
#
# Python stuff to improve portability
#
from __future__ import print_function

#
# Generic python packages used
#
import getpass
import os
import select
import SocketServer
import socket
import sys
import threading
import time

#
# Python packages supplied and needed by xdd
#
import paramiko
import Pyro4
import serpent
import xdd_settings

#
# XDD transfer exceptions
#
class XDDError(Exception):
    """Base class for exceptions in the module."""

    pass

class TransferRemoteError(XDDError):
    """Exceptions raised when the proxy is unable to contact remote."""

    pass

class TransferPreconditionError(XDDError):
    """Exception raised when a flow is unable to be started."""

    pass

class TransferSinkPreconditionError(TransferPreconditionError):
    """Exception raised when a sink flow fails during startup."""

    pass

class TransferSourcePreconditionError(TransferPreconditionError):
    """Exception raised when a source flow fails during startup."""

    pass

#
# Interface classes to interact with local and remote XDD flows
#
class TransferManager:
    """
    Manager for creating, monitoring, and deallocating local and remote flows.
    """

    def __init__(self):
        """ """
        self.isCreated = False
        self.isStarted = False
        self.isComplete = False
        self.isSuccess = False
        self.factory = None
        self.sinks = []
        self.sources = []

    def setSinkTarget(self, target):
        """ Set the name of of the sink target file"""
        assert not self.isCreated
        self.sinkTarget = target

    def setSourceTarget(self, target):
        """Set the name of the source target file"""
        assert not self.isCreated
        self.sourceTarget = target

    def addSink(self, hostname, threads, ifs = []):
        """Add a sink to the list of sinks"""
        assert not self.isCreated
        assert hostname
        assert 0 < threads
        sink = {'hostname': hostname,
         'threads': threads}
        if ifs:
            sink['ifs'] = ifs
        else:
            sink['ifs'] = hostname
        self.sinks.append(sink)

    def addSource(self, hostname, threads, ifs = []):
        """Add a source to the list of sources"""
        assert not self.isCreated
        assert hostname
        assert 0 < threads
        source = {'hostname': hostname,
         'threads': threads}
        if ifs:
            source['ifs'] = ifs
        else:
            source['ifs'] = hostname
        self.sinks.append(source)

    def createFlows(self):
        """Create local and remote flows"""
        assert False == self.isCreated
        self.factory = FlowBuilderFactory(self.sourceTarget, self.sources, 
                                          self.sinkTarget, self.sinks)
        self.factory.createFlows()
        self.isCreated = True
        return 0

    def startFlows(self):
        """Start all flows in correct order"""
        assert True == self.isCreated
        assert False == self.isStarted
        rc = 0
        try:
            sinks = self.factory.getSinkFlows()
            for flow in sinks:
                flow.start()
        except FlowPreconditionError:
            print('Sink flow failed during startup')
            self.cleanupFlows()
            rc = 1
        try:
            sources = self.factory.getSourceFlows()
            for flow in sources:
                flow.start()

        except FlowPreconditionError:
            print('Source flow failed during startup')
            self.cleanupFlows()
            rc = 2
        pri
        if 0 == rc:
            self.isStarted = True
        return rc

    def monitorFlows(self, monitorInterval):
        """Determine if flows are still functioning"""
        assert True == self.isStarted
        flows = self.factory.getFlows()
        success = True
        while success:
            for f in flows:
                if False == f.pollStatus() and 0 != f.completionStatus():
                    return 1
            time.sleep(monitorInterval)

        return 0

    def cleanupFlows(self):
        """
            Determine exit status for stopped flows, and kill any remaining 
            flows
        """
        rc = 0
        if self.factory:
            #flows = self.factory.getFlows()
            #for f in flows:
                #import pdb; pdb.set_trace()
            #    print(f)
            #    if True == f.pollStatus():
            #        f.cancel()
            #        print('Cancelling Flow')
            #        rc = 1
                #elif None != f.completionStatus():
                #    rc = 2
                #    if 0 != f.completionStatus():
                #        print('Flow exited with code:', f.completionStatus())
                #        rc = 3

            self.factory.shutdown()
            del self.factory
        self.isCreate = False
        self.isStarted = False
        self.isCompleted = True
        return rc

    def completedSuccessfully(self):
        """@return true if the flows completed successfully"""
        return self.isComplete and self.isSuccess


class FlowBuilderFactory:
    """
      The factory class that builds each of the flows (locally or remote
      as required)
    """

    def __init__(self, sourceTarget, sources, sinkTarget, sinks):
        """Constructor"""
        self.remoteTransports = {}
        self.sourceTarget = sourceTarget
        self.sources = sources
        self.sinkTarget = sinkTarget
        self.sinks = sinks
        self.sinkFlows = []
        self.sourceFlows = []
        self.allFlows = []
        self.allBuilders = []

    def shutdown(self):
        """Shutdown all flow builders"""
        for (h, b) in self.remoteTransports.items():
            b.shutdown()
        
    def getFlowBuilders(self):
        """Return all flows"""
        return self.allFlows

    def getSinkFlowBuilders(self):
        """Return sink flows"""
        return self.sinkFlows

    def getSourceFlowBuilders(self):
        """Return source flows"""
        return self.sourceFlows

    def buildFlowBuilder(self, flowSpec):
        """Create an individual flow builder"""
        b = None
        hostname = flowSpec['hostname']
        if 'localhost' == hostname or '127.0.0.1' == hostname:
            print('Creating local flow')
            b = FlowBuilder()
        else:
            # Build a remote transport
            trans = FlowBuilderTransport(hostname)
            # Extract the flow builder proxy from the transport
            b = trans.getFlowBuilder()
            self.remoteTransports[hostname] = trans
        return b

    def createFlows(self):
        """Create the flow builders on each source and sink"""
        for spec in self.sinks:
            b = self.buildFlowBuilder(spec)
            b.buildFlow(sinkFlag=True, target=self.sinkTarget, 
                        dioFlag=False, serialFlag=False)
            self.sinkFlows.append(b)
            self.allFlows.append(b)

        for spec in self.sources:
            b = self.buildFlowBuilder(spec)
            b.buildFlow(sinkFlag=False, target=self.sinkTarget, 
                        dioFlag=False, serialFlag=False)
            self.sourceFlows.append(b)
            self.allFlows.append(b)

#
# Internal classes not designed for client use
#
class FlowBuilderTransportError(XDDError):
    """Exception raised when the flow proxy encounters problems."""

class FlowBuilderTransportForwardingServer(SocketServer.TCPServer):
    """
    SSH forwarding server to forward traffic over the forwarded ssh channel
    """
    daemon_threads = True
    allow_reuse_address = True
    
    def setTransport(self, transport, remoteAddr):
        """Set instance variables used by the underlying handler""" 
        self.transport = transport
        self.remoteAddr = remoteAddr

class FlowBuilderTransportForwardingHandler(SocketServer.BaseRequestHandler):
    """
    Request handler that establishes the forwarding SSH tunnel and 
    passes traffic over the tunnel as it is received
    """
    def handle(self):

        # Determine the SSH transport, remote hostname, and remote port
        sshTransport = self.server.transport
        remoteAddr = self.server.remoteAddr

        # The first time this function is invoked is by the instantiator
        try:
            destAddr = remoteAddr
            srcAddr = self.server.server_address
            channel = sshTransport.open_channel('direct-tcpip', 
                                                destAddr, 
                                                srcAddr)
        except paramiko.SSHException, e:
            print("ERROR: Unable to open channel for the existing transport:",
                  e)
            return
        except Exception, e:
            print("ERROR: Unable to create SSH forward channel.")
            import sys
            eInfo = sys.exc_info()[0]
            print("Exception:", e)
            print("Info:", eInfo)
            return

        # Forward the data through this server
        while True:
            r,w,x = select.select([self.request, channel], [], [])
            if self.request in r:
                data = self.request.recv(1024)
                if 0 == len(data):
                    break
                channel.send(data)
            if channel in r:
                data = channel.recv(1024)
                if 0 == len(data):
                    break
                self.request.send(data)

        channel.close()
        self.request.close()
        print("Tunnel closed.")                
            

class FlowBuilderTransport:
    """
        Paramiko client that creates a FlowBuilderServer
    """
    def __init__(self, host):
        """Constructor"""
        # Start the remote service
        (ssh, uri) = self.createRemoteServer(host)
        self.host = host
        self.ssh = ssh
        self.remoteURI = uri

        # Port forward the remote service using SSH
        fields = uri.rsplit(':', 1)
        pyroPort = int(fields[1])
        (server, thread, port) = self.startLocalForwarder(pyroPort)
        self.remotePort = pyroPort
        self.localPort = port
        self.forwardingServer = server
        self.forwardingThread = thread

        # Modify the Pyro URI so that we use the locally forwarded server
        # and port rather than the remote end.  Since the host is already
        # 'localhost' on the remote side, the host is correct, just need
        # to use the locally forwarded port
        self.localURI = fields[0] + ':' + str(self.localPort)

        # Use the tunnel to retrieve the flow builder proxy
        #print("URI: >", self.localURI, "<", sep='')
        flowBuilder = Pyro4.Proxy(self.localURI)
        self.flowBuilder = flowBuilder

        # Quickly test the flowbuilder
        print("FlowBuilder is ready:", self.flowBuilder.isReady())
        
    def shutdown(self):
        """
        Stop the remote pyro server, the local forwarding server and terminate 
        the ssh connection
        """
        print("Testing Proxy during shutdown", self.flowBuilder.test())
        #try:
        #    self.flowBuilder.shutdown();
        #except Pyro4.errors.ConnectionClosedError:
        #     The only way to shutdown the server is via the Pyro object
        #     So the return from the RMI fails.  Which is not ideal, but its
        #     relatively safe since we are on our way out anyway.
        #    pass
        #self.forwardingServer.shutdown()
        self.forwardingThread.join()
        self.ssh.close()

    def createRemoteServer(self, host):
        """"Create the remote pyro server using paramiko"""
        print('Creating remote flow on', host)
        uri = None
        ssh = paramiko.SSHClient()
        ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())
        try:
            ssh.connect('bws-mbpro2')
        except paramiko.AuthenticationException:
            print('Unable to authenticate SSH at', host)
        except paramiko.BadHostKeyException:
            print('Bad host key', host)
        except:
            print('Unknown SSH error for', host)
            import sys
            e = sys.exc_info()[0]
            print(e)
        try:
            # Set the keep alive interval
            ssh.get_transport().set_keepalive(5)

            # Start the xdd flow server
            cmd = 'PYTHONPATH=' + xdd_settings.XDD_PYTHONPATH + ':$PYTHONPATH '
            cmd += 'python -m xdd'
            #print("Cmd is: ", cmd)

            (stdin, stdout, stderr) = ssh.exec_command(cmd)
            
            # Convert the returned stuff into something useful
            channel = stdin.channel

            # Wait for the buffer to fill
            while (not channel.recv_ready()) and \
                  (not channel.exit_status_ready()):
                pass

            # If the command exited, something went wrong
            if channel.exit_status_ready():
                print("Error: Unable to start remote XDD flow server:", 
                      channel.recv_exit_status)
                for line in stdout:
                    print(host, "stdout:", line)
                for line in stderr:
                    print(host, "stderr", line)
            else:
                # Read stdout to find the delimited URI
                uri = None
                foundDelim = False;
                i = 0
                while None == uri and (not channel.exit_status_ready()):
                    line = stdout.readline()
                    #print("Line", line)
                    if line:
                        token = line.rstrip('\n')
                        if foundDelim:
                            uri = token
                            foundDelim = False
                            break
                        elif xdd_settings.XDD_PYRO_URI_DELIMITER == token:
                            foundDelim = True 
                    else:
                        break
                    
                # If the URI is invalid, trigger an error
                if None == uri:
                    print("ERROR: XDD flow server terminated prematurely")
                    for line in stdout:
                        print(host, "stderr", line)
                    raise FlowBuilderTransportError()
                
        except paramiko.SSHException, e:
            print('SSH Exception', host, e)

        # Return the SSH session and URI
        return (ssh, uri)

    def startLocalForwarder(self, pyroPort):
        """
        Establish an ssh tunnel and start a thread that forwards TCP
        requests on the local host to the server running on the remote host.
        """
        # Start a forwarding server and set SSH forwarding attributes
        pyroListenAddr = ('localhost', pyroPort)
        localListenAddr = ('localhost', 0)
        forwardServer = FlowBuilderTransportForwardingServer(
            localListenAddr, FlowBuilderTransportForwardingHandler)
        forwardServer.setTransport(self.ssh.get_transport(), pyroListenAddr)

        # Start the forwarding server in its own thread so we don't block
        # waiting to handle requests
        forwardThread = threading.Thread(target=forwardServer.serve_forever)
        forwardThread.daemon = True
        forwardThread.start()

        # Retrieve the local port for the forwarding server
        (host,port) = forwardServer.server_address

        return (forwardServer, forwardThread, port)

    
    def getFlowBuilder(self):
        """Return the flow builder object"""
        return self.flowBuilder

class Flow:
    """
    Class that starts, stops, and monitors an XDD flow.  Since this class 
    starts and monitors a UNIX process, it is by its nature not serializable,
    and should rarely be used directly.  Instead, you should generally use a
    FlowBuilder (either directly, or via a Pyro Proxy) to interact with flows
    """

    def __init__(self, target, dioFlag, serialFlag):
        self.completionStatus = None
        self.target = target
        self.dio = dioFlag
        self.serial = serialFlag

    def start(self):
        """Start an XDD process to perform work"""
        print('Starting Flow' + self.target)

    def cancel(self):
        """Cancel the underlying XDD process that does the work"""
        print('Cancelling flow.')

    def pollStatus(self):
        """@return True if the XDD process is still active, otherwise False"""
        return False

    def completionStatus(self):
        """@return XDD return code"""
        return self.completionStatus


class FlowBuilder:
    """
    Helper class that builds flows and dispatches messages to the flow
    """
    def __init__(self):
        """Constructor"""
        pass

    def shutdown(self):
        """Shutdown"""
        pass

    def buildFlow(self, sinkFlag, target, dioFlag, serialFlag):
        """Create the Flow"""
        self.flow = Flow(target, dioFlag, serialFlag)

    def start(self):
        return self.flow.start()

    def cancel(self):
        return self.flow.cancel()

    def pollStatus(self):
        return self.flow.pollStatus()

    def completionStatus(self):
        return self.flow.completionStatus()


class RemoteFlowBuilder(FlowBuilder):
    """
    Pyro helper class that builds remote flows and dispatches messages to the 
    flow
    """

    def __init__(self, daemon):
        """Constructor"""
        self.daemon = daemon
        self.i = 0

    def shutdown(self):
        """Stop the pyro daemon"""
        self.daemon.shutdown()

    def isReady(self):
        """
        Returns True when the proxy is established.  Pyro throws an internal
        exception (usually Pyro4.errors.ConnectionClosedError) if the
        service or transport are not ready
        """
        return True

    def test(self):
        """Return a test string"""
        self.i += 1
        return "Test string " + str(self.i)


def main():
    """Main to run an actual XDD Flow Server"""

    # Create the server
    daemon = None
    try:
        # Let the daemon find a port on its own
        daemon = Pyro4.Daemon(host='127.0.0.1', port=0)
    except socket.error:
        print("Pyro connection error.")

    except:
        print("Pyro unknown error.")
        e = sys.exc_info()[0]
        print(str(e))
        
    flowBuilder = RemoteFlowBuilder(daemon)
    uri = daemon.register(flowBuilder)

    # Publish the URI over stdout
    print(xdd_settings.XDD_PYRO_URI_DELIMITER)
    sys.stdout.flush()
    print (uri)
    sys.stdout.flush()
    print(xdd_settings.XDD_PYRO_URI_DELIMITER)
    sys.stdout.flush()
    sys.stdout.flush()

    # Daemonize and wait for requests
    daemon.requestLoop()
    return 0


if __name__ == '__main__':
    main()

