
#
# Python stuff to improve portability
#
from __future__ import print_function

#
# Generic python packages used
#
import getpass
import os
import select
import SocketServer
import socket
import subprocess
import sys
import threading
import time
from stat import *

#
# Python packages supplied and needed by xdd
#
import paramiko
import Pyro4
import serpent
import xdd_settings

#
# XDD transfer exceptions
#
class XDDError(Exception):
    """Base class for exceptions in the module."""

    pass

class TransferRemoteError(XDDError):
    """Exceptions raised when the proxy is unable to contact remote."""

    pass

class TransferPreconditionError(XDDError):
    """Exception raised when a flow is unable to be started."""

    pass

class TransferSinkPreconditionError(TransferPreconditionError):
    """Exception raised when a sink flow fails during startup."""

    pass

class TransferSourcePreconditionError(TransferPreconditionError):
    """Exception raised when a source flow fails during startup."""

    pass

#
# Interface classes to interact with local and remote XDD flows
#
class TransferManager:
    """
    Manager for creating, monitoring, and deallocating local and remote flows.
    """

    def __init__(self):
        """Constructor"""
        self.isCreated = False
        self.isStarted = False
        self.isComplete = False
        self.isSuccess = False
        self.factory = None

        self.requestSize = 0
        self.transferSize = 0
        self.restartFlag = False
        self.restartOffset = True
        self.sinkDIOFlag = False
        self.sinkSerialFlag = False
        self.sinkTarget = None
        self.sinks = []
        self.sourceDIOFlag = False
        self.sourceSerialFlag = False
        self.sourceTarget = None
        self.sources = []

    def setRequestSize(self, reqSize):
        """Set the chunk size of data to move across the wire"""
        self.requestSize = reqSize
        
    def setTransferSize(self, transferSize):
        """Set the size of data to move across the wire"""
        self.transferSize = transferSize
        
    def setRestartOffset(self, restartOffset):
        """Set the amount of data previously sent across the wire"""
        self.restartFlag = True
        self.restartOffset = restartOffset
        
    def setSinkTarget(self, target, dioFlag=False, serialFlag=False):
        """ Set the name of of the sink target file"""
        assert not self.isCreated
        self.sinkTarget = target
        self.sinkDIOFlag = dioFlag
        self.sinkSerialFlag = serialFlag

    def setSourceTarget(self, target, dioFlag=False, serialFlag=False):
        """Set the name of the source target file"""
        assert not self.isCreated
        self.sourceTarget = target
        self.sourceDIOFlag = dioFlag
        self.sourceSerialFlag = serialFlag

    def setVerbosity(self, verboseLevel):
        """Set the level of verbosity"""
        verboseFlag = True
        self.timestampFlag = True

    def addSink(self, hostname, threads, ifs = []):
        """Add a sink to the list of sinks"""
        assert not self.isCreated
        assert hostname
        assert 0 < threads
        sink = {'hostname': hostname,
         'threads': threads}
        if ifs:
            sink['ifs'] = ifs
        else:
            sink['ifs'] = hostname
        self.sinks.append(sink)

    def addSource(self, hostname, threads, ifs = []):
        """Add a source to the list of sources"""
        assert not self.isCreated
        assert hostname
        assert 0 < threads
        source = {'hostname': hostname,
         'threads': threads}
        if ifs:
            source['ifs'] = ifs
        else:
            source['ifs'] = hostname
        self.sinks.append(source)

    def createFlows(self):
        """Create local and remote flows"""
        assert False == self.isCreated
        assert 0 < self.requestSize
        assert 0 < self.transferSize
        self.factory = FlowBuilderFactory(self.sourceTarget, self.sources, 
                                          self.sinkTarget, self.sinks)
        self.factory.createFlows()
        self.isCreated = True
        return 0

    def startFlows(self):
        """Start all flows in correct order"""
        assert True == self.isCreated
        assert False == self.isStarted
        rc = 0
        try:
            sinks = self.factory.getSinkFlowBuilders()
            for s in sinks:
                s.start()
        except TransferPreconditionError:
            print('Sink flow failed during startup')
            self.cleanupFlows()
            rc = 1
        try:
            sources = self.factory.getSourceFlowBuilders()
            for s in sources:
                s.start()
        except TransferPreconditionError:
            print('Source flow failed during startup')
            self.cleanupFlows()
            rc = 2

        if 0 == rc:
            self.isStarted = True
        return rc

    def monitorFlows(self, monitorInterval):
        """Determine if flows are still functioning"""
        assert True == self.isStarted
        builders = self.factory.getFlowBuilders()
        success = True
        while success:
            for b in builders:
                if False == b.pollStatus() and 0 != b.completionStatus():
                    return 1
            time.sleep(monitorInterval)

        return 0

    def cleanupFlows(self):
        """
        Determine exit status for stopped flows, and kill any remaining flows
        """
        rc = 0
        if self.factory:
            #flows = self.factory.getFlows()
            #for f in flows:
                #import pdb; pdb.set_trace()
            #    print(f)
            #    if True == f.pollStatus():
            #        f.cancel()
            #        print('Cancelling Flow')
            #        rc = 1
                #elif None != f.completionStatus():
                #    rc = 2
                #    if 0 != f.completionStatus():
                #        print('Flow exited with code:', f.completionStatus())
                #        rc = 3

            self.factory.shutdown()
            del self.factory
        self.isCreate = False
        self.isStarted = False
        self.isCompleted = True
        return rc

    def completedSuccessfully(self):
        """@return true if the flows completed successfully"""
        return self.isComplete and self.isSuccess


class FlowBuilderFactory:
    """
      The factory class that builds each of the flows (locally or remote
      as required)
    """

    def __init__(self, sourceTarget, sources, sinkTarget, sinks):
        """Constructor"""
        self.remoteTransports = {}
        self.sourceTarget = sourceTarget
        self.sources = sources
        self.sinkTarget = sinkTarget
        self.sinks = sinks
        self.sinkFlows = []
        self.sourceFlows = []
        self.allFlows = []
        self.allBuilders = []

    def shutdown(self):
        """Shutdown all flow builders"""
        for (h, b) in self.remoteTransports.items():
            b.shutdown()
        
    def getFlowBuilders(self):
        """Return all flows"""
        return self.allFlows

    def getSinkFlowBuilders(self):
        """Return sink flows"""
        return self.sinkFlows

    def getSourceFlowBuilders(self):
        """Return source flows"""
        return self.sourceFlows

    def buildFlowBuilder(self, flowSpec):
        """Create an individual flow builder"""
        b = None
        hostname = flowSpec['hostname']
        if 'localhost' == hostname or '127.0.0.1' == hostname:
            print('Creating local flow')
            b = FlowBuilder()
        else:
            # Build a remote transport
            trans = FlowBuilderTransport(hostname)
            # Extract the flow builder proxy from the transport
            b = trans.getFlowBuilder()
            self.remoteTransports[hostname] = trans
        return b

    def createFlows(self):
        """Create the flow builders on each source and sink"""
        for spec in self.sinks:
            b = self.buildFlowBuilder(spec)
            b.buildFlow(sinkFlag=True, target=self.sinkTarget, 
                        reqSize=self.reqSize, dataSize=self.dataSize,
                        flowIdx=0, numFlows=1,
                        restartFlag=self.restartFlag, 
                        restartOffset=self.restartOffset,
                        ifaces=self.ifaces,
                        dioFlag=False, serialFlag=False, verboseFlag=False, 
                        timestampFlag=False)
            self.sinkFlows.append(b)
            self.allFlows.append(b)

        for spec in self.sources:
            b = self.buildFlowBuilder(spec)
            b.buildFlow(sinkFlag=False, target=self.sourceTarget,
                        reqSize=self.reqSize, dataSize=self.dataSize,
                        flowIdx=0, numFlows=1,
                        restartFlag=self.restartFlag, 
                        restartOffset=self.restartOffset,
                        ifaces=self.ifaces,
                        dioFlag=False, serialFlag=False, verboseFlag=False, 
                        timestampFlag=False)
            self.sourceFlows.append(b)
            self.allFlows.append(b)

#
# Internal classes not designed for client use
#
class FlowBuilderTransportError(XDDError):
    """Exception raised when the flow proxy encounters problems."""

class FlowBuilderTransportForwardingServer(SocketServer.TCPServer):
    """
    SSH forwarding server to forward traffic over the forwarded ssh channel
    """
    daemon_threads = True
    allow_reuse_address = True
    
    def setTransport(self, transport, remoteAddr):
        """Set instance variables used by the underlying handler""" 
        self.transport = transport
        self.remoteAddr = remoteAddr

class FlowBuilderTransportForwardingHandler(SocketServer.BaseRequestHandler):
    """
    Request handler that establishes the forwarding SSH tunnel and 
    passes traffic over the tunnel as it is received
    """
    def handle(self):

        # Determine the SSH transport, remote hostname, and remote port
        sshTransport = self.server.transport
        remoteAddr = self.server.remoteAddr

        # The first time this function is invoked is by the instantiator
        try:
            destAddr = remoteAddr
            srcAddr = self.server.server_address
            channel = sshTransport.open_channel('direct-tcpip', 
                                                destAddr, 
                                                srcAddr)
        except paramiko.SSHException, e:
            print("ERROR: Unable to open channel for the existing transport:",
                  e)
            return
        except Exception, e:
            print("ERROR: Unable to create SSH forward channel.")
            import sys
            eInfo = sys.exc_info()[0]
            print("Exception:", e)
            print("Info:", eInfo)
            return

        # Forward the data through this server
        while True:
            r,w,x = select.select([self.request, channel], [], [])
            if self.request in r:
                data = self.request.recv(1024)
                if 0 == len(data):
                    break
                channel.send(data)
            if channel in r:
                data = channel.recv(1024)
                if 0 == len(data):
                    break
                self.request.send(data)

        channel.close()
        self.request.close()
        print("Tunnel closed.")                
            

class FlowBuilderTransport:
    """
    Paramiko client that creates a FlowBuilderServer
    """
    def __init__(self, host):
        """Constructor"""
        # Start the remote service
        (ssh, uri) = self.createRemoteServer(host)
        self.host = host
        self.ssh = ssh
        self.remoteURI = uri

        # Port forward the remote service using SSH
        fields = uri.rsplit(':', 1)
        pyroPort = int(fields[1])
        (server, thread, port) = self.startLocalForwarder(pyroPort)
        self.remotePort = pyroPort
        self.localPort = port
        self.forwardingServer = server
        self.forwardingThread = thread

        # Modify the Pyro URI so that we use the locally forwarded server
        # and port rather than the remote end.  Since the host is already
        # 'localhost' on the remote side, the host is correct, just need
        # to use the locally forwarded port
        self.localURI = fields[0] + ':' + str(self.localPort)

        # Use the tunnel to retrieve the flow builder proxy
        #print("URI: >", self.localURI, "<", sep='')
        flowBuilder = Pyro4.Proxy(self.localURI)
        self.flowBuilder = flowBuilder

        # Quickly test the flowbuilder
        print("FlowBuilder is ready:", self.flowBuilder.isReady())
        
    def shutdown(self):
        """
        Stop the remote pyro server, the local forwarding server and terminate 
        the ssh connection
        """
        print("Testing Proxy during shutdown", self.flowBuilder.test())
        try:
            self.flowBuilder.shutdown();
        except Pyro4.errors.ConnectionClosedError:
            # The only way to shutdown the server is via the Pyro object
            # So the return from the RMI fails.  Which is not ideal, but its
            # relatively safe since we are on our way out anyway.
            pass
        self.forwardingServer.shutdown()
        self.forwardingThread.join()
        self.ssh.close()

    def createRemoteServer(self, host):
        """"Create the remote pyro server using paramiko"""
        print('Creating remote flow on', host)
        uri = None
        ssh = paramiko.SSHClient()
        ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())
        try:
            ssh.connect('bws-mbpro2')
        except paramiko.AuthenticationException:
            print('Unable to authenticate SSH at', host)
        except paramiko.BadHostKeyException:
            print('Bad host key', host)
        except:
            print('Unknown SSH error for', host)
            import sys
            e = sys.exc_info()[0]
            print(e)
        try:
            # Set the keep alive interval
            ssh.get_transport().set_keepalive(5)

            # Start the xdd flow server
            cmd = 'PYTHONPATH=' + xdd_settings.XDD_PYTHONPATH + ':$PYTHONPATH '
            cmd += 'python -m xdd'
            #print("Cmd is: ", cmd)

            (stdin, stdout, stderr) = ssh.exec_command(cmd)
            
            # Convert the returned stuff into something useful
            channel = stdin.channel

            # Wait for the buffer to fill
            while (not channel.recv_ready()) and \
                  (not channel.exit_status_ready()):
                pass

            # If the command exited, something went wrong
            if channel.exit_status_ready():
                print("Error: Unable to start remote XDD flow server:", 
                      channel.recv_exit_status)
                for line in stdout:
                    print(host, "stdout:", line)
                for line in stderr:
                    print(host, "stderr", line)
            else:
                # Read stdout to find the delimited URI
                uri = None
                foundDelim = False;
                i = 0
                while None == uri and (not channel.exit_status_ready()):
                    line = stdout.readline()
                    #print("Line", line)
                    if line:
                        token = line.rstrip('\n')
                        if foundDelim:
                            uri = token
                            foundDelim = False
                            break
                        elif xdd_settings.XDD_PYRO_URI_DELIMITER == token:
                            foundDelim = True 
                    else:
                        break
                    
                # If the URI is invalid, trigger an error
                if None == uri:
                    print("ERROR: XDD flow server terminated prematurely")
                    for line in stdout:
                        print(host, "stderr", line)
                    raise FlowBuilderTransportError()
                
        except paramiko.SSHException, e:
            print('SSH Exception', host, e)

        # Return the SSH session and URI
        return (ssh, uri)

    def startLocalForwarder(self, pyroPort):
        """
        Establish an ssh tunnel and start a thread that forwards TCP
        requests on the local host to the server running on the remote host.
        """
        # Start a forwarding server and set SSH forwarding attributes
        pyroListenAddr = ('localhost', pyroPort)
        localListenAddr = ('localhost', 0)
        forwardServer = FlowBuilderTransportForwardingServer(
            localListenAddr, FlowBuilderTransportForwardingHandler)
        forwardServer.setTransport(self.ssh.get_transport(), pyroListenAddr)

        # Start the forwarding server in its own thread so we don't block
        # waiting to handle requests
        forwardThread = threading.Thread(target=forwardServer.serve_forever)
        forwardThread.daemon = True
        forwardThread.start()

        # Retrieve the local port for the forwarding server
        (host,port) = forwardServer.server_address

        return (forwardServer, forwardThread, port)

    
    def getFlowBuilder(self):
        """Return the flow builder object"""
        return self.flowBuilder

class Flow:
    """
    Class that starts, stops, and monitors an XDD flow.  Since this class 
    starts and monitors a UNIX process, it is by its nature not serializable,
    and should rarely be used directly.  Instead, you should generally use a
    FlowBuilder (either directly, or via a Pyro Proxy) to interact with flows
    """

    def __init__(self, isSink, target, reqSize, dataSize, 
                 flowIdx, numFlows, restartFlag, restartOffset, ifaces,
                 dioFlag, serialFlag, verboseFlag, timestampFlag):
        self.isSink = isSink
        self.target = target
        self.reqSize = reqSize
        self.dataSize = dataSize
        self.flowIdx = flowIdx,
        self.numFlows = numFlows
        self.restart = restartFlag
        self.restartOffset = restartOffset
        self.ifaces = ifaces
        self.dio = dioFlag
        self.serial = serialFlag
        self.verbose = verboseFlag
        self.timestamp = timestampFlag

        self.completionStatus = None
        self.process = None
        self.reasons = ["Some error"]

    def checkSinkPreconditions(self):
        """
        Checks the following preconditions for a sink:
          Either file exists and is writable or 
                 parent directory exists and is searchable and writable
          The data size provided maskes sense
          The dio flag is not set for character devices
        """
        assert self.isSink
        passes = True

        # Determine if the path exists
        if os.path.exists(self.target):
            # Check other preconditions based on file type
            res = os.stat(self.target)
            if S_ISREG(res.st_mode) or S_ISLNK(res.st_mode):
                # For regular files and links just check read permission
                if not os.access(self.target, os.R_OK):
                    self.reasons.append("Cannot read source: " + self.target)
                    passes = False;
            elif S_ISBLK(res.st_mode):
                # For block devices check read permissions
                if not os.access(self.target, os.R_OK):
                    self.reasons.append("Cannot read block device: " + 
                                        self.target)
                    passes = False;
            elif S_ISCHR(res.st_mode):
                # For character devices, check that DIO is off
                if not os.access(self.target, os.R_OK):
                    self.reasons.append("Cannot read character device: " + 
                                        self.target)
                    passes = False;
                elif self.dio:
                    self.reasons.append("Device does not support Direct I/O: " +
                                        self.target)
                    passes = False;
            else:
                passes = False
                self.reasons.append("Target is unsupported file type:" + 
                                    self.target)
        else:
            # Check the parent directory for existence
            parentDir = os.path.dirname(self.target)
            if not os.path.exists(parentDir):
                reasons.append("Parent directory does not exist: " +
                               self.target)
                passes = False
            elif not os.access(parentDir, os.W_OK):
                self.reasons.append("Cannot write parent directory" + 
                                    self.target)
                passes = False
        return passes

    def checkSourcePreconditions(self):
        """
        Check the following preconditions for a source:
          - The file exists
          - The file is readable
          - If the file is a block device or file, it is large enough to
            satisfy the data size
          - If the file is a character device, the data size must be positive
          - DIO can only be set for block devices and file
        """
        assert not self.isSink
        passes = True
        
        # Ensure the source exists
        if not os.path.exists(self.target):
            self.reasons.append("Target does not exist: " + self.target)
            passes = False
        else:
            # Check other preconditions based on file type
            res = os.stat(self.target)
            if S_ISREG(res.st_mode) or S_ISLNK(res.st_mode):
                # For regular files and links just check read permission
                if not os.access(self.target, os.R_OK):
                    self.reasons.append("Cannot read source: " + self.target)
                    passes = False;
            elif S_ISBLK(res.st_mode):
                # For block devices check read permissions
                if not os.access(self.target, os.R_OK):
                    self.reasons.append("Cannot read block device: " + 
                                        self.target)
                    passes = False;
            elif S_ISCHR(res.st_mode):
                # For character devices, check that DIO is off
                if not os.access(self.target, os.R_OK):
                    self.reasons.append("Cannot read character device: " + 
                                        self.target)
                    passes = False;
                elif self.dio:
                    self.reasons.append("Device does not support Direct I/O: " +
                                        self.target)
                    passes = False;
            else:
                passes = False
                self.reasons.append("Target is unsupported file type:" + 
                                    self.target)
        return passes

    def checkPreconditions(self):
        """
        Checks preconditions to ensure the XDD process should start correctly
        """        
        if self.isSink:
            passes = self.checkSinkPreconditions()
        else:
            passes = self.checkSourcePreconditions()
        return passes

    def createCommandArgs(self):
        """Return the command used to start the XDD process"""
        # Assemble the basic file system command
        cmd = ['xdd', '-target', self.target]
        if self.isSink:
            cmd.extend(['-op', 'write', '-e2e', 'isdest'])
        else:
            cmd.extend(['-op', 'read', '-e2e', 'issource'])
        cmd.extend(['-reqsize', str(self.reqSize), '-bytes', str(self.dataSize)])
        # Add interfaces for network
        for iface in self.ifaces:
            # Determine if optional NUMA has been supplied
            if 4 == len(iface):
                (host, port, threads, numa) = iface
            else:
                (host, port, threads) = iface
                numa = None
            spec = host + ':' + str(port) + ',' + str(threads)
            if numa:
                spec += ',' + numa
            cmd.extend(['-e2e', 'dest', spec])
            
        
        # Process flags
        if self.dio:
            cmd.append('-dio')
        if not self.serial:
            if not self.isSink:
                cmd.append('-looseordering')
            else:
                cmd.append('-noordering')
        else:
            cmd.append('-serialordering')


        # Add on all of the standard output stuff
        cmd.extend(['-verbose', '-minall', '-stoponerror'])

        # Add the heartbeat stuff on the source
        if not self.isSink:
            cmd.extend(['-hb', '4', '-hb', 'pct', '-hb', 'bw'])
        return cmd

    def start(self):
        """Start an XDD process to perform work"""
        assert self.process is None

        # Check preconditions
        self.checkPreconditions()

        # Print out a diagnostic of the command
        args = self.createCommandArgs()
        process = subprocess.Popen(args)

    def cancel(self):
        """Cancel the underlying XDD process that does the work"""
        print('Cancelling flow.')

    def pollStatus(self):
        """@return True if the XDD process is still active, otherwise False"""
        return False

    def completionStatus(self):
        """@return XDD return code"""
        return self.completionStatus


class FlowBuilder:
    """
    Helper class that builds flows and dispatches messages to the flow
    """
    def __init__(self):
        """Constructor"""
        pass

    def shutdown(self):
        """Shutdown"""
        pass

    def buildFlow(self, isSink, target, reqSize, dataSize, 
                  flowIdx, numFlows, restartFlag, restartOffset, ifaces,
                  dioFlag, serialFlag, verboseFlag, timestampFlag):
        """Create the Flow"""
        self.flow = Flow(isSink, target, reqSize, dataSize, 
                         flowIdx, numFlows, restartFlag, restartOffset, ifaces,
                         dioFlag, serialFlag, verboseFlag, timestampFlag)

    def start(self):
        """Start an XDD process"""
        return self.flow.start()

    def cancel(self):
        """Stop a running XDD process"""
        return self.flow.cancel()

    def pollStatus(self):
        """Return the current state of a running XDD process"""
        return self.flow.pollStatus()

    def completionStatus(self):
        """Return the return code from the XDD process"""
        return self.flow.completionStatus()


class RemoteFlowBuilder(FlowBuilder):
    """
    Pyro helper class that builds remote flows and dispatches messages to the 
    flow
    """

    def __init__(self, daemon):
        """Constructor"""
        self.daemon = daemon
        self.i = 0

    def shutdown(self):
        """Stop the pyro daemon"""
        self.daemon.shutdown()

    def isReady(self):
        """
        Returns True when the proxy is established.  Pyro throws an internal
        exception (usually Pyro4.errors.ConnectionClosedError) if the
        service or transport are not ready
        """
        return True

    def test(self):
        """Return a test string"""
        self.i += 1
        return "Test string " + str(self.i)


def main():
    """Main to run an actual XDD Flow Server"""

    # Create the server
    daemon = None
    try:
        # Let the daemon find a port on its own
        daemon = Pyro4.Daemon(host='127.0.0.1', port=0)
    except socket.error:
        print("Pyro connection error.")

    except:
        print("Pyro unknown error.")
        e = sys.exc_info()[0]
        print(str(e))
        
    flowBuilder = RemoteFlowBuilder(daemon)
    uri = daemon.register(flowBuilder)

    # Publish the URI over stdout
    print(xdd_settings.XDD_PYRO_URI_DELIMITER)
    sys.stdout.flush()
    print (uri)
    sys.stdout.flush()
    print(xdd_settings.XDD_PYRO_URI_DELIMITER)
    sys.stdout.flush()
    sys.stdout.flush()

    # Daemonize and wait for requests
    daemon.requestLoop()
    return 0


if __name__ == '__main__':
    main()

