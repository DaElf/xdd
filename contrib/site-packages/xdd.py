
#
# Python stuff to improve portability
#
from __future__ import print_function

#
# Generic python packages used
#
import datetime
import fcntl
import getpass
import os
import select
import SocketServer
import socket
import subprocess
import sys
import threading
import time
from stat import *

#
# Python packages supplied and needed by xdd
#
import paramiko
import Pyro4
import serpent
import xdd_settings

#
# XDD transfer exceptions
#
class XDDError(Exception):
    """Base class for exceptions in the module."""

    pass

class TransferRemoteError(XDDError):
    """Exceptions raised when the proxy is unable to contact remote."""

    pass

class TransferPreconditionError(XDDError):
    """Exception raised when a flow is unable to be started."""

    pass

class TransferSinkPreconditionError(TransferPreconditionError):
    """Exception raised when a sink flow fails during startup."""

    pass

class TransferSourcePreconditionError(TransferPreconditionError):
    """Exception raised when a source flow fails during startup."""

    pass

#
# Interface classes to interact with local and remote XDD flows
#
class TransferManager:
    """
    Manager for creating, monitoring, and deallocating local and remote flows.
    """

    def __init__(self):
        """Constructor"""
        self.isCreated = False
        self.isStarted = False
        self.isComplete = False
        self.isSuccess = False
        self.factory = None
        self.beginTime = None

        self.requestSize = 0
        self.transferSize = 0
        self.restartFlag = False
        self.sinkDIOFlag = False
        self.sinkSerialFlag = False
        self.sinkTimestampFlag = False
        self.sinkVerboseFlag = False
        self.sinkTarget = None
        self.sinkXddPath = ''
        self.sinks = []
        self.sourceDIOFlag = False
        self.sourceSerialFlag = False
        self.sourceVerboseFlag = False
        self.sourceTimestampFlag = False
        self.sourceTarget = None
        self.sourceXddPath = ''
        self.sources = []

    def setRequestSize(self, reqSize):
        """Set the chunk size of data to move across the wire"""
        self.requestSize = reqSize
        
    def setTransferSize(self, transferSize):
        """Set the size of data to move across the wire"""
        self.transferSize = transferSize
        
    def setRestartFlag(self, restartFlag):
        """Set the amount of data previously sent across the wire"""
        self.restartFlag = True
        
    def setSinkTarget(self, target, dioFlag=False, serialFlag=False):
        """ Set the name of of the sink target file"""
        assert not self.isCreated
        self.sinkTarget = target
        self.sinkDIOFlag = dioFlag
        self.sinkSerialFlag = serialFlag

    def setSourceTarget(self, target, dioFlag=False, serialFlag=False):
        """Set the name of the source target file"""
        assert not self.isCreated
        self.sourceTarget = target
        self.sourceDIOFlag = dioFlag
        self.sourceSerialFlag = serialFlag

    def setVerbosity(self, verboseLevel, filename):
        """Set the level of verbosity"""
        if 1 <= verboseLevel:
            self.verboseFlag = True
        if 2 <= verboseLevel:
            self.timestampFlag = True
        self.verboseLog = filename

    def addSink(self, hostname, threads, ifs = [], port = 40000):
        """Add a sink to the list of sinks"""
        assert not self.isCreated
        assert hostname
        assert 0 < threads
        sink = {'hostname': hostname, 'threads': threads, 
                'port': port, 'ifs': []}
        if 0 == len(ifs):
            sink['ifs'].append(hostname)
        else:
            sink['ifs'].extend(ifs)
        self.sinks.append(sink)

    def addSource(self, hostname, threads, ifs = [], port = 40000):
        """Add a source to the list of sources"""
        assert not self.isCreated
        assert hostname
        assert 0 < threads
        source = {'hostname': hostname, 'threads': threads, 
                  'port': port, 'ifs': []}
        if 0 == len(ifs):
            source['ifs'].append(hostname)
        else:
            source['ifs'].extend(ifs)
        self.sources.append(source)

    def setSinkXddPath(self, path):
        """Set the path sinks use to find xdd"""
        self.sinkXddPath = path

    def setSourceXddPath(self, path):
        """Set the path sources use to find xdd"""
        self.sourceXddPath = path

    def performPostCreateChecks(self):
        """@return 0 if all checks pass, otherwise non-zero"""
        rc = 0
        # Check that all of the XDD's are the same version
        v = ''
        for f in self.factory.getFlowBuilders():
            if '' == v:
                v = s.protocolVersion()
            elif v != s.protocolVersion():
                print("ERROR: XDD Protocols do not match", file=sys.stderr)
                rc = 1

        # Print a generic warning if the sinks do not have pre-allocation
        # support
        for s in self.factory.getSinkFlowBuilders():
            if not s.hasPreallocateAvailable():
                print("WARNING: Preallocation support not available", 
                      file=sys.stderr)
        return rc

    def createFlows(self):
        """Create local and remote flows"""
        assert False == self.isCreated
        assert 0 < self.requestSize
        assert 0 < self.transferSize
        assert self.sinkTarget
        assert self.sourceTarget
        rc = 0
        self.factory = FlowBuilderFactory(self.requestSize, self.transferSize,
                                          self.sourceDIOFlag, 
                                          self.sourceSerialFlag, 
                                          self.sourceVerboseFlag, 
                                          self.sourceTimestampFlag,
                                          self.sourceXddPath,
                                          self.sources,
                                          self.sinkDIOFlag, 
                                          self.sinkSerialFlag, 
                                          self.sinkVerboseFlag, 
                                          self.sinkTimestampFlag,
                                          self.sinkXddPath,
                                          self.sinks)
        self.factory.createFlowBuilders()
        self.isCreated = True

        rc = self.performPostCreateChecks()
        return rc

    def startFlows(self):
        """Start all flows in correct order"""
        assert True == self.isCreated
        assert False == self.isStarted
        rc = 0
        try:
            sinks = self.factory.getSinkFlowBuilders()
            for s in sinks:
                s.startFlow()
        except TransferPreconditionError:
            print('Sink flow failed during startup')
            rc = 1
        try:
            sources = self.factory.getSourceFlowBuilders()
            for s in sources:
                s.startFlow()
        except TransferPreconditionError:
            print('Source flow failed during startup')
            rc = 2

        if 0 == rc:
            self.isStarted = True
            self.beginTime = time.time()
        return rc

    def monitorFlows(self, monitorInterval):
        """Determine if flows are still functioning"""
        assert True == self.isStarted
        builders = self.factory.getFlowBuilders()
        completedByte = 0
        completeCount = 0
        while completeCount < len(builders):
            monBegin = time.time()
            completedByte = 0
            for b in builders:
                if b.completionStatus() is not None:
                    completeCount += 1
                # Get the progress very conservatively
                byte = b.currentByte()
                if (completedByte == 0) or (byte < completedByte):
                    completedByte = byte
            self.showStatus(completedByte)
            monEnd = time.time()

            # Sleep until its time to monitor again
            interval = monEnd - monBegin
            if interval < monitorInterval:
                time.sleep(monitorInterval - interval)

        return 0

    def cleanupFlows(self):
        """
        Determine exit status for stopped flows, and kill any remaining flows
        """
        rc = 0
        if self.factory:
            flowBuilders = self.factory.getFlowBuilders()
            for f in flowBuilders:
                if True == f.pollFlow():
                    f.cancelFlow()
                    print('Cancelling Flow')
                    rc = 1
                elif 0 != f.completionStatus():
                    print('Flow exited with code:', f.completionStatus())
                    print('Flow cmd:', f.executeString())
                    rc = 2

            self.factory.shutdown()
            del self.factory

        # On success, print out a final status
        if (0 == rc):
            self.showStatus(self.transferSize)
            print('')

        self.isCreate = False
        self.isStarted = False
        self.isCompleted = True
        return rc

    def completedSuccessfully(self):
        """@return true if the flows completed successfully"""
        return self.isComplete and self.isSuccess

    def showStatus(self, completedBytes):
        """Print a status line to stderr without a linefeed"""
        # Calculate the status values
        pctProgress = (float(completedBytes) / self.transferSize) * 100.0;
        transferTime = time.time() - self.beginTime
        bandwidth = float(completedBytes) / transferTime
        eta = '00:00:00'
        if (bandwidth > 0):
            eta_secs = round((self.transferSize - completedBytes) / bandwidth)
            td = datetime.timedelta(seconds=eta_secs)
            eta = str(td)

        # Get the width of the terminal
        #(cols, rows) = os.get_terminal_size()
        (r, c) = os.popen('stty size').read().split()
        cols = int(c)

        # Generate the status string
        status = str(round(pctProgress)) + '% '
        status += str(round(bandwidth / 1024.0 / 1024.0)) + 'MiB/s '
        status += eta + ' ETA'
           
        # Determine the padding length between the file name and status
        padding = ' '
        if cols > (len(status) + len(self.sinkTarget)):
            padding *= cols - len(status) - len(self.sinkTarget)
        
        # Clear the existing status line with whitespace
        print('\r', ' ' * cols, sep='', end='', file=sys.stderr)
         
        # Write the new status line
        print('\r', self.sinkTarget, padding, status, 
              sep='', end='', file=sys.stderr)

class FlowBuilderFactory:
    """
      The factory class that creates the FlowBuilders (locally or remote
      as required)
    """

    def __init__(self, transferRequestSize, 
                 sourceDioFlag, sourceSerialFlag, sourceVerboseFlag, 
                 sourceTimestampFlag, sourceXddPath, sources,
                 sinkDioFlag, sinkSerialFlag, sinkVerboseFlag, 
                 sinkTimestampFlag, sinkXddPath, sinks,
                 restartFlag=False):
        """Constructor"""
        # Transfer params
        self.transferRequestSize = transferRequestSize

        # Source params
        self.sourceDioFlag = sourceDioFlag
        self.sourceSerialFlag = sourceSerialFlag
        self.sourceVerboseFlag = sourceVerboseFlag
        self.sourceTimestampFlag = sourceTimestampFlag
        self.sourceXddPath = sourceXddPath
        self.sources = sources

        # Sink params
        self.sinkDioFlag = sinkDioFlag
        self.sinkSerialFlag = sinkSerialFlag
        self.sinkVerboseFlag = sinkVerboseFlag
        self.sinkTimestampFlag = sinkTimestampFlag
        self.sinkXddPath = sinkXddPath
        self.sinks = sinks

        # Optional params
        self.restartFlag = restartFlag

        # Internal variables
        self.remoteTransports = {}
        self.sinkFlows = []
        self.sourceFlows = []
        self.allFlows = []
        self.allBuilders = []

    def shutdown(self):
        """Shutdown all flow builders"""
        for (h, b) in self.remoteTransports.items():
            b.shutdown()
        
    def getFlowBuilders(self):
        """Return all flows"""
        return self.allFlows

    def getSinkFlowBuilders(self):
        """Return sink flows"""
        return self.sinkFlows

    def getSourceFlowBuilders(self):
        """Return source flows"""
        return self.sourceFlows

    def buildFlowBuilder(self, flowSpec):
        """Create an individual flow builder"""
        b = None
        hostname = flowSpec['hostname']
        if 'localhost' == hostname:
            b = FlowBuilder()
        else:
            # Build a remote transport
            trans = FlowBuilderTransport(hostname)
            # Extract the flow builder proxy from the transport
            b = trans.getFlowBuilder()
            self.remoteTransports[hostname] = trans
        return b

    def createIfaceList(self, flowSpec):
        """Convert a TransferManager spec into a Flow ifaces tuple list"""
        flowIfaceList = []
        threads = flowSpec['threads']
        port = flowSpec['port']
        ifs = flowSpec['ifs']
        for iface in ifs:
            if 'numa' in flowSpec:
                numa = flowSpec['numa']
                flowIface = (iface, port, threads, numa)
            else:
                flowIface = (iface, port, threads)
            flowIfaceList.append(flowIface)
        return flowIfaceList
                
    def createFlowBuilders(self):
        """Create the flow builders on each source and sink"""
        idx = 0
        for spec in self.sinks:
            b = self.buildFlowBuilder(spec)
            ifaces = self.createIfaceList(spec)
            b.buildFlow(isSink=True,  
                        reqSize=self.transferRequestSize,
                        flowIdx=idx, numFlows=len(self.sinks),
                        ifaces=ifaces,
                        dioFlag=False, serialFlag=False, verboseFlag=False, 
                        timestampFlag=False, xddPath=self.sinkXddPath)
            self.sinkFlows.append(b)
            self.allFlows.append(b)
            idx += 1
            
        idx = 0
        for spec in self.sources:
            b = self.buildFlowBuilder(spec)
            ifaces = self.createIfaceList(spec)
            b.buildFlow(isSink=False,
                        reqSize=self.transferRequestSize,
                        flowIdx=idx, numFlows=len(self.sources),
                        ifaces=ifaces,
                        dioFlag=False, serialFlag=False, verboseFlag=False, 
                        timestampFlag=False, xddPath=self.sourceXddPath)
            self.sourceFlows.append(b)
            self.allFlows.append(b)
            idx += 1


#
# Internal classes not designed for client use
#
class FlowBuilderTransportError(XDDError):
    """Exception raised when the flow proxy encounters problems."""

class FlowBuilderTransportForwardingServer(SocketServer.TCPServer):
    """
    SSH forwarding server to forward traffic over the forwarded ssh channel
    """
    daemon_threads = True
    allow_reuse_address = True
    
    def setTransport(self, transport, remoteAddr):
        """Set instance variables used by the underlying handler""" 
        self.transport = transport
        self.remoteAddr = remoteAddr

class FlowBuilderTransportForwardingHandler(SocketServer.BaseRequestHandler):
    """
    Request handler that establishes the forwarding SSH tunnel and 
    passes traffic over the tunnel as it is received
    """
    def handle(self):

        # Determine the SSH transport, remote hostname, and remote port
        sshTransport = self.server.transport
        remoteAddr = self.server.remoteAddr

        # The first time this function is invoked is by the instantiator
        try:
            destAddr = remoteAddr
            srcAddr = self.server.server_address
            channel = sshTransport.open_channel('direct-tcpip', 
                                                destAddr, 
                                                srcAddr)
            #print("SSH Channel opened:", srcAddr, ' -> ', destAddr)
        except paramiko.SSHException, e:
            print("ERROR: Unable to open channel for the existing transport:",
                  e)
            return
        except Exception, e:
            print("ERROR: Unable to create SSH forward channel.")
            import sys
            eInfo = sys.exc_info()[0]
            print("Exception:", e)
            print("Info:", eInfo)
            return

        # Forward the data through this server
        while True:
            r,w,x = select.select([self.request, channel], [], [])
            if self.request in r:
                data = self.request.recv(1024)
                if 0 == len(data):
                    break
                channel.send(data)
            if channel in r:
                data = channel.recv(1024)
                if 0 == len(data):
                    break
                self.request.send(data)

        channel.close()
        self.request.close()
        #print("SSH Channel closed:", srcAddr, ' -> ', destAddr)
            

class FlowBuilderTransport:
    """
    Paramiko client that creates a FlowBuilderServer
    """
    def __init__(self, host):
        """Constructor"""
        # Start the remote service
        (ssh, uri) = self.createRemoteServer(host)
        self.host = host
        self.ssh = ssh
        self.remoteURI = uri

        # Port forward the remote service using SSH
        fields = uri.rsplit(':', 1)
        pyroPort = int(fields[1])
        (server, thread, port) = self.startLocalForwarder(pyroPort)
        self.remotePort = pyroPort
        self.localPort = port
        self.forwardingServer = server
        self.forwardingThread = thread

        # Modify the Pyro URI so that we use the locally forwarded server
        # and port rather than the remote end.  Since the host is already
        # 'localhost' on the remote side, the host is correct, just need
        # to use the locally forwarded port
        self.localURI = fields[0] + ':' + str(self.localPort)

        # Use the tunnel to retrieve the flow builder proxy
        #print("URI: >", self.localURI, "<", sep='')
        flowBuilder = Pyro4.Proxy(self.localURI)
        self.flowBuilder = flowBuilder

        # Quickly test the flowbuilder
        self.flowBuilder.isReady()
        #print("FlowBuilder is ready:", self.flowBuilder.isReady())
        
    def shutdown(self):
        """
        Stop the remote pyro server, the local forwarding server and terminate 
        the ssh connection
        """
        try:
            self.flowBuilder.shutdown();
        except Pyro4.errors.ConnectionClosedError:
            # The only way to shutdown the server remotely is via the Pyro 
            # object.  So the return from the RMI fails.  Which is not ideal, 
            # but its relatively safe since we are on our way out anyway.
            pass
        self.forwardingServer.shutdown()
        self.forwardingThread.join()
        self.ssh.close()

    def createRemoteServer(self, host):
        """"Create the remote pyro server using paramiko"""
        #print('Creating remote XDD flow server on', host)
        uri = None
        ssh = paramiko.SSHClient()
        ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())
        try:
            ssh.connect('bws-mbpro2')
        except paramiko.AuthenticationException:
            print('Unable to authenticate SSH at', host)
        except paramiko.BadHostKeyException:
            print('Bad host key', host)
        except:
            print('Unknown SSH error for', host)
            import sys
            e = sys.exc_info()[0]
            print(e)
        try:
            # Set the keep alive interval
            ssh.get_transport().set_keepalive(5)

            # Start the xdd flow server
            cmd = 'PYTHONPATH=' + xdd_settings.XDD_PYTHONPATH + ':$PYTHONPATH '
            cmd += 'python -m xdd'
            #print("Cmd is: ", cmd)

            (stdin, stdout, stderr) = ssh.exec_command(cmd)
            
            # Convert the returned stuff into something useful
            channel = stdin.channel

            # Wait for the buffer to fill
            while (not channel.recv_ready()) and \
                  (not channel.exit_status_ready()):
                pass

            # If the command exited, something went wrong
            if channel.exit_status_ready():
                print("Error: Unable to start remote XDD flow server:", 
                      channel.recv_exit_status)
                for line in stdout:
                    print(host, "stdout:", line)
                for line in stderr:
                    print(host, "stderr", line)
            else:
                # Read stdout to find the delimited URI
                uri = None
                foundDelim = False;
                i = 0
                while None == uri and (not channel.exit_status_ready()):
                    line = stdout.readline()
                    #print("Line", line)
                    if line:
                        token = line.rstrip('\n')
                        if foundDelim:
                            uri = token
                            foundDelim = False
                            break
                        elif xdd_settings.XDD_PYRO_URI_DELIMITER == token:
                            foundDelim = True 
                    else:
                        break
                    
                # If the URI is invalid, trigger an error
                if None == uri:
                    print("ERROR: XDD flow server terminated prematurely")
                    for line in stdout:
                        print(host, "stderr", line)
                    raise FlowBuilderTransportError()
                
        except paramiko.SSHException, e:
            print('SSH Exception', host, e)

        # Return the SSH session and URI
        return (ssh, uri)

    def startLocalForwarder(self, pyroPort):
        """
        Establish an ssh tunnel and start a thread that forwards TCP
        requests on the local host to the server running on the remote host.
        """
        # Start a forwarding server and set SSH forwarding attributes
        pyroListenAddr = ('localhost', pyroPort)
        localListenAddr = ('localhost', 0)
        forwardServer = FlowBuilderTransportForwardingServer(
            localListenAddr, FlowBuilderTransportForwardingHandler)
        forwardServer.setTransport(self.ssh.get_transport(), pyroListenAddr)

        # Start the forwarding server in its own thread so we don't block
        # waiting to handle requests
        forwardThread = threading.Thread(target=forwardServer.serve_forever)
        forwardThread.daemon = True
        forwardThread.start()

        # Retrieve the local port for the forwarding server
        (host,port) = forwardServer.server_address

        return (forwardServer, forwardThread, port)

    
    def getFlowBuilder(self):
        """Return the flow builder object"""
        return self.flowBuilder

class Flow:
    """
    Class that starts, stops, and monitors an XDD flow.  Since this class 
    starts and monitors a UNIX process, it is by its nature not serializable,
    and should rarely be used directly.  Instead, you should generally use a
    FlowBuilder (either directly, or via a Pyro Proxy) to interact with flows
    """

    def __init__(self, isSink, reqSize, flowIdx, numFlows, ifaces,
                 dioFlag, serialFlag, verboseFlag, timestampFlag, xddPath=''):
        self.isSink = isSink
        self.reqSize = reqSize
        self.flowIdx = flowIdx,
        self.numFlows = numFlows
        self.ifaces = ifaces
        self.dio = dioFlag
        self.serial = serialFlag
        self.verbose = verboseFlag
        self.timestamp = timestampFlag

        if '' != xddPath:
            self.xddExe = xddPath + '/' + 'xdd'
        else:
            self.xddExe = 'xdd'

        self.processStatus = None
        self.process = None
        self.reasons = ["Some error"]

        # Variable set later
        self.target = ''
        self.dataSize = 0
        self.restart = False
        self.restartByte = 0
        self.heartbeatByte = self.restartByte



    def checkSinkPreconditions(self):
        """
        Checks the following preconditions for a sink:
          Either file exists and is writable or 
                 parent directory exists and is searchable and writable
          The data size provided maskes sense
          The dio flag is not set for character devices
        """
        assert self.isSink
        passes = True

        # Determine if the path exists
        if os.path.exists(self.target):
            # Check other preconditions based on file type
            res = os.stat(self.target)
            if S_ISREG(res.st_mode) or S_ISLNK(res.st_mode):
                # For regular files and links just check read permission
                if not os.access(self.target, os.W_OK):
                    self.reasons.append("Cannot write source: " + self.target)
                    passes = False;
            elif S_ISBLK(res.st_mode):
                # For block devices check read permissions
                if not os.access(self.target, os.W_OK):
                    self.reasons.append("Cannot write block device: " + 
                                        self.target)
                    passes = False;
            elif S_ISCHR(res.st_mode):
                # For character devices, check that DIO and restart are off
                if not os.access(self.target, os.W_OK):
                    self.reasons.append("Cannot write character device: " + 
                                        self.target)
                    passes = False;
                elif self.dio:
                    self.reasons.append("Device does not support Direct I/O: " +
                                        self.target)
                    passes = False;
                elif self.restart:
                    self.reasons.append("Character device does not support restart: " +
                                        self.target)
                    passes = False;
            else:
                passes = False
                self.reasons.append("Target is unsupported file type:" + 
                                    self.target)
        else:
            # Check the parent directory for existence
            parentDir = os.path.dirname(self.target)
            if not os.path.exists(parentDir):
                reasons.append("Parent directory does not exist: " +
                               self.target)
                passes = False
            elif not os.access(parentDir, os.W_OK):
                self.reasons.append("Cannot write parent directory" + 
                                    self.target)
                passes = False

        # If the restart flag is set, we must be able to create the restart
        # file
        if self.restart:
            parentDir = os.path.dirname(self.target)
            if not os.path.exists(parentDir) and os.access(parentDir, os.W_OK):
                self.reasons.append("Restart requires write access to " +
                                    "destination parent directory")
                passes = False
        return passes

    def checkSourcePreconditions(self):
        """
        Check the following preconditions for a source:
          - The file exists
          - The file is readable
          - If the file is a block device or file, it is large enough to
            satisfy the data size
          - If the file is a character device, the data size must be positive
          - DIO can only be set for block devices and file
        """
        assert not self.isSink
        passes = True
        
        # Ensure the source exists
        if not os.path.exists(self.target):
            self.reasons.append("Target does not exist: " + self.target)
            passes = False
        else:
            # Check other preconditions based on file type
            res = os.stat(self.target)
            if S_ISREG(res.st_mode) or S_ISLNK(res.st_mode):
                # For regular files and links just check read permission
                if not os.access(self.target, os.R_OK):
                    self.reasons.append("Cannot read source: " + self.target)
                    passes = False;
            elif S_ISBLK(res.st_mode):
                # For block devices check read permissions
                if not os.access(self.target, os.R_OK):
                    self.reasons.append("Cannot read block device: " + 
                                        self.target)
                    passes = False;
            elif S_ISCHR(res.st_mode):
                # For character devices, check that DIO is off
                if not os.access(self.target, os.R_OK):
                    self.reasons.append("Cannot read character device: " + 
                                        self.target)
                    passes = False;
                elif self.dio:
                    self.reasons.append("Device does not support Direct I/O: " +
                                        self.target)
                    passes = False;
            else:
                passes = False
                self.reasons.append("Target is unsupported file type:" + 
                                    self.target)
        return passes

    def checkPreconditions(self):
        """
        Checks preconditions to ensure the XDD process should start correctly
        """
        # First ensure that xdd exists and is executable
        if ((not os.path.exists(self.xddExe)) or 
            (not os.access(self.xddExe, os.X_OK))):
           return False
        
        if self.isSink:
            passes = self.checkSinkPreconditions()
        else:
            passes = self.checkSourcePreconditions()
        return passes

    def getRestartFilename(self):
        """@return the name of the restart file for this sink"""
        # The restart file is named sinkfile.idx.xrf
        (head, tail) = os.path.split(self.target)
        restartFilename = head + '/.' + tail + '-' + self.flowIdx + '.xrf'
        return restartFilename

    def getRestartOffset(self):
        """@return the restart offset if the restart flag is true, else None"""
        offset = None
        if self.restart:
            offset = 0
            try:
                rfn = self.getRestartFilename()
                rf = open(rfn, 'r')
                cookie = rf.readline();
                rf.close()
                cl = cookie.split(' ')
                offset = int(cl[2])
            except:
                print("Invalid restart offset found")
        return offset

    def createCommandArgs(self):
        """@return the command used to start the XDD process"""
        # Assemble the basic file system command
        cmd = [self.xddExe, '-target', self.target]
        if self.isSink:
            cmd.extend(['-op', 'write', '-e2e', 'isdest'])
        else:
            cmd.extend(['-op', 'read', '-e2e', 'issource'])
        cmd.extend(['-reqsize', str(self.reqSize), '-bytes', str(self.dataSize)])
        # Add interfaces for network
        for iface in self.ifaces:
            # Determine if optional NUMA has been supplied
            if 4 == len(iface):
                (host, port, threads, numa) = iface
            else:
                (host, port, threads) = iface
                numa = None
            spec = host + ':' + str(port) + ',' + str(threads)
            if numa:
                spec += ',' + numa
            cmd.extend(['-e2e', 'dest', spec])
            
        
        # Process flags
        if self.dio:
            cmd.append('-dio')
        if not self.serial:
            if not self.isSink:
                cmd.append('-looseordering')
            else:
                cmd.append('-noordering')
        else:
            cmd.append('-serialordering')
        if self.restart:
            rfn = self.getRestartFilename()
            cmd.extend(['-restart', 'enable', '-restart', 'file', rfn])
            cmd.extend(['-restart', 'offset', str(self.restartByte)])


        # Add on all of the standard output stuff
        cmd.extend(['-verbose', '-minall', '-stoponerror'])

        # Add the heartbeat stuff on the source
        cmd.extend(['-hb', '2', '-hb', 'bytes', '-hb', 'lf'])
        return cmd

    def start(self, filename, dataSize, restartFlag=False, restartOffset=0):
        """Start an XDD process to perform work"""
        assert self.process is None

        # Add the final options
        self.target = filename
        self.dataSize = dataSize
        self.restart = False
        self.restartByte = 0

        # Check preconditions
        if self.checkPreconditions():
            args = self.createCommandArgs()
            try:
                self.process = subprocess.Popen(args, 
                                                stdout=subprocess.PIPE,
                                                stderr=subprocess.PIPE)
            except OSError:
                print("Error executing", args[0])
            
    def cancel(self):
        """Cancel the underlying XDD process that does the work"""
        print('Cancelling flow.')
        self.process.kill()

    def pollStatus(self):
        """@return True if the XDD process is still active, otherwise False"""
        self.process.poll()
        if self.process.returncode is None:
            return True
        else:
            return False

    def getOutput(self):
        s = ""
        return s

    def completionStatus(self):
        """@return XDD return code"""
        self.process.poll()
        return self.process.returncode

    def currentByte(self):
        """@return the most recently completed byte"""
        # Turn off blocking for stderr
        eflags = fcntl.fcntl(self.process.stderr, fcntl.F_GETFL)
        fcntl.fcntl(self.process.stderr, fcntl.F_SETFL, eflags | os.O_NONBLOCK)
        
        
        # For safety, get the last 2 lines of stderr
        last = ''
        try:
            while True:
                temp = self.process.stderr.read(1024)
                if 0 == len(temp):
                    break
                last = temp
        except IOError:
            # This is invoked when the stream is out of data
            pass
        except OSError:
            # This is part of the spec, I don't know why
            pass

        # Split the last line, and update the heartbeat byte if it exists
        sl = last.split(',')
        # Sometimes XDD gives an alternate WAITING format, if we verify that
        # the first field is Pass and the last is B, then the bytes are correct
        if 5 == len(sl) and '\nPass' == sl[0] and 'B' == sl[4]:
            # Convert the byte field into a int if possible
            byteString = sl[3]
            try:
                value = int(byteString)
                self.heartbeatByte = value
            except ValueError:
                print("ERROR: Invalid heartbeat", byteString)
        return self.heartbeatByte     

    def hasPreallocate(self):
        """@return true if XDD is compiled with preallocation support"""
        # Just use nm (assume its in the path)
        cmd = ['nm', self.xddExe]
        p = subprocess.popen(cmd, stdout=PIPE)
        (stdoutdata, _) = p.communicate()
        # If XDD has preallocate support it will have a special symbol
        for l in stdoutdata:
            sl = l.split(' ')
            if 3 == len(sl) and xdd_settings.XDD_PREALLOC_TOKEN == sl[2]:
                return True 
        return False
        
class FlowBuilder:
    """
    Helper class that can start flows, generate directory walks, create 
    symlinks, and retrieve the restart offset for partially completed 
    transfers.  This class is designed for use with an RPC-system, thus its
    grab-bag nature.
    """
    def __init__(self):
        """Constructor"""
        pass

    def shutdown(self):
        """Shutdown"""
        pass

    def buildWalk(self, source):
        """@return a (dirs, files, symlinks) tuple"""
        outDirs = []
        outFiles = []
        outSymlinks = []
        try:
            for dirpath, dirs, files in os.walk(source, topdown=True, 
                                                onerror=raise_err, 
                                                followlinks=False):
                # construct the directories
                for d in dirs:
                    dirname = os.path.join(dirpath, d)
                    if os.path.islink(dirname):
                        linkTarget = os.path.relpath(dirpath, 
                                                     os.readlink(filename))
                        link = (linkTarget, dirname)
                        outSymlinks.append(link)
                    else:
                        outDirs.append(dirname)
                # construct the files
                for f in files:
                    filename = os.path.join(dirpath, f)
                    if os.path.islink(filename):
                        linkTarget = os.path.relpath(dirpath, 
                                                     os.readlink(filename))
                        link = (linkTarget, filename)
                        outSymlinks.append(link)
                    else:
                        outFiless.append(filename)
        except OSError:
            print("ERROR during recursive file walk")
            outDirs = []
            outFiles = []
            outSymlinks = []            
        return (outDirs, outFiles, outSymlinks)
    
    def buildDirectory(self, target):
        """Create the directory target"""
        os.mkdir(target)

    def buildSymlink(self, source, target):
        """Generate a symlink target that points at source"""
        os.symlink(source, target)

    def getFileSize(self, path):
        """@return file or block device size in bytes"""
        fd = os.open(path, os.O_RDONLY)
        try:
            return os.lseek(fd, 0, os.SEEK_END)
        finally:
            os.close(fd)

    def getRestartOffset(self):
        """@return the restart offset from the existing cookie"""
        return self.flow.getRestartOffset()

    def buildFlow(self, isSink, reqSize, flowIdx, numFlows, ifaces,
                  dioFlag, serialFlag, verboseFlag, timestampFlag, 
                  xddPath):
        """Create the Flow"""
        self.flow = Flow(isSink, reqSize, flowIdx, numFlows, ifaces,
                         dioFlag, serialFlag, verboseFlag, timestampFlag, 
                         xddPath)

    def startFlow(self, filename, dataSize, restartFlag, restartOffset):
        """Start an XDD process"""
        return self.flow.start(filename, dataSize, restartFlag, restartOffset)

    def cancelFlow(self):
        """Stop a running XDD process"""
        return self.flow.cancel()

    def pollFlow(self):
        """Return the current state of a running XDD process"""
        return self.flow.pollStatus()

    def completionStatus(self):
        """Return the return code from the XDD process"""
        return self.flow.completionStatus()

    def currentByte(self):
        """@return the most recently processed byte"""
        return self.flow.currentByte()

    def executeString(self):
        args = self.flow.createCommandArgs()
        s = ""
        for a in args:
            s = s + " " + a
        return s

    def hasPreallocateAvailable(self):
        """@return if preallocation is available for a flow"""
        # All we check here is that XDD supports pre-allocation, we
        # do not check file system support, because there is no way
        # the check could be correct
        return self.flow.hasPreallocate()

    def protocolVersion(self):
        """@return The XDD protocol version"""

class RemoteFlowBuilder(FlowBuilder):
    """
    Pyro helper class that builds remote flows and dispatches messages to the 
    flow
    """

    def __init__(self, daemon):
        """Constructor"""
        self.daemon = daemon
        self.i = 0

    def shutdown(self):
        """
        Stop the pyro daemon.  This is guaranteed to raise a ConnectionClosed
        Exception, and is therefore not typically useful.  Shutdown from
        factory is exception safe.
        """
        print("Warning: Client initiated shutdown")
        self.daemon.shutdown()

    def isReady(self):
        """
        Returns True when the proxy is established.  Pyro throws an internal
        exception (usually Pyro4.errors.ConnectionClosedError) if the
        service or transport are not ready
        """
        return True

    def test(self):
        """Return a test string"""
        self.i += 1
        return "Test string " + str(self.i)

def ppidCheck(server):
    """
    Check to see if the parent PID is 1, and if it is, call Pyro4.shutdown()
    """
    # The client to the RPC server cannot guarantee that it can send the
    # terminate signal to the RPC server, however, it will kill the parent
    # process when the SSH connection terminates.  When the happens, the
    # parent process will become init (PID: 1), and this thread will then
    # shutdown the Pyro server cleanly
    while True:
        if 1 == os.getppid():
            server.shutdown()
            break
        time.sleep(5)

def main():
    """Main to run an actual XDD Flow Server"""

    # Create the server
    pyroServer = None
    try:
        # Let the daemon find a port on its own
        pyroServer = Pyro4.Daemon(host='localhost', port=0)
    except socket.error:
        print("Pyro connection error.")

    except:
        print("Pyro unknown error.")
        e = sys.exc_info()[0]
        print(str(e))
        
    flowBuilder = RemoteFlowBuilder(pyroServer)
    uri = pyroServer.register(flowBuilder)

    # Publish the URI over stdout
    print(xdd_settings.XDD_PYRO_URI_DELIMITER)
    sys.stdout.flush()
    print (uri)
    sys.stdout.flush()
    print(xdd_settings.XDD_PYRO_URI_DELIMITER)
    sys.stdout.flush()
    sys.stdout.flush()

    # Start the monitor thread
    monitor = threading.Thread(target = ppidCheck, args = (pyroServer, ))
    monitor.daemon = True
    monitor.start()

    # Daemonize and wait for requests
    pyroServer.requestLoop()

    return 0


if __name__ == '__main__':
    main()

