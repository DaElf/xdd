
#
# Python stuff to improve portability
#
from __future__ import print_function

#
# Python standard packages
#
import os

#
# 3rd party packages
#
import Pyro4

#
# XDD package imports
#
from xdd.flow import Flow

class FlowBuilder:
    """
    Helper class that can start flows, generate directory walks, create 
    symlinks, and retrieve the restart offset for partially completed 
    transfers.  This class is designed for use with an RPC-system, thus its
    grab-bag nature.
    """
    def __init__(self):
        """Constructor"""
        pass

    def shutdown(self):
        """Shutdown"""
        pass

    def pathExists(self, path):
        """@return true if the path exists"""
        return os.path.exists(path)

    def pathIsDir(self, path):
        """@return true if the path exists"""
        return os.path.isdir(path)

    def getFileSize(self, path):
        """@return file or block device size in bytes"""
        fd = os.open(path, os.O_RDONLY)
        try:
            return os.lseek(fd, 0, os.SEEK_END)
        finally:
            os.close(fd)

    def walkError(self, e):
        """Raises the exception e"""
        raise e

    def buildWalk(self, source, target, targetExists, targetIsDir):
        """
        @return a (rc, dirs, files, symlinks) tuple
        rc is 0 on success
        dirs is the list of source dirs to create
        files is a list of (sourcename, sinkname) tuples
        links is a list of (target, sinkname) tuples
        """
        rc = 0
        outDirs = []
        outFiles = []
        outSymlinks = []

        # The source is a directory, link, or file.  Link has to be
        # checked first, because links may also be directories or files,
        # the final check does not use isfile() because we also need to
        # handle character special and block devices
        if os.path.islink(source):
            # Links are stored in target-value format
            value = os.readlink(source)
            # Build the target name
            if targetIsDir:
                base = os.path.basename(source)
                tname = os.path.join(tname, base)
            else:
                tname = target
            outSymlinks = [(value, tname)]
        elif os.path.isdir(source) and targetIsDir or not targetExists:
            # Determine if the source has a trailing slash
            (_, stail) = os.path.split(source)

            # Build the target side prefix
            if targetExists and stail:
                targetPrefix = os.path.join(target, stail)
            else:
                targetPrefix = target

            try:
                for dirpath, dirs, files in os.walk(source, topdown=True, 
                                                    onerror=self.walkError, 
                                                    followlinks=False):
                    # Strip off the parts of path supplied by caller
                    reldir = os.path.relpath(dirpath, source)

                    # Construct the directories and symlinks to directories
                    for d in dirs:
                        # Convert the name to use target prefix               
                        sourcename = os.path.join(dirpath, d)
                        targetname = os.path.join(targetPrefix, reldir, d)
                        # Handle symlinks
                        if os.path.islink(sourcename):
                            # Try and remove relative path parts in link target
                            ltarget = os.readlink(sourcename)
                            reltarget = os.path.relpath(source, ltarget)
                            if ltarget != reltarget:
                                link = (targetname, os.path.join(targetPrefix,
                                                              reltarget))
                            else:
                                link = (targetname, ltarget)
                            outSymlinks.append(link)
                        else:
                            outDirs.append(targetname)
                    # Construct the files and symlinks to files
                    for f in files:
                        sourcename = os.path.join(dirpath, f)
                        targetname = os.path.join(targetPrefix, reldir, f)
                        # Handle symlinks
                        if os.path.islink(sourcename):
                            # Try and remove relative path parts in link target
                            ltarget = os.readlink(sourcename)
                            reltarget = os.path.relpath(source, ltarget)
                            if ltarget != reltarget:
                                link = (targetname, os.path.join(targetPrefix,
                                                                 reltarget))
                            else:
                                link = (targetname, ltarget)
                            outSymlinks.append(link)
                        else:
                            outFiles.append( (sourcename, targetname) )
            except OSError:
                rc = 2
                outDirs = []
                outFiles = []
                outSymlinks = []
        elif not os.path.isdir(source) and os.path.exists(source):
            # Build the target name for regular and special files
            if targetIsDir:
                base = os.path.basename(source)
                tname = os.path.join(tname, base)
            else:
                tname = target
            outFiles = [(source, tname)]
        else:
            rc = 1
                
        return (rc, outDirs, outFiles, outSymlinks)
    
    def buildDirectory(self, target):
        """Create the directory target"""
        os.mkdir(target)

    def buildSymlink(self, source, target):
        """Generate a symlink target that points at source"""
        os.symlink(source, target)

    def protocolVersion(self):
        """@return The XDD protocol version"""
        return self.flow.protocolVersion()

    def getRestartOffset(self):
        """@return the restart offset from the existing cookie"""
        return self.flow.getRestartOffset()

    def buildFlow(self, isSink, reqSize, flowIdx, numFlows, ifaces,
                  dioFlag, serialFlag, verboseFlag, timestampFlag, 
                  xddPath):
        """Create the Flow"""
        self.flow = Flow(isSink, reqSize, flowIdx, numFlows, ifaces,
                         dioFlag, serialFlag, verboseFlag, timestampFlag, 
                         xddPath)

    def startFlow(self, filename, dataSize, restartFlag, restartOffset):
        """Start an XDD process"""
        return self.flow.start(filename, dataSize, restartFlag, restartOffset)

    def cancelFlow(self):
        """Stop a running XDD process"""
        return self.flow.cancel()

    def pollFlow(self):
        """Return the current state of a running XDD process"""
        return self.flow.pollStatus()

    def completionStatus(self):
        """Return the return code from the XDD process"""
        return self.flow.completionStatus()

    def currentByte(self):
        """@return the most recently processed byte"""
        return self.flow.currentByte()

    def errorString(self):
        return self.flow.getErrorString()

    def executeString(self):
        args = self.flow.createCommandArgs()
        s = ''
        for a in args:
            s += a + ' '
        return s.rstrip()

    def output(self):
        """@return the flow's standard output"""
        return self.flow.getOutput()

    def hasPreallocateAvailable(self):
        """@return if preallocation is available for a flow"""
        # All we check here is that XDD supports pre-allocation, we
        # do not check file system support, because there is no way
        # the check could be correct
        return self.flow.hasPreallocate()

class RemoteFlowBuilder(FlowBuilder):
    """
    Pyro helper class that builds remote flows and dispatches messages to the 
    flow
    """

    def __init__(self, daemon):
        """Constructor"""
        self.daemon = daemon
        self.i = 0

    def shutdown(self):
        """
        Stop the pyro daemon.  This is guaranteed to raise a ConnectionClosed
        Exception, and is therefore not typically useful.  Shutdown from
        factory is exception safe.
        """
        print("Warning: Client initiated shutdown")
        self.daemon.shutdown()

    def isReady(self):
        """
        Returns True when the proxy is established.  Pyro throws an internal
        exception (usually Pyro4.errors.ConnectionClosedError) if the
        service or transport are not ready
        """
        return True

    def test(self):
        """Return a test string"""
        self.i += 1
        return "Test string " + str(self.i)



