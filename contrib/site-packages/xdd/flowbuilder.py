
#
# Python stuff to improve portability
#
from __future__ import print_function

#
# Python standard packages
#
import os

#
# 3rd party packages
#
import Pyro4

#
# XDD package imports
#
from xdd.flow import Flow

class FlowBuilder:
    """
    Helper class that can start flows, generate directory walks, create 
    symlinks, and retrieve the restart offset for partially completed 
    transfers.  This class is designed for use with an RPC-system, thus its
    grab-bag nature.
    """
    def __init__(self):
        """Constructor"""
        pass

    def shutdown(self):
        """Shutdown"""
        pass

    def walkError(self, e):
        raise e

    def buildWalk(self, source):
        """@return a (rc, dirs, files, symlinks) tuple"""
        rc = 0
        outDirs = []
        outFiles = []
        outSymlinks = []
        # If source is not a directory, just return it
        if os.path.isdir(source):
            try:
                for dirpath, dirs, files in os.walk(source, topdown=True, 
                                                    onerror=self.walkError, 
                                                    followlinks=False):
                    # construct the directories
                    for d in dirs:
                        dirname = os.path.join(dirpath, d)
                        if os.path.islink(dirname):
                            linkTarget = os.path.relpath(dirpath, 
                                                         os.readlink(filename))
                            link = (linkTarget, dirname)
                            outSymlinks.append(link)
                        else:
                            outDirs.append(dirname)
                    # construct the files
                    for f in files:
                        filename = os.path.join(dirpath, f)
                        if os.path.islink(filename):
                            linkTarget = os.path.relpath(dirpath, 
                                                         os.readlink(filename))
                            link = (linkTarget, filename)
                            outSymlinks.append(link)
                        else:
                            outFiless.append(filename)
            except OSError:
                rc = 1
                outDirs = []
                outFiles = []
                outSymlinks = []
        return (rc, outDirs, outFiles, outSymlinks)
    
    def buildDirectory(self, target):
        """Create the directory target"""
        os.mkdir(target)

    def buildSymlink(self, source, target):
        """Generate a symlink target that points at source"""
        os.symlink(source, target)

    def getFileSize(self, path):
        """@return file or block device size in bytes"""
        fd = os.open(path, os.O_RDONLY)
        try:
            return os.lseek(fd, 0, os.SEEK_END)
        finally:
            os.close(fd)

    def getRestartOffset(self):
        """@return the restart offset from the existing cookie"""
        return self.flow.getRestartOffset()

    def buildFlow(self, isSink, reqSize, flowIdx, numFlows, ifaces,
                  dioFlag, serialFlag, verboseFlag, timestampFlag, 
                  xddPath):
        """Create the Flow"""
        self.flow = Flow(isSink, reqSize, flowIdx, numFlows, ifaces,
                         dioFlag, serialFlag, verboseFlag, timestampFlag, 
                         xddPath)

    def startFlow(self, filename, dataSize, restartFlag, restartOffset):
        """Start an XDD process"""
        return self.flow.start(filename, dataSize, restartFlag, restartOffset)

    def cancelFlow(self):
        """Stop a running XDD process"""
        return self.flow.cancel()

    def pollFlow(self):
        """Return the current state of a running XDD process"""
        return self.flow.pollStatus()

    def completionStatus(self):
        """Return the return code from the XDD process"""
        return self.flow.completionStatus()

    def currentByte(self):
        """@return the most recently processed byte"""
        return self.flow.currentByte()

    def errorString(self):
        return self.flow.getErrorString()

    def executeString(self):
        args = self.flow.createCommandArgs()
        s = ""
        for a in args:
            s = s + " " + a
        return s

    def hasPreallocateAvailable(self):
        """@return if preallocation is available for a flow"""
        # All we check here is that XDD supports pre-allocation, we
        # do not check file system support, because there is no way
        # the check could be correct
        return self.flow.hasPreallocate()

    def protocolVersion(self):
        """@return The XDD protocol version"""

class RemoteFlowBuilder(FlowBuilder):
    """
    Pyro helper class that builds remote flows and dispatches messages to the 
    flow
    """

    def __init__(self, daemon):
        """Constructor"""
        self.daemon = daemon
        self.i = 0

    def shutdown(self):
        """
        Stop the pyro daemon.  This is guaranteed to raise a ConnectionClosed
        Exception, and is therefore not typically useful.  Shutdown from
        factory is exception safe.
        """
        print("Warning: Client initiated shutdown")
        self.daemon.shutdown()

    def isReady(self):
        """
        Returns True when the proxy is established.  Pyro throws an internal
        exception (usually Pyro4.errors.ConnectionClosedError) if the
        service or transport are not ready
        """
        return True

    def test(self):
        """Return a test string"""
        self.i += 1
        return "Test string " + str(self.i)



