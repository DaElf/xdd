
#
# Python stuff to improve portability
#
from __future__ import print_function

#
# Generic python packages used
#
import datetime
import fcntl
import getpass
import os
import select
import SocketServer
import socket
import subprocess
import sys
import threading
import time
from stat import *

#
# XDD packages
#
from xdd.core import XDDError, TransferPreconditionError
from xdd.factory import FlowBuilderFactory

class TransferFailError(XDDError):

    def __init__(source, dest, reason):
        self.source = source
        self.dest = dest
        self.reason = reason

#
# Interface classes to interact with local and remote XDD flows
#
class TransferManager:
    """
    Manager for creating, monitoring, and deallocating local and remote flows.
    """

    def __init__(self):
        """Constructor"""
        self.isCreated = False
        self.isStarted = False
        self.isComplete = False
        self.isSuccess = False
        self.factory = None

        # Temporary variables used for showing progress
        self.beginTime = None
        self.currentFlowSize = 0
        self.verboseLog = None

        self.requestSize = 0
        self.transferSize = None
        self.restartFlag = False
        self.sinkDIOFlag = False
        self.sinkSerialFlag = False
        self.sinkTimestampFlag = False
        self.sinkVerboseFlag = False
        self.sinkTarget = None
        self.sinkXddPath = ''
        self.sinks = []
        self.sourceDIOFlag = False
        self.sourceSerialFlag = False
        self.sourceVerboseFlag = False
        self.sourceTimestampFlag = False
        self.sourceTarget = None
        self.sourceXddPath = ''
        self.sources = []


    def setRequestSize(self, reqSize):
        """Set the chunk size of data to move across the wire"""
        self.requestSize = reqSize
        
    def setTransferSize(self, transferSize):
        """Set the size of data to move across the wire"""
        self.transferSize = transferSize
        
    def setRestartFlag(self, restartFlag):
        """Set the amount of data previously sent across the wire"""
        self.restartFlag = restartFlag
        
    def setSinkTarget(self, target, dioFlag=False, serialFlag=False):
        """ Set the name of of the sink target file"""
        assert not self.isCreated
        self.sinkTarget = target
        self.sinkDIOFlag = dioFlag
        self.sinkSerialFlag = serialFlag

    def setSourceTarget(self, target, dioFlag=False, serialFlag=False):
        """Set the name of the source target file"""
        assert not self.isCreated
        self.sourceTarget = target
        self.sourceDIOFlag = dioFlag
        self.sourceSerialFlag = serialFlag

    def setVerbosity(self, verboseLevel, filename):
        """Set the level of verbosity"""
        if 1 <= verboseLevel:
            self.sinkVerboseFlag = True
            self.sourceVerboseFlag = True
        if 2 <= verboseLevel:
            self.sinkTimestampFlag = True
            self.sourceTimestampFlag = True
        self.verboseLog = filename

    def addSink(self, user, hostname, threads, ifs = [], port = 40000):
        """Add a sink to the list of sinks"""
        assert not self.isCreated
        assert hostname
        assert 0 < threads
        sink = {'hostname': hostname, 'threads': threads, 
                'port': port, 'ifs': []}
        if 0 == len(ifs):
            sink['ifs'].append(hostname)
        else:
            sink['ifs'].extend(ifs)
        self.sinks.append(sink)

    def addSource(self, user, hostname, threads, ifs = [], port = 40000):
        """Add a source to the list of sources"""
        assert not self.isCreated
        assert hostname
        assert 0 < threads
        source = {'hostname': hostname, 'threads': threads, 
                  'port': port, 'ifs': []}
        if 0 == len(ifs):
            source['ifs'].append(hostname)
        else:
            source['ifs'].extend(ifs)
        self.sources.append(source)

    def setSinkXddPath(self, path):
        """Set the path sinks use to find xdd"""
        self.sinkXddPath = path

    def setSourceXddPath(self, path):
        """Set the path sources use to find xdd"""
        self.sourceXddPath = path

    def setXddPath(self, path):
        """Set the path used to find xdd"""
        self.sinkXddPath = path
        self.sourceXddPath = path

    def performPostCreateChecks(self):
        """@return 0 if all checks pass, otherwise non-zero"""
        rc = 0
        # Check that all of the XDD's are the same version
        base = None
        current = None
        for f in self.factory.getFlowBuilders():
            current = f.protocolVersion()
            if base is None:
                base = current
            if current is None or not current or current != base:
                print("ERROR: XDD Protocols do not match", file=sys.stderr)
                rc = 1
                break
            

        # Print a generic warning if the sinks do not have pre-allocation
        # support
        for s in self.factory.getSinkFlowBuilders():
            if not s.hasPreallocateAvailable():
                print("WARNING: XDD preallocation support not available", 
                      file=sys.stderr)
        return rc

    def createFlows(self):
        """Create local and remote flows"""
        assert False == self.isCreated
        assert 0 < self.requestSize
        assert 0 < len(self.sources)
        assert 0 < len(self.sinks)
        assert self.sinkTarget
        assert self.sourceTarget
        self.factory = FlowBuilderFactory(self.requestSize,
                                          self.sourceDIOFlag, 
                                          self.sourceSerialFlag, 
                                          self.sourceVerboseFlag, 
                                          self.sourceTimestampFlag,
                                          self.sourceXddPath,
                                          self.sources,
                                          self.sinkDIOFlag, 
                                          self.sinkSerialFlag, 
                                          self.sinkVerboseFlag, 
                                          self.sinkTimestampFlag,
                                          self.sinkXddPath,
                                          self.sinks)
        rc = self.factory.createFlowBuilders()
        if 0 == rc:
            self.isCreated = True
            rc = self.performPostCreateChecks()
        return rc

    def startFlows(self, sourceFile, sinkFile):
        """Start all flows in correct order"""
        assert True == self.isCreated
        assert False == self.isStarted
        rc = 0
        self.currentFile = sourceFile

        # If needed get a transfer size
        if not self.transferSize:
            s = self.factory.getSourceFlowBuilders()[0]
            transferSize = s.getFileSize(sourceFile)
        else:
            transferSize = self.transferSize

        # Start sinks first
        sinks = self.factory.getSinkFlowBuilders()
        for s in sinks:
            r = s.startFlow(sinkFile, transferSize, self.restartFlag, 0)
            if 0 != r:
                print('Sink flow failed during startup', s.errorString())
                rc += 1

        # Then start sources
        sources = self.factory.getSourceFlowBuilders()
        for s in sources:
            r = s.startFlow(sourceFile, transferSize, self.restartFlag, 0)
            if 0 != r:
                print('Source flow failed during startup', s.errorString())
                rc += 1

        # Update the log
        self.writeLog()

        # If all went well, set state and start timer
        if 0 == rc:
            self.isStarted = True
            self.beginTime = time.time()
            self.currentFlowSize = transferSize
        return rc

    def monitorFlows(self, monitorInterval):
        """Determine if flows are still functioning"""
        assert True == self.isStarted
        builders = self.factory.getFlowBuilders()
        completedByte = 0
        completeCount = 0
        while completeCount < len(builders):
            monBegin = time.time()
            completedByte = 0
            completeCount = 0
            for b in builders:
                if b.completionStatus() is not None:
                    completeCount += 1
                # Get the progress very conservatively
                byte = b.currentByte()
                if (completedByte == 0) or (byte < completedByte):
                    completedByte = byte
            self.showProgress(self.currentFile, completedByte)
            monEnd = time.time()

            # Sleep until its time to monitor again
            interval = monEnd - monBegin
            if interval < monitorInterval:
                time.sleep(monitorInterval - interval)

        # If the completion status for all builder is success, print out
        # a final progress message
        failures = 0
        for b in builders:
            failures += b.completionStatus()
        if 0 == failures:
            self.showProgress(self.currentFile, self.currentFlowSize)
            print('')


        return 0

    def startAndMonitorFlows(self, monitorInterval):
        """
        Used to transfer and monitor a directory or multiple files
        as part of a single transfer
        """
        # First determine if the sink path exists
        sink = self.factory.getSinkFlowBuilders()[0]
        sinkExists = sink.pathExists(self.sinkTarget)
        sinkIsDir = sink.pathIsDir(self.sinkTarget)
        
        # Use one of the sources to build the transfer pairs
        # Note you have to do this on the source in case the requested
        # path is a directory or symlink
        source = self.factory.getSourceFlowBuilders()[0]
        (rc, dirs, files, links) = source.buildWalk(self.sourceTarget,
                                                    self.sinkTarget,
                                                    sinkExists,
                                                    sinkIsDir)
        if 0 == rc:
            # Build all of the remote directories with the first sink
            for (sdir, tdir) in dirs:
                self.beginTime = time.time()
                self.currentFlowSize = 0
                sink.createDirectory(tdir)
                self.showProgress(sdir, 0)
                print()

            # Move all files
            for (sfile, tfile) in files:
                rc = self.startFlows(sfile, tfile)
                if 0 != rc:
                    break
                self.monitorFlows(monitorInterval)
            # Create all symlinks
            for (ssym, tsym, link) in links:
                self.beginTime = time.time()
                self.currentFlowSize = 0
                sink.createSymlink(tsym, link)
                self.showProgress(ssym, 0)
                print()
        else:
            print('ERROR:  Unable to access source', self.sourceTarget)
        return rc

    def cleanupFlows(self):
        """
        Determine exit status for stopped flows, and kill any remaining flows
        """
        rc = 0
        if self.factory:
            flowBuilders = self.factory.getFlowBuilders()
            for f in flowBuilders:
                if True == f.pollFlow():
                    f.cancelFlow()
                    print('Cancelling Flow')
                    rc = 1
                elif 0 != f.completionStatus():
                    print('Flow exited with code:', f.completionStatus())
                    print('Flow cmd:', f.executeString())
                    rc = 2

            self.factory.shutdown()
            del self.factory

        self.isCreate = False
        self.isStarted = False
        self.isCompleted = True
        return rc

    def completedSuccessfully(self):
        """@return true if the flows completed successfully"""
        return self.isComplete and self.isSuccess

    def showProgress(self, filename, completedBytes):
        """Print a status line to stderr without a linefeed"""
        try:
            # Calculate the status values
            pctProgress = (float(completedBytes) / self.currentFlowSize) * 100.0;
            transferTime = time.time() - self.beginTime
            bandwidth = float(completedBytes) / transferTime
            eta = '--:--:--'
        except ZeroDivisionError:
            # Zero size flows are completed by definition
            pctProgress = 100.0
            transferTime = time.time() - self.beginTime
            bandwidth = 0.0
            eta = '00:00:00'

        if (bandwidth > 0):
            eta_secs = round((self.currentFlowSize - completedBytes) /bandwidth)
            td = datetime.timedelta(seconds=eta_secs)
            eta = str(td)

        # Get the width of the terminal
        #(cols, rows) = os.get_terminal_size()
        (r, c) = os.popen('stty size').read().split()
        cols = int(c)

        # Generate the status string
        status = str(round(pctProgress)) + '% '
        status += str(round(bandwidth / 1024.0 / 1024.0)) + 'MiB/s '
        status += eta + ' ETA'
           
        # Determine the padding length between the file name and status
        padding = ' '
        if cols > (len(status) + len(filename)):
            padding *= cols - len(status) - len(filename)
        
        # Clear the existing status line with whitespace
        print('\r', ' ' * cols, sep='', end='', file=sys.stderr)
         
        # Write the new status line
        print('\r', filename, padding, status, 
              sep='', end='', file=sys.stderr)

    def writeLog(self):
        """Log current status"""
        if self.verboseLog is not None:
            f = open(self.verboseLog, 'a')
            if self.sinkVerboseFlag:
                sinks = self.factory.getSinkFlowBuilders()
                for s in sinks:
                    f.write(s.executeString() + os.linesep)
            if self.sourceVerboseFlag:
                sources = self.factory.getSourceFlowBuilders()
                for s in sources:
                    f.write(s.executeString() + os.linesep)
            f.close()
