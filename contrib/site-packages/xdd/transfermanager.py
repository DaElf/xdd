
#
# Python stuff to improve portability
#
from __future__ import print_function

#
# Generic python packages used
#
import datetime
import fcntl
import getpass
import os
import select
import SocketServer
import socket
import subprocess
import sys
import threading
import time
from stat import *

#
# XDD packages
#
from xdd.core import TransferPreconditionError
from xdd.factory import FlowBuilderFactory


#
# Interface classes to interact with local and remote XDD flows
#
class TransferManager:
    """
    Manager for creating, monitoring, and deallocating local and remote flows.
    """

    def __init__(self):
        """Constructor"""
        self.isCreated = False
        self.isStarted = False
        self.isComplete = False
        self.isSuccess = False
        self.factory = None
        self.beginTime = None

        self.requestSize = 0
        self.transferSize = 0
        self.restartFlag = False
        self.sinkDIOFlag = False
        self.sinkSerialFlag = False
        self.sinkTimestampFlag = False
        self.sinkVerboseFlag = False
        self.sinkTarget = None
        self.sinkXddPath = ''
        self.sinks = []
        self.sourceDIOFlag = False
        self.sourceSerialFlag = False
        self.sourceVerboseFlag = False
        self.sourceTimestampFlag = False
        self.sourceTarget = None
        self.sourceXddPath = ''
        self.sources = []

    def setRequestSize(self, reqSize):
        """Set the chunk size of data to move across the wire"""
        self.requestSize = reqSize
        
    def setTransferSize(self, transferSize):
        """Set the size of data to move across the wire"""
        self.transferSize = transferSize
        
    def setRestartFlag(self, restartFlag):
        """Set the amount of data previously sent across the wire"""
        self.restartFlag = True
        
    def setSinkTarget(self, target, dioFlag=False, serialFlag=False):
        """ Set the name of of the sink target file"""
        assert not self.isCreated
        self.sinkTarget = target
        self.sinkDIOFlag = dioFlag
        self.sinkSerialFlag = serialFlag

    def setSourceTarget(self, target, dioFlag=False, serialFlag=False):
        """Set the name of the source target file"""
        assert not self.isCreated
        self.sourceTarget = target
        self.sourceDIOFlag = dioFlag
        self.sourceSerialFlag = serialFlag

    def setVerbosity(self, verboseLevel, filename):
        """Set the level of verbosity"""
        if 1 <= verboseLevel:
            self.verboseFlag = True
        if 2 <= verboseLevel:
            self.timestampFlag = True
        self.verboseLog = filename

    def addSink(self, hostname, threads, ifs = [], port = 40000):
        """Add a sink to the list of sinks"""
        assert not self.isCreated
        assert hostname
        assert 0 < threads
        sink = {'hostname': hostname, 'threads': threads, 
                'port': port, 'ifs': []}
        if 0 == len(ifs):
            sink['ifs'].append(hostname)
        else:
            sink['ifs'].extend(ifs)
        self.sinks.append(sink)

    def addSource(self, hostname, threads, ifs = [], port = 40000):
        """Add a source to the list of sources"""
        assert not self.isCreated
        assert hostname
        assert 0 < threads
        source = {'hostname': hostname, 'threads': threads, 
                  'port': port, 'ifs': []}
        if 0 == len(ifs):
            source['ifs'].append(hostname)
        else:
            source['ifs'].extend(ifs)
        self.sources.append(source)

    def setSinkXddPath(self, path):
        """Set the path sinks use to find xdd"""
        self.sinkXddPath = path

    def setSourceXddPath(self, path):
        """Set the path sources use to find xdd"""
        self.sourceXddPath = path

    def setXddPath(self, path):
        """Set the path used to find xdd"""
        self.sinkXddPath = path
        self.sourceXddPath = path

    def performPostCreateChecks(self):
        """@return 0 if all checks pass, otherwise non-zero"""
        rc = 0
        # Check that all of the XDD's are the same version
        v = ''
        for f in self.factory.getFlowBuilders():
            if '' == v:
                v = f.protocolVersion()
            elif v != f.protocolVersion():
                print("ERROR: XDD Protocols do not match", file=sys.stderr)
                rc = 1

        # Print a generic warning if the sinks do not have pre-allocation
        # support
        for s in self.factory.getSinkFlowBuilders():
            if not s.hasPreallocateAvailable():
                print("WARNING: XDD preallocation support not available", 
                      file=sys.stderr)
        return rc

    def createFlows(self):
        """Create local and remote flows"""
        assert False == self.isCreated
        assert 0 < self.requestSize
        assert 0 < self.transferSize
        assert 0 < len(self.sources)
        assert 0 < len(self.sinks)
        assert self.sinkTarget
        assert self.sourceTarget
        self.factory = FlowBuilderFactory(self.requestSize,
                                          self.sourceDIOFlag, 
                                          self.sourceSerialFlag, 
                                          self.sourceVerboseFlag, 
                                          self.sourceTimestampFlag,
                                          self.sourceXddPath,
                                          self.sources,
                                          self.sinkDIOFlag, 
                                          self.sinkSerialFlag, 
                                          self.sinkVerboseFlag, 
                                          self.sinkTimestampFlag,
                                          self.sinkXddPath,
                                          self.sinks)
        rc = self.factory.createFlowBuilders()
        if 0 == rc:
            self.isCreated = True
            rc = self.performPostCreateChecks()
        return rc

    def startFlows(self):
        """Start all flows in correct order"""
        assert True == self.isCreated
        assert False == self.isStarted
        rc = 0

        # Start sinks first
        sinks = self.factory.getSinkFlowBuilders()
        for s in sinks:
            r = s.startFlow(self.sinkTarget, self.transferSize, 
                            self.restartFlag, 0)
            if 0 != r:
                print('Sink flow failed during startup', s.errorString())
                rc += 1

        # Then start sources
        sources = self.factory.getSourceFlowBuilders()
        for s in sources:
            r = s.startFlow(self.sourceTarget, self.transferSize, 
                            self.restartFlag, 0)
            if 0 != r:
                print('Source flow failed during startup', s.errorString())
                rc += 1

        # If all went well, set state and start timer
        if 0 == rc:
            self.isStarted = True
            self.beginTime = time.time()
        return rc

    def monitorFlows(self, monitorInterval):
        """Determine if flows are still functioning"""
        assert True == self.isStarted
        builders = self.factory.getFlowBuilders()
        completedByte = 0
        completeCount = 0
        while completeCount < len(builders):
            monBegin = time.time()
            completedByte = 0
            for b in builders:
                if b.completionStatus() is not None:
                    completeCount += 1
                # Get the progress very conservatively
                byte = b.currentByte()
                if (completedByte == 0) or (byte < completedByte):
                    completedByte = byte
            self.showStatus(completedByte)
            monEnd = time.time()

            # Sleep until its time to monitor again
            interval = monEnd - monBegin
            if interval < monitorInterval:
                time.sleep(monitorInterval - interval)

        return 0

    def cleanupFlows(self):
        """
        Determine exit status for stopped flows, and kill any remaining flows
        """
        rc = 0
        if self.factory:
            flowBuilders = self.factory.getFlowBuilders()
            for f in flowBuilders:
                if True == f.pollFlow():
                    f.cancelFlow()
                    print('Cancelling Flow')
                    rc = 1
                elif 0 != f.completionStatus():
                    print('Flow exited with code:', f.completionStatus())
                    print('Flow cmd:', f.executeString())
                    rc = 2

            self.factory.shutdown()
            del self.factory

        # On success, print out a final status
        if (0 == rc):
            self.showStatus(self.transferSize)
            print('')

        self.isCreate = False
        self.isStarted = False
        self.isCompleted = True
        return rc

    def completedSuccessfully(self):
        """@return true if the flows completed successfully"""
        return self.isComplete and self.isSuccess

    def showStatus(self, completedBytes):
        """Print a status line to stderr without a linefeed"""
        # Calculate the status values
        pctProgress = (float(completedBytes) / self.transferSize) * 100.0;
        transferTime = time.time() - self.beginTime
        bandwidth = float(completedBytes) / transferTime
        eta = '00:00:00'
        if (bandwidth > 0):
            eta_secs = round((self.transferSize - completedBytes) / bandwidth)
            td = datetime.timedelta(seconds=eta_secs)
            eta = str(td)

        # Get the width of the terminal
        #(cols, rows) = os.get_terminal_size()
        (r, c) = os.popen('stty size').read().split()
        cols = int(c)

        # Generate the status string
        status = str(round(pctProgress)) + '% '
        status += str(round(bandwidth / 1024.0 / 1024.0)) + 'MiB/s '
        status += eta + ' ETA'
           
        # Determine the padding length between the file name and status
        padding = ' '
        if cols > (len(status) + len(self.sinkTarget)):
            padding *= cols - len(status) - len(self.sinkTarget)
        
        # Clear the existing status line with whitespace
        print('\r', ' ' * cols, sep='', end='', file=sys.stderr)
         
        # Write the new status line
        print('\r', self.sinkTarget, padding, status, 
              sep='', end='', file=sys.stderr)

