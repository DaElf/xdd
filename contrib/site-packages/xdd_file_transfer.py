#!/bin/env python

#
# Stupid python-isms to make code slightly more portable
#
from __future__ import print_function

#
# Import modules
#
import optparse
import sys
import xdd

class InvalidSpecError(Exception):
    """Spec was not of the format [[user@]host[,[user@]host]:]file"""
    pass

class FailedTransferError(Exception):
    """File transfer failed"""
    pass


def createParser():
    """Create an option parser for xddmcp"""
    usage='usage: xddmcp [Options] [host[,host]:]sfile [host:]dfile'
    parser = optparse.OptionParser(usage=usage)
    parser.add_option('-a', '--resume', dest='resume',
                      action='store_true', default=False,
                      help='enable resume for partially completed transfers')
    parser.add_option('-d', dest='dio', 
                      action='store', type='choice', choices=['s', 'd', 'b'],
                      metavar='s|d|b',
                      help='use direct I/O for the specified side (s for source, d for dest, b for both sides)')
    parser.add_option('-o', dest='ordered',
                      action='store', type='choice', choices=['s', 'd', 'b'],
                      metavar='s|d|b',
                      help='use serial ordering for the specified side (s for source, d for dest, b for both sides)')
    parser.add_option('-n', '--retry', dest='retries', 
                      action='store', type='int', default=0, metavar='N',
                      help='on failure, retry up to N times [Default: 0]')
    parser.add_option("-p", "--port", dest='port',
                      action='store', type='int', default=40000,
                      help='set the first listen port [Default: 40000]')
    parser.add_option('-r', dest='recursive', 
                      action='store_true', default=True,
                      help='copy files recursively [Default: On]')
    parser.add_option('-t', dest='threads',
                      action='store', type='int', default=8,
                      help='set the number of parallel streams [Default: 8]')
    parser.add_option('-s', '--size', dest='size',
                      action='store', type='int', default=None,
                      help='number of source device bytes to transfer')
    parser.add_option('-v', dest='verbose',
                      action='store_true', default=False,
                      help='create a log file')
    parser.add_option('-V', dest='verbose2',
                      action='store_true', default=False,
                      help='add timestamp output to log')
    return parser

def parseSpec(spec):
    """
    Parse spec.  The current spec format is:
    [[user@]host[,[user@]host]:]file
    """
    # Return entry defaults
    userHostTuples = []
    filename = ''

    # First split at the colon to get the hosts and files
    parts = spec.split(':')
    if 1 == len(parts):
        filename = spec
    elif 2 == len(parts):
        hspec = parts[0]
        filename = parts[1]
        # Second, split hosts at comma
        hlist = hspec.split(',')
        for h in hlist:
            # Finally, split at @ to get user and host
            uh = h.split('@')
            if 1 == len(uh) and 0 != len(h):
                userHostTuples.append( (None, h) )
            elif 2 == len(uh) and 0 != len(uh[0]) and 0 != len(uh[1]):
                userHostTuples.append( (uh[0], uh[1]) )
            else:
                raise InvalidSpecError
    else:
        raise InvalidSpecError

    # Finally, make sure what we have makes sense
    if 0 == len(filename):
        raise InvalidSpecError

    return (userHostTuples, filename)

def createTransferManager(src, dest, opts):
    """
    Use the supplied command line arguments to create a TransferManager
    """
    # Create the TransferManager
    transferMgr = xdd.TransferManager()

    # Add options
    transferMgr.setRequestSize(8192)
    if opts.size is not None:
        transferMgr.setTransferSize(opts.size)

    # Add sources
    (sourceTuples, sfile) = src
    transferMgr.setSourceTarget(sfile, 
                                dioFlag=opts.dio, serialFlag=opts.ordered)
    for s in sourceTuples:
        (user, host) = s
        transferMgr.addSource()

    # Add destinations
    (destTuples, dfile) = dest
    transferMgr.setSinkTarget(dfile, dioFlag=False, serialFlag=False)
    transferMgr.addSource("localhost", 1)

    # Add destination
    transferMgr.addSink("bws-mbpro2", 1)


def performTransfer(transferMgr, retries):
    """
    Perform the transfer and print out monitoring information.
    """
    # Handle retries here
    rc = 0
    failCount = 0
    count = -1
    while count < retries:
        if count >= 0:
            print("INFO: Retrying failed transfer")
        count += 1
        try:
            # Create all remote flow elements
            rc = transferMgr.createFlows()
            if 0 != rc:
                print("ERROR: File data transfer failed during flow creation.")
                raise XDDTransferMasterException()

             # Start and monitor the flows
            rc = transferMgr.startFlows()
            if 0 != rc:
                print("ERROR: File data transfer failed during startup.")
                raise XDDTransferMasterException()
            else:
                break

        finally:
            # Stop all of the flows and get their status
            transferMgr.cleanupFlows()

    return rc

#
# Main
#
# Current algorithm is
#   For remote hosts, ensure that ssh access exists
#   For all hosts, check flow preconditions (permissions, etc.)
#   Start all XDD-based flows
#
#   If at any point an error occurs, go back and shut down anything that has
#   been successfuly started, and report the detected error to the user.
#   Also report anything that could not be successfully shutdown.
#
def main():
    rc = 0
    parser = createParser()
    (args, opts) = parser.parse_args()
    if 2 > len(args):
        print('ERROR: Source and destination names are required')
        parser.print_usage()
        return 1

    # Convert arguments in sources and destination
    i = 0
    sources = []
    try:
        for spec in args:
            if len(sources) < len(args) - 1:
                sources.append( parse_spec(spec))
        else:
            dest = parse_spec(spec)
    except:
        print('ERROR: Invalid spec: ', spec)
        parser.print_usage()
        return 1
                

    # Perform a transfer for each source
    try:
        for src in sources:
            tmgr = createTransferManager(src, dest, opts)
            performTransfer(tmgr, opts.retries)
    except:
        print('ERROR: Failed transferring ', src, ' to ', dest)
        rc = 2

    return rc
    
# Execute main
if __name__ == "__main__":
    main()
