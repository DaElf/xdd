#!/bin/bash
#
# IMPORTANT NOTE: I found it necessary to delete the destination file
# before every test *IF* the same namespace is used AND the test used
# a smaller file size than the previous test. It seems as though the
# destination file is not truncated to the newer, SMALLER size, thus
# md5sum goes after the old size and gives different sums. I know WHAT
# happens, but not WHY. Is this an XDD or XFS issue??? Just be forewarned.
#
#

# XDD Configurable global settings
XDDCP_DEFAULT_E2E_PORT=40010
XDDCP_DEFAULT_XFER_SIZE=16777216
XDDCP_DEFAULT_QUEUE_DEPTH=4
XDDCP_DEFAULT_SSH_PSEUDO_TERMINAL_OPT="-T"
XDDCP_DEFAULT_HEARTBEAT_SECS=4
XDDCP_DEFAULT_TIMESTAMP="$(date -u +'%Y-%m-%d-%H%M')-GMT"

#
# Print out the usage information
#
function print_usage() {
    echo "xddcp [OPTIONS] source_file destination_host:destination_file [size]"
    echo ""
    echo "source_file       - complete /filepath/name for source file on source host"
    echo "destination_host  - destination host IP or Name over which data is transferred"
    echo "destination_file  - complete /filepath/name for destination file on destination host"
    echo "size              - number of bytes to transfer [Default: size of source file]"
    echo ""
    echo "OPTIONS: "
    echo " -a		- Resume transfer if it was only partially completed and the -a flag was specified"
    echo " -d		- Use direct I/O on the destination end"
    echo " -F		- Transfer a list of files named in source_file"
    echo " -h		- Print out usage information"
    echo " -p portnum   - First port to use for transfer [Default: $XDDCP_DEFAULT_E2E_PORT]" 
    echo " -s		- Use direct I/O on the source end"
    echo " -t threads	- Use 'threads' number of threads during transfer [Default: $XDDCP_DEFAULT_QUEUE_DEPTH]"
    #echo "-Y		- Force SSH to create psueo-terminal tty"
    echo "NOTE: 'xdd.Linux' and script 'qipcrm' must be in your PATH env on both source and destination hosts!!!"
}

#
# Check preconditions for the host
#
function check_host_preconditions() {

    # Arguments
    local sourceSideFilename=$1
    local fileListFlag=$2
    local fileSizeFlag=$3
    local resumeFlag=$4

    # Check for qipcrm script
    which qipcrm > /dev/null 2> /dev/null
    if [ $? -eq 1 ]; then
	echo "ERROR: qipcrm executable was not found.  Please make sure it is in your PATH."
	exit 10
    fi

    # Check for xdd.Linux binary
    which xdd.Linux >/dev/null 2> /dev/null
    if [ $? -eq 1 ]; then
        echo "ERROR: xdd.Linux executable was not found.  Please make sure it is in your PATH."
        exit 11
    fi

    # Ensure flag combinations are valid
    if [ 1 -eq $fileListFlag -a 1 -eq $resumeFlag ]; then
        echo "ERROR: The -a and -F flags cannot be used simulataneously."
        exit 12
    elif [ 1 -eq $fileListFlag -a 1 -eq $fileSizeFlag ]; then
        echo "ERROR: Cannot specify -F flag and a file size simulataneously."
        exit 13
    fi

    # Ensure source side file exists
    if [ ! -r "${sourceSideFilename}" ]; then
	echo "ERROR: Cannot read source file: ${sourceSideFilename}"
	exit 14
    fi
}

#
# Check preconditions for the source side file
#
function check_source_file_preconditions() {

    # Arguments
    local sourceSideFilename=$1
    local fileSizeFlag=$2
    local transferSize=$3

    # Ensure source side file exists
    if [ ! -r "${sourceSideFilename}" ]; then
	echo "ERROR: Cannot read source file: ${sourceSideFilename}"
	exit 20
    fi

    # Ensure file is large enough
    local sourceDir="$(dirname $sourceSideFilename)"
    if [ "$sourceDir" != "/dev" ]; then
        local trueSize=$(stat -c '%s' "$sourceSideFilename")
        if [ 16777216 -gt $trueSize ]; then
            echo "ERROR: Cannot transfer files smaller than 16MiB"
            exit 21
        elif [ 1 -eq $fileSizeFlag -a $transferSize -gt $trueSize ]; then
            echo "ERROR: Requested transfer size is larger than file size: $transferSize > $trueSize"
            exit 22
        fi
    fi
}

#
# Perform local cleanup operations
#
function perform_local_cleanup() {
    qipcrm ${USER} > /dev/null
    pgrep -u ${USER} -f xdd.Linux | xargs kill -9 2> /dev/null
}

#
# Initialize local transfer
#
function init_local_transfer() {

    # Arguments
    local remoteHost=$1
    local sourceFile=$2
    local totalBytes=$3
    local queueDepth=$4
    local e2ePort=$5
    local sourceDIOFlag=$6
    local resumeFlag=$7
    local resumeOffset=$8

    # Construct XDD transfer settings
    let "xfer      = ${XDDCP_DEFAULT_XFER_SIZE}"
    let "numreqs   = ${totalBytes} / $xfer"
    let "blocksize = 1024"
    let "reqsize   = $xfer / $blocksize"

    # Validate restart flag if necessary
    sourceRestart=""
    if [ 1 == $resumeFlag ]; then
        if [ "enable" == "$resumeOffset" ]; then
            sourceRestart="-restart enable"
        elif [ 0 -le $resumeOffset ]; then
            echo "INFO: Resuming XDD file transfer at offset: $resumeOffset"
            sourceRestart="-restart enable -restart offset $resumeOffset"
        else
	    echo "ERROR: Invalid restart offset: $resumeOffset"
	    exit -10
        fi
    fi

    # Construct source XDD settings
    local sourceBase=$(basename ${sourceFile})
    local sourceQD="-queuedepth ${queuedepth}"
    local sourceLog="xdd.$(hostname).${sourceBase}.${XDDCP_DEFAULT_TIMESTAMP}.log"
    if [ 1 -eq $sourceDIOFlag ]; then
        local sourceDIO="-dio"
    fi

    # Construct local transport endpoint
    xdd.Linux -targets 1  ${sourceFile} -op read -minall \
        -bytes ${totalBytes} -reqsize ${reqsize} ${sourceQD} \
        -e2e issource -e2e dest ${remoteHost} -e2e port ${e2ePort} \
        ${sourceDIO} ${sourceRestart} \
        -output ${sourceLog} -heartbeat ${XDDCP_DEFAULT_HEARTBEAT_SECS}

    # Check transfer completion status
    transfer_rc=$?
    if [ 0 -eq "$transfer_rc" ]; then
        echo "Transfer finished (use md5sum to validate transfer)."
    else
        echo "ERROR: Transfer did not complete.  XDD Error Code: $transfer_rc"
        exit -11
    fi
}

#
# Perform remote cleanup and construct remote transport endpoint
#
function init_remote_transfer() {
    # Arguments
    local remoteHost="$1"
    local sshOpts="$2"
    local srcFile="$3"
    local destFile="$4"
    local totalBytes="$5"
    local queueDepth="$6"
    local e2ePort="$7"
    local destDIOFlag="$8"
    local resumeFlag="$9"

    # Construct transfer settings
    let "xfer      = ${XDDCP_DEFAULT_XFER_SIZE}"
    let "numreqs   = $totalBytes / $xfer"
    let "blocksize = 1024"
    let "reqsize   = $xfer / $blocksize"

    # Other variables
    local srcBase=$(basename $srcFile)
    local destinationBase=$(basename $destFile)
    local destinationDirname=$(dirname $destFile)
    local destinationLog="xdd.${remoteHost}.${destinationBase}.${XDDCP_DEFAULT_TIMESTAMP}.log"
    local destinationQD="-queuedepth ${queueDepth}"
    if [ 1 -eq $destDIOFlag ]; then
        local destinationDIO="-dio"
    fi
    remote_output=$(ssh ${sshOpts} ${remoteHost} bash <<EOF

# Kill any stale xdd processes
xddpid=\$(pgrep -u \${USER} -fl xdd.Linux |grep -v pgrep |cut -f 1 -d ' ')
if [ ! -z "$xddpid" ]; then
    kill \$xddpid
    sleep 1
    kill -9 \$xddpid
fi

# Cleanup leaked system resources
qipcrm \${USER} &>/dev/null

# If the filename uses a relative path, path complement it
path_char=\$(dirname $destFile |cut -c 1)
#echo "First path char: \$path_char"
if [ "." == \$path_char ]; then
    default_dir=\$(pwd)
    destinationDir="\${default_dir}/${destinationDirname}"
    destinationFile="\${default_dir}/${destFile}"
    destinationLog="\${default_dir}/${destinationLog}"
else
    destinationDir="${destinationDirname}"
    destinationFile="${destFile}"
    destinationLog="\${destinationDir}/${destinationLog}"
fi
#echo "Path complemented filename is \$destinationFile"
#echo "Path complemented logfile is \$destinationLog"

# Ensure destination is writable
if [ ! -d \$destinationDir ]; then
    echo "Cannot write to directory: \$destinationDir"
    exit -1
fi

# Perform restart if neccesary
if [ 1 == $resumeFlag ]; then

    # Create the name for a new restart cookie
    restart_logfile="\${destinationDir}/xdd.$(hostname).${srcBase}.${remoteHost}.${destinationBase}.${XDDCP_DEFAULT_TIMESTAMP}.rst"

    # Check for the existence a restart cookie
    most_recent_restart_cookie=\$(ls \${destinationDir}/xdd.$(hostname).${srcBase}.${remoteHost}.${destinationBase}.*.rst 2>/dev/null |tail -1)
    echo "Using restart cookie: \$most_recent_restart_cookie"
    if [ -z "\$most_recent_restart_cookie" ]; then
       destinationRestart="-restart file \${restart_logfile} -restart enable"
    else
       destinationRestart="-restart file \${restart_logfile} -restart enable \$(cat \$most_recent_restart_cookie)"
    fi
fi

# Start the XDD process
echo "Starting remote xdd . . ."
xdd.Linux -targets 1 \${destinationFile} -op write -minall \
    -bytes ${totalBytes} -reqsize $reqsize ${destinationQD} \
    -e2e isdestination -e2e dest ${remoteHost} -e2e port ${e2ePort} \
    ${destinationDIO} \${destinationRestart} \
    -verbose &> \${destinationLog} &

# Send the restart offset back to the source side via an exit code
if [ 1 == $resumeFlag ]; then
    echo "XDDCP RESTART TOKENS: \${destinationRestart}"
fi

EOF
    )

    # Check the status of remote operations
    dest_rc=$?
    #echo "Remote output strings are >$remote_output<"
    #echo "Remote return code is: $dest_rc"
    if [ 255 -eq $dest_rc ]; then
        echo "ERROR: Failure spawning remote XDD.  $remote_output"
        exit -7
    elif [ -z "$remote_output" ]; then
        echo "ERROR: Remote session failed."
        exit -8
    fi

    # Extract the resume offset from the remote output
    if [ 1 == $resumeFlag ]; then
        resumeOffset=$(echo $remote_output |rev |cut -d ' ' -f 1 |rev)
        if [ -z "$resumeOffset" ]; then
            echo "ERROR: SSH psueo-terminal problems.  Adding '-Y' to the command line may fix this problem."
            exit -9
        fi
    fi
}

#
# Main
#
if [ "$1" == "-h" ]; then
    print_usage
    exit 0
elif [ $# -lt 2 ]; then
    echo "usage: $0 [OPTION] /full_path/source_file destination_host:/full_path/destination_file [bytes_to_transfer]"
    echo "Try '$0 -h' for more information."
    exit 1
fi

# Parse options
resumeFlag=0
destinationDIOFlag=0
e2eport=$XDDCP_DEFAULT_E2E_PORT
fileListFlag=0
sourceDIOFlag=0
queuedepth=$XDDCP_DEFAULT_QUEUE_DEPTH
sshoption=$XDDCP_DEFAULT_SSH_PSEUDO_TERMINAL_OPT

while getopts ":adFhp:st:Y" option; do
    case $option in
        a) resumeFlag=1;;
	d) destinationDIOFlag=1;;
        F) fileListFlag=1;;
	h) print_usage; exit 0;;
        p) e2eport=$OPTARG;;
	s) sourceDIOFlag=1;;
	t) queuedepth=$OPTARG;;
        Y) sshoption="-tt";;
        \?) echo "ERROR:  Invalid option specified: -$OPTARG"; exit 1;;
    esac
done
shift $((OPTIND-1))

# Parse out source file and source host
TDSource="$1"
HSourceIP=`hostname`

# Parse out destination file and destination host
colon_count=`echo $2 | grep -c ":"`
if [ $colon_count -eq 1 ]; then
    HDestin=`echo $2 | awk -F: '{print $1}'`
    HDestinIP=$HDestin
    TDDestin=`echo $2 | awk -F: '{print $2}'`

    # Pull off the username if it exists
    amp_count=$(echo ${HDestinIP} |grep -c "@")
    if [ 1 -eq $amp_count ]; then
        remoteUsername=$(echo ${HDestinIP} |awk -F@ '{print $1}')
        HDestinIP=$(echo ${HDestinIP} |awk -F@ '{print $2}')
        sshoptions="$sshoptions -l $remoteUsername"
    fi
else
    echo "ERROR: Destination format must be in the form '[user@]host:filename'"
    exit 2
fi

# Get the specified size if it is defined
fileSizeFlag=0
totalbytes=0
if [ ! -z "$3" ]; then
    fileSizeFlag=1
    totalbytes=$3
fi

# Ensure local-side preconditions are met
check_host_preconditions ${TDSource} ${fileListFlag} ${fileSizeFlag} ${resumeFlag}

# Handle a set of input file
sourceFileList="${TDSource}"
if [ 1 -eq $fileListFlag ]; then
    sourceFileList=$(cat ${TDSource})
fi

# Process all source files
for sourceFile in ${sourceFileList}; do

    # Construct the detination filename if there are multiple sources
    destFile=${TDDestin}
    if [ 1 -eq $fileListFlag ]; then
        sourceNameBase=$(basename $sourceFile)
        destFile="${TDDestin}/${sourceNameBase}"
        echo "INFO: Starting transfer for: $sourceFile"
    fi

    # Perform source side cleanup
    perform_local_cleanup

    # Ensure source file preconditions are met
    check_source_file_preconditions ${sourceFile} ${fileSizeFlag} ${totalbytes}
    if [ 0 -eq $fileSizeFlag ]; then
        totalbytes=$(stat -c "%s" ${sourceFile})
    fi

    # Initialize the remote transfer (note $resumeOffset is set as a side effect of init_remote_transfer
    init_remote_transfer ${HDestinIP} ${sshoption} ${sourceFile} ${destFile} ${totalbytes} ${queuedepth} ${e2eport} ${destinationDIOFlag} ${resumeFlag} 
    if [ 1 -eq "${resumeFlag}" ]; then
        if [ -z "${resumeOffset}" ]; then
            echo "ERROR: Restart offset could not be determined."
            exit -10
        fi
    fi

    # Initialize the local-side transfer (note $resumeOffset is set as a side effect of init_remote_transfer)
    init_local_transfer ${HDestinIP} ${sourceFile} ${totalbytes} ${queuedepth} ${e2eport} ${sourceDIOFlag} ${resumeFlag} ${resumeOffset}

done

# Return success
exit 0
