#!/bin/bash
#
# This program is free software; you can redistribute it and/or modify 
# it under the terms of the GNU General Public License as published by 
# the Free Software Foundation; either version 2 of the License, or 
# (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful, but 
# WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY 
# or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License 
# for more details.
# 
# You should have received a copy of the GNU General Public License along 
# with this program; if not, write to the Free Software Foundation, Inc., 
# 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
#
#
# This file is part of XDD
#
# Copyright (C) 2010, Brad Settlemyer
#
# Description:  This script enables the use of XDD as a remote data movement
# engine.  Its functionality loosely mimics the capabilities of scp and bbcp,
# however, with hopefully much improved performance.
#
# Notes: XDDCP has only been tested on Linux environments.  The
# following POSIX utilities are required to utilize XDDCP:
#    basename
#    cat
#    cut
#    date
#    dirname
#    echo
#    grep
#    hostname
#    ps
#    tr
#
# The following other utilities (non-POSIX) are required to utilize XDDCP:
#    netstat 
#    ssh
#    stat
#    truncate
#    xdd.Linux
#

# XDD Configurable global settings
XDDCP_DEFAULT_E2E_PORT=40010
XDDCP_DEFAULT_XFER_SIZE=33554432
XDDCP_DEFAULT_QUEUE_DEPTH=4
XDDCP_DEFAULT_SSH_PSEUDO_TERMINAL_OPT="-T"
XDDCP_DEFAULT_HEARTBEAT_SECS=4
XDDCP_DEFAULT_TIMESTAMP="$(date -u +'%Y-%m-%d-%H%M%S')-GMT"
XDDCP_DEFAULT_NETWORK_SLEEP_SECS=10
XDDCP_DEFAULT_XDD="xdd.$(uname)"

# XDDCP Error Codes
XDDCP_ERR_CODE_INVALID_ARGS=1
XDDCP_ERR_CODE_INVALID_FORMAT=2
XDDCP_ERR_CODE_XDD_NOT_FOUND=3
XDDCP_ERR_CODE_QIP_NOT_FOUND=4
XDDCP_ERR_CODE_INV_FLAGS=5
XDDCP_ERR_CODE_SRC_XST=6
XDDCP_ERR_CODE_INV_RST=7
XDDCP_ERR_CODE_SSH_ERROR=8
XDDCP_ERR_CODE_SSH_FAILURE=9
XDDCP_ERR_CODE_SMALL_FILE=10
XDDCP_ERR_CODE_XFER_SIZE=11
XDDCP_ERR_CODE_VERSION_MATCH=12
XDDCP_ERR_CODE_NO_REMOTE=13
XDDCP_ERR_CODE_XFER_FAIL=14
XDDCP_ERR_CODE_DEST_PORT=15

#
# Global variables
#
g_xddcpXddVersion="-1"
g_xddcpDestXddPid="-1"
g_xddcpSrcXddPid="-1"
g_xddcpResumeOffset="0"


#
# Print out the usage information
#
function print_usage() {
    echo "xddcp [OPTIONS] source_file destination_host:destination_file [size]"
    echo ""
    echo "source_file       - complete /filepath/name for source file on source host"
    echo "destination_host  - destination host IP or Name over which data is transferred"
    echo "destination_file  - complete /filepath/name for destination file on destination host"
    echo "size              - number of bytes to transfer [Default: size of source file]"
    echo ""
    echo "OPTIONS: "
    echo " -a		- Resume transfer if it was only partially completed and the -a flag was specified"
    echo " -d		- Use direct I/O on the destination end"
    echo " -f           - If ports are unavailable on destination, attempt to kill running XDD and retry"
    echo " -F		- Transfer a list of files named in source_file"
    echo " -h		- Print out usage information"
    echo " -p portnum   - First port to use for transfer [Default: $XDDCP_DEFAULT_E2E_PORT]" 
#    echo " -o		- Ordered-mode, write data in sequential order"
#    echo " -r		- Copy sub-directories and contents recursively"
    echo " -s		- Use direct I/O on the source end"
    echo " -t threads	- Use 'threads' number of threads during transfer [Default: $XDDCP_DEFAULT_QUEUE_DEPTH]"
    echo " -v		- Add verbose output to logs"
    #echo "-Y		- Force SSH to create psueo-terminal tty"
    #echo "NOTE: 'xdd.Linux' and script 'qipcrm' must be in your PATH env on both source and destination hosts!!!"
    echo "NOTE: 'xdd.Linux' must be in your PATH env on both source and destination hosts!!!"
}

function multilevel_exit_handler() {
    local errorCode=$1
    #kill $$
}

#
# Print out an appropriate error message and exit
#
function error_exit() {
    local errorCode=$1

    trap "multilevel_exit_handler $errorCode" EXIT
    error_print $errorCode
    echo "Exiting with error code $errorCode" >/dev/stderr
    exit $errorCode
    exit $errorCode
    exit $errorCode
    echo "Under no circumstances should this line display" >/dev/stderr
}

#
# Print out an appropriate error message
#
function error_print() {
    local errorCode=$1
    case $errorCode in
        $XDDCP_ERR_CODE_INVALID_ARGS) 
            echo "ERROR: Invalid command arguments" >/dev/stderr
            ;;
        $XDDCP_ERR_CODE_INVALID_FORMAT) 
            echo "ERROR: Invalid source/destination format" >/dev/stderr
            ;;
        $XDDCP_ERR_CODE_XDD_NOT_FOUND) 
            echo "ERROR: ${XDDCP_DEFAULT_XDD} executable not found" >/dev/stderr
            ;;
        $XDDCP_ERR_CODE_QIP_NOT_FOUND) 
            echo "ERROR: qipcrm executable not found" >/dev/stderr
            ;;
        $XDDCP_ERR_CODE_INV_FLAGS) 
            echo "ERROR: Incompatible command line arguments" >/dev/stderr
            ;;
        $XDDCP_ERR_CODE_SRC_XST) 
            echo "ERROR: Cannot locate source file" >/dev/stderr
            ;;
        $XDDCP_ERR_CODE_INV_RST) 
            echo "ERROR: Invalid restart offset location" >/dev/stderr
            ;;
        $XDDCP_ERR_CODE_SSH_FAILURE) 
            echo "ERROR: Failure spawing process via SSH" >/dev/stderr
            ;;
        $XDDCP_ERR_CODE_SSH_ERROR) 
            echo "ERROR: Remote session failure" >/dev/stderr
            ;;
        $XDDCP_ERR_CODE_SMALL_FILE) 
            echo "ERROR: Cannot transfer files smaller than $XDDCP_DEFAULT_XFER_SIZE bytes" >/dev/stderr
            ;;
        $XDDCP_ERR_CODE_XFER_SIZE) 
            echo "ERROR: Requested transfer size is larger than file size" >/dev/stderr
            ;;
        $XDDCP_ERR_CODE_VERSION_MATCH) 
            echo "ERROR: ${XDDCP_DEFAULT_XDD} versions differ on source and destination" >/dev/stderr
            ;;
        $XDDCP_ERR_CODE_NO_REMOTE) 
            echo "ERROR: Local file transfers are not permitted" >/dev/stderr
            ;;
        $XDDCP_ERR_CODE_XFER_FAIL) 
            echo "ERROR: File transfer failed." >/dev/stderr
            echo "  If the reason is \"Connection refused\", check the destination logfile." >/dev/stderr
            ;;
        $XDDCP_ERR_CODE_DEST_PORT) 
            echo "ERROR: Destination port is in use" >/dev/stderr
            ;;
        \?) 
            echo "ERROR: Unknown error code" >/dev/stderr
            ;;
    esac
}

#
# Handle trapped signals
#
function handle_signal_common() {
    local signum=$1

    # Attempt to deliver the signal to XDD
    if [ -1 -ne $g_xddcpSrcXddPid ]; then
        kill -$signum $g_xddcpSrcXddPid
    fi
    echo "INFO:  Transfer cancelled by user." >/dev/stderr
}

#
# Parse endpoint spec of the form [[user@]host:]path
#
# Call with spec and variable names as arguments, e.g.:
#
# spec="user@foo.bar.com:/home/user"
# srcRemoteFlag=0
# srcUser=""
# srcHost=""
# srcPath=""
# parse_endpoint_spec $spec srcRemoteFlag srcUser srcHost srcPath
#
function parse_endpoint_spec() {
    local spec=$1
    local remoteFlagRef="$2"
    local remoteUserRef="$3"
    local remoteHostRef="$4"
    local remotePathRef="$5"
    
    # Set the outbound defaults
    eval "$remoteFlagRef=0"
    eval "$remoteUserRef=\"\""
    eval "$remoteHostRef=\"\""
    eval "$remotePathRef=\"\""
    
    # Parse out remote host and file
    local colon_count=`echo $spec | grep -c ":"`
    if [ $colon_count -eq 1 ]; then

        # Set the remote flag
        eval "$remoteFlagRef=1"

        # Set the path
        eval "$remotePathRef=$(echo $spec | awk -F: '{print $2}')"

        # Set the host
        local _tmp=$(echo $spec | awk -F: '{print $1}')
        eval "$remoteHostRef=$(echo $spec | awk -F: '{print $1}')"
        
        # Set the username if it exists
        local amp_count=$(echo $_tmp |grep -c "@")
        if [ 1 -eq $amp_count ]; then
            eval "$remoteUserRef=$(echo $_tmp |awk -F@ '{print $1}')"
            eval "$remoteHostRef=$(echo $_tmp |awk -F@ '{print $2}')"
        fi
    else
        eval "$remotePathRef=$spec"
    fi
}

#
# Check preconditions for the host
#
# Sideffects: Sets the global XDDCP version identifier
#
function check_host_preconditions() {

    # Arguments
    local sourceSideFilename=$1
    local fileListFlag=$2
    local fileSizeFlag=$3
    local resumeFlag=$4

    # Check for xdd.Linux binary
    hash ${XDDCP_DEFAULT_XDD} &>/dev/null
    if [ 0 -ne $? ]; then
        error_exit $XDDCP_ERR_CODE_XDD_NOT_FOUND
    else
        g_xddcpXddVersion=$(${XDDCP_DEFAULT_XDD} -version)
    fi

    # Ensure flag combinations are valid
    if [ 1 -eq $fileListFlag -a 1 -eq $resumeFlag ]; then
        echo "INFO: -F and -a flags cannot both be specified" >/dev/stderr
        error_exit $XDDCP_ERR_CODE_INV_FLAGS
    elif [ 1 -eq $fileListFlag -a 1 -eq $fileSizeFlag ]; then
        echo "INFO: -F and file size cannot both be specified" >/dev/stderr
        error_exit $XDDCP_ERR_CODE_INV_FLAGS
    fi

    # Ensure source side file list filename exists
    if [ 1 -eq $fileListFlag -a ! -r "${sourceSideFilename}" ]; then
	echo "INFO: Cannot read ${sourceSideFilename}" >/dev/stderr
	error_exit $XDDCP_ERR_CODE_SRC_XST
    fi
}

#
# Execute xdd commands locally
#
function local_exec() {
    local cmds="$1"
    bash <<EOF
$cmds
EOF
    
    # If the transfer failed, trigger appropriate error
    local rc=$?
    if [ 0 -ne "$rc" ]; then
        error_exit "$rc"
    fi
}

#
# Execute xdd commands on remote host
#
function remote_exec() {
    #echo "remote_exec Args: $@" >/dev/stderr
    local cmds="$1"
    local remoteHost="$2"
    local remoteUser="$3"

    # Construct ssh options
    if [ ! -z "${remoteUser}" ]; then
        sshOpts="-l $remoteUser"
    fi

    # Local decl must be on seperate line so $? is correct
    local remoteOutput=""
    remoteOutput=$(ssh ${sshOpts} ${remoteHost} bash <<EOF
$cmds
EOF
        )
    local destRC=$?

    # Check the status of remote operations
    if [ 255 -eq $destRC ]; then
        echo "INFO: Remote output - $remoteOutput" >/dev/stderr
        error_exit $XDDCP_ERR_CODE_SSH_FAILURE
    elif [ 0 -ne $destRC -a ! -z "$remoteOutput" ]; then
        echo "INFO: Remote Error: $remoteOutput"
        error_print $destRC
        error_exit $XDDCP_ERR_CODE_SSH_ERROR
    elif [ 0 -ne $destRC ]; then
        echo "INFO: Remote operation failure, no cause detected"
        error_exit $XDDCP_ERR_CODE_SSH_ERROR
    fi
    echo "$remoteOutput"
}


#
# Check preconditions for the source side file
#
function check_source_file_preconditions() {

    # Arguments
    local sourceSideFilename=$1
    local fileSizeFlag=$2
    local transferSize=$3

    # Ensure source side file exists
    if [ ! -r "${sourceSideFilename}" ]; then
	echo "INFO: Cannot read ${sourceSideFilename}"
	error_exit $XDDCP_ERR_CODE_SRC_XST
    fi

    # Ensure file is large enough
    local sourceDir="$(dirname $sourceSideFilename)"
    if [ "$sourceDir" != "/dev" ]; then
        local trueSize=$(stat -c '%s' "$sourceSideFilename")
        if [ 16777216 -gt $trueSize ]; then
            error_exit $XDDCP_ERR_CODE_SMALL_FILE
        elif [ 1 -eq $fileSizeFlag -a $transferSize -gt $trueSize ]; then
            error_exit $XDDCP_ERR_CODE_XFER_SIZE
        fi
    fi
}

#
# Return the file size
#
function get_file_size() {
    #echo "get_file_size Args: $@" >/dev/stderr
    local filename=$1
    local remoteFlag=$2
    local host=$3
    local user=$4

    if [ 0 -eq "$remoteFlag" ]; then
        echo $(stat -c %s $filename)
    else
        cmd="stat -c %s $filename"
        $(remote_exec $cmd $host $user)
    fi
}

#
# Return the destination side program
#
function get_destination_cmds() {
    #echo "get_destination_cmds Args: $@" >/dev/stderr
    local destHost=${1}
    local srcFile=${2}
    local destFile=${3}
    local totalBytes=${4}
    local queueDepth=${5}
    local e2ePort=${6}
    local dioFlag=${7}
    local forceFlag=${8}
    local orderedFlag=${9}
    local resumeFlag=${10}
    local verboseFlag=${11}

    # Options that aren't yet settable
    local srcHost=$(hostname)
    
    # Construct transfer settings
    let "xfer      = ${XDDCP_DEFAULT_XFER_SIZE}"
    let "numreqs   = $totalBytes / $xfer"
    let "blocksize = 1024"
    let "reqsize   = $xfer / $blocksize"

    # Other variables
    local e2eLB=$e2ePort
    local e2eUB=$((e2ePort + queueDepth))
    local srcBase=$(basename $srcFile)
    local destBase=$(basename $destFile)
    local destDirname=$(dirname $destFile)
    local destLog="xdd.${destHost}.${destBase}.${XDDCP_DEFAULT_TIMESTAMP}.log"
    local destQD="-queuedepth ${queueDepth}"

    # Direct I/O option
    if [ 1 -eq $dioFlag ]; then
        local destDIO="-dio"
    fi

    # Strict ordering option
    if [ 1 -eq $orderedFlag ]; then
        local orderedOpt="-strictordering"
    fi

    # Verbose option
    if [ 1 -eq $verboseFlag ]; then
        local verboseOpt="-ts detailed -ts output e2e"
    fi
    
    cat <<EOF
# Ensure xdd is in the remote path
\$(hash ${XDDCP_DEFAULT_XDD}) >/dev/null
if [ 0 -ne \$? ]; then
    echo "xdd.Linux is not in destination host PATH" >/dev/stderr
    exit ${XDDCP_ERR_CODE_XDD_NOT_FOUND}
fi

# Check that the correct version of XDD is available
dest_version=\$(${XDDCP_DEFAULT_XDD} -version)
if [ "\$dest_version" != "$g_xddcpXddVersion" ]; then
    echo "XDD source and destionation version mismatch." >/dev/stderr
    exit ${XDDCP_ERR_CODE_VERSION_MATCH}
fi

# Check that ports are available for binding
port_conflict=0
used_ports=\$(netstat -nat |cut -d : -f 2 |cut -d ' ' -f 1 |tr -d [:alpha:])
for p in \$used_ports; do
    if [ $e2eLB -le \$p -a $e2eUB -gt \$p ]; then
        port_conflict=1
        break
    fi
done

# If a port conflict, user may want to kill running XDD's and retry
if [ 1 -eq \$port_conflict ]; then
    # Attempt to kill any running XDDs and re-check
    if [ 1 -eq $forceFlag ]; then
        xddpid=\$(ps -u \${USER} |grep xdd |grep -v grep |grep -v xddcp |cut -c-5)
        if [ ! -z "\$xddpid" ]; then
            kill \$xddpid 2>/dev/null
            sleep 1
            kill -9 \$xddpid 2>/dev/null
            sleep 1
        fi
    else
        echo "Requested port \$p is in use"
        exit ${XDDCP_ERR_CODE_DEST_PORT}
    fi
    used_ports=\$(netstat -nat |cut -d : -f 2 |cut -d ' ' -f 1 |tr -d [:alpha:])
    for p in \$used_ports; do
        if [ $e2eLB -le \$p -a $e2eUB -gt \$p ]; then
            echo "Requested port \$p is in use" >/dev/stderr
            exit ${XDDCP_ERR_CODE_DEST_PORT}
        fi
    done
fi

# If the filename uses a relative path, path complement it
path_char=\$(dirname $destFile |cut -c 1)
if [ "." == \$path_char ]; then
    default_dir=\$(pwd)
    destination_dir="\${default_dir}/${destDirname}"
    destination_file="\${default_dir}/${destFile}"
    destination_log="\${default_dir}/${destLog}"
else
    destination_dir="${destDirname}"
    destination_file="${destFile}"
    destination_log="\${destination_dir}/${destLog}"
fi

# Ensure destination is writable
if [ ! -d \$destination_dir ]; then
    echo "Destination directory does not exist: \$destination_dir" >/dev/stderr
    exit ${XDDCP_ERR_CODE_DEST_XST}
elif [ -d \$destination_dir -a ! -e \$destination_file -a ! -w \$destination_dir ]; then
    echo "Destination directory is not writable: \$destination_dir" >/dev/stderr
    exit ${XDDCP_ERR_CODE_DEST_XST}
elif [ -e \$destination_file -a ! -w \$destination_file ]; then
    echo "Destination target exists but is not writable: \$destination_file" >/dev/stderr
    exit ${XDDCP_ERR_CODE_DEST_XST}
fi

# Perform restart if necessary
if [ 1 == $resumeFlag ]; then
    # Ensure sufficient permissions exist to create restart cookie
    if [ ! -w \$destination_dir ]; then
        echo "Restart option requires write access to: \$destination_dir" >/dev/stderr
        exit ${XDDCP_ERR_CODE_DEST_XST}
    fi

    # Create the name for a new restart cookie
    restart_logfile="\${destination_dir}/xdd.${srcHost}.${srcBase}.${destHost}.${destBase}.${XDDCP_DEFAULT_TIMESTAMP}.rst"

    # Check for the existence a restart cookie
    most_recent_restart_cookie=\$(ls \${destination_dir}/xdd.${srcHost}.${srcBase}.${destHost}.${destBase}.*.rst 2>/dev/null |tail -1)
    echo "Using restart cookie: \$most_recent_restart_cookie"
    if [ -z "\$most_recent_restart_cookie" ]; then
       destination_restart="-restart file \${restart_logfile} -restart enable"
    else
       destination_restart="-restart file \${restart_logfile} -restart enable \$(cat \$most_recent_restart_cookie)"
    fi
fi

# If insufficient permissions for the log exist, direct to HOME
if [ ! -w \$destination_dir -a -e \$destination_log -a ! -w \$destination_log ]; then
    echo "Logfile already exists and is not writable: \$destination_log" >/dev/stderr
    exit ${XDDCP_ERR_CODE_DEST_XST}
elif [ ! -w \$destination_dir -a ! -w \$destination_log ]; then
    home_dir_log="./${destination_log}"
    if [ ! -w "./" ]; then
        echo "Could not create log file as \$destination_log or as \$home_dir_log" >/dev/stderr
        exit ${XDDCP_ERR_CODE_DEST_XST}
    fi
    echo "Warning: Writing log to: \$home_dir_log" >/dev/stderr
    destination_log=\$home_dir_log
fi

# Truncate the destination to the correct size if necessary
if [ -e \$destination_file ]; then
    cur_size=\$(stat -c '%s' \${destination_file})
    if [ \$cur_size -gt $totalBytes ]; then
        truncate -s $totalBytes \${destination_file}
    fi
fi

${XDDCP_DEFAULT_XDD} -target \${destination_file} -op write -minall ${orderedOpt} ${verboseOpt} -bytes ${totalBytes} -reqsize $reqsize ${destQD} -e2e isdestination -e2e dest ${destHost} -e2e port ${e2ePort} ${destDIO} \${destination_restart} -preallocate ${totalBytes} -verbose > \${destination_log} 2>&1 &

# Send the restart offset back to the source side via an exit code
if [ 1 -eq $resumeFlag ]; then
    echo "XDDCP RESTART TOKENS: \${destination_restart}"
else
    echo "XDD started without restart capability"
fi
EOF
}

#
# Return the source side program
#
function get_source_cmds() {
    #echo "get_source_cmds Args: $@" >/dev/stderr
    local destHost=${1}
    local srcFile=${2}
    local totalBytes=${3}
    local queueDepth=${4}
    local e2ePort=${5}
    local srcDIOFlag=${6}
    local orderedFlag=${7}
    local resumeFlag=${8}
    local verboseFlag=${9}
    local resumeOffset=${10}

    # Construct XDD transfer settings
    let "xfer      = ${XDDCP_DEFAULT_XFER_SIZE}"
    let "numReqs   = ${totalBytes} / $xfer"
    let "blockSize = 1024"
    let "reqSize   = $xfer / $blockSize"

    # Validate restart flag if necessary
    srcRestart=""
    if [ 1 == $resumeFlag ]; then
        if [ "enable" == "$resumeOffset" ]; then
            srcRestart="-restart enable"
        elif [ 0 -le "$resumeOffset" ]; then
            echo "INFO: Resuming XDD file transfer at offset: $resumeOffset" >/dev/stderr
            srcRestart="-restart enable -restart offset $resumeOffset"
        else
            error_exit $XDDCP_ERR_CODE_INV_RESTART
        fi
    fi

    # Construct source XDD settings
    local srcBase=$(basename ${srcFile})
    local srcQD="-queuedepth ${queueDepth}"
    local srcLog="xdd.$(hostname).${srcBase}.${XDDCP_DEFAULT_TIMESTAMP}.log"

    # Direct I/O option
    if [ 1 -eq $srcDIOFlag ]; then
        local srcDIO="-dio"
    fi

    # Strict ordering option
    if [ 1 -eq $orderedFlag ]; then
        local orderedOpt="-strictordering"
    fi

    # Verbose option
    if [ 1 -eq $verboseFlag ]; then
        local verboseOpt="-ts detailed -ts output e2e"
    fi
    
    # Determine if output can be sent to log file
    local srcOutput="-output ${srcLog}"
    if [ ! -w "./" ]; then
        echo "WARNING:  Cannot create log file: ./$srcLog, logging output to stdout" >/dev/stderr
        sourceOutput=""
    fi

    # Build the command string
    cat <<EOF
# Ensure xdd is in the path
\$(hash ${XDDCP_DEFAULT_XDD}) >/dev/null
if [ 0 -ne \$? ]; then
    echo "xdd.Linux is not in the source host PATH"
    exit ${XDDCP_ERR_CODE_XDD_NOT_FOUND}
fi

# Check that the correct version of XDD is available
source_version=\$(${XDDCP_DEFAULT_XDD} -version)
if [ "\$source_version" != "$g_xddcpXddVersion" ]; then
    echo "XDD source and destionation version mismatch."
    exit ${XDDCP_ERR_CODE_VERSION_MATCH}
fi

# Ensure source side file exists
if [ ! -r "${srcFile}" ]; then
    echo "ERROR: Cannot read source file: ${srcFile}"
    exit ${XDDCP_ERR_CODE_SRC_XST}
fi

# Construct local transport endpoint
${XDDCP_DEFAULT_XDD} -targets 1  ${srcFile} -op read -minall ${orderedOpt} ${verboseOpt} -bytes ${totalBytes} -reqsize ${reqSize} ${srcQD} -e2e issource -e2e dest ${destHost} -e2e port ${e2ePort} ${srcDIO} ${srcRestart} ${srcOutput} -hb ${XDDCP_DEFAULT_HEARTBEAT_SECS} -hb pct

src_xdd_rc=\$?
if [ \${src_xdd_rc} -ne 0 ]; then
    exit ${XDDCP_ERR_CODE_XFER_FAIL}
fi
EOF
}

function start_destination_xdd() {
    #echo "start_destination_xdd Args: $@" >/dev/stderr
    local srcPath=${1}
    local destPath=${2}
    local totalBytes=${3}
    local queueDepth=${4}
    local e2ePort=${5}
    local dioFlag=${6}
    local forceFlag=${7}
    local orderedFlag=${8}
    local recursionFlag=${9}
    local resumeFlag=${10}
    local verboseFlag=${11}
    local remoteFlag=${12}
    local destHost=${13}
    local destUser=${14}

    # Get source commands and execute
    destResult=""
    destCmds=$(get_destination_cmds $destHost $srcPath $destPath \
        $totalBytes $queueDepth $e2ePort $dioFlag $forceFlag $orderedFlag \
        $recursionFlag $resumeFlag $verboseFlag)
    if [ 1 -eq ${remoteFlag} ]; then
        destResult=$(remote_exec "${destCmds}" "${destHost}" "${destUser}")
    else
        destResult=$(local_exec "${destCmds}")
    fi

    # Extract the resume offset from the remote output
    #echo "Output was: $destResult"
    local rc=1
    if [ 1 == $resumeFlag ]; then
        g_xddcpResumeOffset=$(echo $destResult |rev |cut -d ' ' -f 1 |rev)
        if [ -z "$g_xddcpResumeOffset" ]; then
            error_exit $XDDCP_ERR_CODE_INV_RESTART
        fi
    fi    
    return 0
}

function start_source_xdd() {
    #echo "start_source_xdd Args: $@" >/dev/stderr
    local path=${1}
    local totalBytes=${2}
    local queueDepth=${3}
    local e2ePort=${4}
    local dioFlag=${5}
    local orderedFlag=${6}
    local resumeFlag=${7}
    local verboseFlag=${8}
    local resumeOffset=${9}
    local destHost=${10}
    local remoteFlag=${11}
    local srcHost=${12}
    local srcUser=${13}

    # Get source commands and execute
    local rc=1
    srcCmds=$(get_source_cmds $destHost $path $totalBytes $queueDepth \
        $e2ePort $dioFlag $orderedFlag $resumeFlag $verboseFlag $resumeOffset)
    if [ 1 -eq ${remoteFlag} ]; then
        remote_exec "${srcCmds}" "${srcHost}" "${srcUser}"
        rc=$?
    else
        local_exec "${srcCmds}"
        rc=$?
    fi

    return $rc
}

#
# XDDCP Main
#
function xddcp_main() {
    #echo "main Args: $@"
    #
    # Install necessary signal handlers
    #
    # Note: We still need to pass the signal thru for Posix compliance.  See
    #  http://www.cons.org/cracauer/sigint.html
    #
    trap 'handle_signal_common 2; trap 2; kill -2 $$' 2 
    trap 'handle_signal_common 3; trap 3; kill -3 $$' 3 
    trap 'handle_signal_common 15; trap 15; kill -15 $$' 15
    trap exit

    # Print a helpful message if user is just typing command to get syntax
    if [ "$1" == "-h" ]; then
        print_usage
        return 0
    elif [ $# -lt 2 ]; then
        echo "usage: $0 [OPTION] /full_path/source_file destination_host:/full_path/destination_file [bytes_to_transfer]"
        echo "Try '$0 -h' for more information."
        return $XDDCP_ERR_CODE_INVALID_ARGS
    fi

    # Parse options
    destDIOFlag=0
    e2ePort=$XDDCP_DEFAULT_E2E_PORT
    fileListFlag=0
    forceFlag=0
    orderedFlag=0
    queueDepth=$XDDCP_DEFAULT_QUEUE_DEPTH
    recursiveFlag=0
    resumeFlag=0
    srcDIOFlag=0
    sshOption=$XDDCP_DEFAULT_SSH_PSEUDO_TERMINAL_OPT
    verboseFlag=0

    while getopts ":FYadfhp:orst:v" option; do
        case $option in
            F) 
                fileListFlag=1
                ;;
            Y) 
                sshOption="-tt"
                ;;
            a) 
                resumeFlag=1
                ;;
	    d) 
                destDIOFlag=1
                ;;
	    f) 
                forceFlag=1
                ;;
	    h) 
                print_usage 
                return 0
                ;;
            o) 
                orderedFlag=1
                ;;
            p) 
                e2ePort=$OPTARG
                ;;
	    r) 
                recursiveFlag=1
                echo "INFO: Unsupported option: -$OPTARG" >/dev/stderr 
                error_exit $XDDCP_ERR_CODE_INVALID_ARGS
                ;;
	    s) 
                srcDIOFlag=1
                ;;
	    t) 
                queueDepth=$OPTARG
                ;;
	    v) 
                verboseFlag=1
                ;;
            \?)
                echo "INFO: Unsupported option: -$OPTARG" >/dev/stderr 
                error_exit $XDDCP_ERR_CODE_INVALID_ARGS
                ;;
        esac
    done
    shift $((OPTIND-1))

    # Handle a set of input files
    srcFileSpecList="${1}"

    # Parse the destination endpoint spec
    destRemoteFlag=0
    parse_endpoint_spec "${2}" destRemoteFlag destUser destHost destPath

    # Get the specified size if it is defined
    fileSizeFlag=0
    totalBytes=0
    if [ ! -z "${3}" ]; then
        fileSizeFlag=1
        totalBytes=${3}
    fi

    # Ensure local option preconditions are met
    check_host_preconditions ${srcFileSpecList} ${fileListFlag} \
        ${fileSizeFlag} ${resumeFlag}

    # If using the file list, get all of the source specs
    if [ 1 -eq $fileListFlag ]; then
        srcFileSpecList=$(cat ${srcFileSpecList})
    fi

    # Process all source file specs
    for srcFileSpec in ${srcFileSpecList}; do

        # Parse the source side spec
        srcRemoteFlag=0
        parse_endpoint_spec ${srcFileSpec} srcRemoteFlag srcUser srcHost srcPath

        # Ensure at least one of the sides is remote
        if [ 0 -eq ${destRemoteFlag} -a 0 -eq ${srcRemoteFlag} ]; then
            error_exit $XDDCP_ERR_CODE_NO_REMOTE
        fi

        # Determine the source file size
        if [ 0 -eq $fileSizeFlag ]; then
            totalBytes=$(get_file_size ${srcPath} \
                ${srcRemoteFlag} ${srcHost} ${srcUser})
        fi

        # Ensure the source file is large enough
        if [ "$XDDCP_DEFAULT_XFER_SIZE" -gt "$totalBytes" ]; then
            echo "INFO: $srcPath file size is $totalBytes bytes" >/dev/stderr
            error_exit $XDDCP_ERR_CODE_SMALL_FILE
        fi

        # Start destination-side XDD (also sets resume offset if needed)
        start_destination_xdd "${srcPath}" "${destPath}" "${totalBytes}" \
            "${queueDepth}" "${e2ePort}" "${destDIOFlag}" "${forceFlag}" \
            "${orderedFlag}" "${recursiveFlag}" "${resumeFlag}" \
            "${verboseFlag}" "${destRemoteFlag}" "${destHost}" "${destUser}"
        rc=$?
        if [ 0 -ne $rc ]; then
           error_exit $rc
        fi
 
        # Wait to ensure the destination side has setup network and accepting
        sleep $XDDCP_DEFAULT_NETWORK_SLEEP_SECS

        # Start source-side XDD
        start_source_xdd "${srcPath}" "${totalBytes}" \
            "${queueDepth}" "${e2ePort}" "${srcDIOFlag}" \
            "${orderedFlag}" "${resumeFlag}" "${verboseFlag}" \
            "${g_xddcpResumeOffset}" "${destHost}" \
            "${srcRemoteFlag}" "${srcHost}" "${srcUser}"
        rc=$?
        if [ 0 -ne $rc ]; then
            error_exit $rc
        fi

        echo ""
        echo "Transfer complete.  Verify results with md5sum."
    done
    return 0
}

#
# Execute xddcp
#
xddcp_main "$@"
exit $?
