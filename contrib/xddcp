#!/bin/bash
#
# This program is free software; you can redistribute it and/or modify 
# it under the terms of the GNU General Public License as published by 
# the Free Software Foundation; either version 2 of the License, or 
# (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful, but 
# WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY 
# or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License 
# for more details.
# 
# You should have received a copy of the GNU General Public License along 
# with this program; if not, write to the Free Software Foundation, Inc., 
# 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
#
#
# This file is part of XDD
#
# Copyright (C) 2010, Brad Settlemyer
#
# Description:  This script enables the use of XDD as a remote data movement
# engine.  Its functionality loosely mimics the capabilities of scp and bbcp,
# however, with hopefully much improved performance.
#
# Notes: XDDCP has been tested on AIX and Linux environments.  
#
# The following POSIX utilities are required to utilize XDDCP:
#    basename
#    cat
#    cut
#    date
#    echo
#    egrep
#    grep
#    hostname
#    kill
#    ps
#    uname
#
# The following utilities are provided by the XDD distribution
#    xdd-getfilesize
#    xdd-gethostip
#    xdd-truncate
#    xdd
#
# These utilities are provided by the Linux tracong package
#    iotrace_init
#    decode
#
# The following utilities (non-POSIX) are required to utilize XDDCP:
#    dirname
#    mkfifo
#    pkill
#    ssh
#    stat
#    tr
#
# The following utilities are optionally used by XDDCP:
#    netstat 
#


# XDD Configurable global settings
readonly XDDCP_DEFAULT_E2E_PORT=40010
readonly XDDCP_DEFAULT_XFER_SIZE=33554432
readonly XDDCP_DEFAULT_QUEUE_DEPTH=8
readonly XDDCP_DEFAULT_SSH_PSEUDO_TERMINAL_OPT="-T"
readonly XDDCP_DEFAULT_HEARTBEAT_SECS=4
readonly XDDCP_DEFAULT_TIMESTAMP="$(\date -u +'%Y-%m-%d-%H%M%S')-GMT"
readonly XDDCP_DEFAULT_NETWORK_SLEEP_SECS=4
readonly XDDCP_DEFAULT_RETRY_SLEEP_SECS=4
readonly XDDCP_DEFAULT_NETWORK_CLEAR_SECS=2
readonly XDDCP_DEFAULT_FIFO_PATH="/tmp/xddcp-$USER.$$"
readonly XDDCP_NUMA_NODE_WILDCARD="all"

# XDD package executables
readonly XDDCP_XDD_EXE="xdd"
readonly XDDCP_GETHOSTIP_EXE="xdd-gethostip"
readonly XDDCP_TRUNCATE_EXE="xdd-truncate"
readonly XDDCP_GETFILESIZE_EXE="xdd-getfilesize"
readonly XDDCP_READTSDUMPS_EXE="xdd-read-tsdumps"
readonly XDDCP_PLOTTSDUMPS_EXE="xdd-plot-tsdumps"
readonly XDDCP_PLOTTSDUMPSDK_EXE="xdd-plot-tsdumps-dk"
readonly XDDCP_IOTRACE_EXE="iotrace_init"
readonly XDDCP_IOTRACE_DECODE_EXE="decode"

# XDDCP Error Codes
readonly XDDCP_ERR_CODE_INVALID_ARGS=101
readonly XDDCP_ERR_CODE_INVALID_FORMAT=102
readonly XDDCP_ERR_CODE_XDD_NOT_FOUND=103
readonly XDDCP_ERR_CODE_QIP_NOT_FOUND=104
readonly XDDCP_ERR_CODE_INV_FLAGS=105
readonly XDDCP_ERR_CODE_SRC_XST=106
readonly XDDCP_ERR_CODE_INV_RST=107
readonly XDDCP_ERR_CODE_SSH_ERROR=108
readonly XDDCP_ERR_CODE_SSH_FAILURE=109
readonly XDDCP_ERR_CODE_SMALL_FILE=110
readonly XDDCP_ERR_CODE_XFER_SIZE=111
readonly XDDCP_ERR_CODE_VERSION_MATCH=112
readonly XDDCP_ERR_CODE_NO_REMOTE=113
readonly XDDCP_ERR_CODE_XFER_FAIL=114
readonly XDDCP_ERR_CODE_DEST_PORT=115
readonly XDDCP_ERR_CODE_SRC_DEV_DIRECT_IO=116
readonly XDDCP_ERR_CODE_DEST_DEV_DIRECT_IO=117
readonly XDDCP_ERR_CODE_DEST_DEV_FILE_SIZE=118
readonly XDDCP_ERR_CODE_DEST_DIR_NOT_XST=119
readonly XDDCP_ERR_CODE_DEST_DIR_NOT_WR=120
readonly XDDCP_ERR_CODE_DEST_TGT_NOT_WR=121
readonly XDDCP_ERR_CODE_DEST_IP=122
readonly XDDCP_ERR_CODE_GETHOSTIP_NOT_FOUND=123
readonly XDDCP_ERR_CODE_FIFO_ACCESS=124
readonly XDDCP_ERR_CODE_FIFO_FAILED=125
readonly XDDCP_ERR_CODE_MISSING_KERNEL_TRACE_COMPONENT=126
readonly XDDCP_ERR_CODE_INV_RESTART=127

# XDDCP Restart Token String
readonly XDDCP_RESTART_DELIM="XDD_RESTART: "

# XDDCP file name bases to use for temporary files
readonly XDDCP_RECURSIVE_LIST_FILE_NAME=".xdd_file_list-$$.xdl"
readonly XDDCP_LIST_PROGRESS_FILE_NAME=".xdd_progress.xdp"

# Output device used to stream informational messages 
readonly XDDCP_DEV_NULL=/dev/stderr
#readonly XDDCP_DEV_NULL=/dev/null

#
# Global variables
#
# The version string emitted by the source-side XDD
g_xddcpXddVersion="-1"

# The path to use for the XDD FIFO (deprecated)
g_xddcpFifoPath=""

# The process ID of the destination-side SSH invocation
g_xddcpDestSSHPid="-1"

# The process ID of the source-side XDD invocation
g_xddcpSrcXddPid="-1"

# The filename used to store the offset of any pending transfers
g_xddcpPartialFileName=""

# The filename used to store the files completed during a multi-file transfer
g_xddcpProgressFileName=""

# The current resume offset
g_xddcpResumeOffset="0"

# The number of completed transfers
g_xddcpTransferCount="0"

# Path to add to execute remote XDD
g_xddcpRemotePathAppend=""

#
# Global variables that need to be analyzed for proper usage
#
readonly g_filebaseTransferRst=".xdd_transfer"
readonly g_filebaseRecusiveList=".xdd_recursive_file_list"
g_srcFilePath=""
g_srcFileMtime="0"
g_srcFileOffset="0"
g_currentFileIndex="0"
g_RestartFileDir=""
g_currentTransferRst=""
g_completeTransfersRst=""
g_srcRestartOpt=""
g_dstRestartOpt=""
g_xddcpRecursiveTransferError="0"
g_fileRecursiveList=""

#
# Print out the usage information
#
function print_usage {
    echo "xddcp [OPTIONS] source_file destination_host[%numa][,destination_host[%numa]]:destination_file [size]"
    echo ""
    echo "source_file       - complete /filepath/name for source file on source host"
    echo "destination_host  - 1 or more destination host IP(s) or Name(s) over which data is transferred"
    echo "numa              - NUMA node on which to bind the threads for that source and destination host"
    echo "destination_file  - complete /filepath/name for destination file on destination host"
    echo "size              - number of bytes to transfer [Default: size of source file]"
    echo ""
    echo "OPTIONS: "
    echo " -a		- Resume transfer if it was only partially completed and the -a flag was specified"
    echo " -b           - path containing remote XDD binaries"
    echo " -c		- If ports are unavailable on destination, indicate error rather than trying to force transfer"
    echo " -d s|d|b	- Use direct I/O the end specified (s for source, d for dest, b for both)"
    echo " -f		- Attempt to kill any running XDD process at destination before spawning XDD for this transfer"
    echo " -F		- Transfer a list of files named in source_file"
    echo " -h		- Print out usage information"
    echo " -l           - local path containing remote XDD binaries"
    echo " -n		- If operation fails for any reason, retry up to n times [Default: 3]"
    echo " -p portnum	- First port to use for transfer [Default: $XDDCP_DEFAULT_E2E_PORT]" 
    echo " -o s|d|b	- Perform file I/O in serial order on end specified (s for source, d for dest, b for both)"
    echo " -r		- Copy sub-directories and contents recursively"
    echo " -t threads	- Use 'threads' number of threads during transfer [Default: $XDDCP_DEFAULT_QUEUE_DEPTH]"
    echo " -v		- Turn on logging"
    echo " -V		- Add timestamping output to logs"
    echo " -w sec	- Add post-analysis: plot bandwidth over time with sliding window of 'sec' seconds. (sec >= 1)"
    echo " -W sec	- Add post-analysis: -w option with kernel tracing. (sec >= 1)"
    echo "NOTE: 'xdd' must be in your PATH env on both source and destination hosts!!!"
    echo "       otherwise you must specifiy the '-b' and/or the '-l' options"

}

#
# Reset global state before retry
#
function reset_global_data {
    g_xddcpDestSSHPid="-1"
    g_xddcpSrcXddPid="-1"
    g_xddcpRecursiveTransferError="0"
    g_srcRestartOpt=""
    g_dstRestartOpt=""
    unset g_fileResumeDataArray
}

#
# Print out an appropriate error message and exit
#
function error_exit {
    local errorCode=$1

    # Exit the program with the error code
    error_print $errorCode
    exit $errorCode

    # Used to print the call stack which can be useful for debugging
    echo "Call stack: $FUNCNAME"
    for ((i=0; i < ${#FUNCNAME[*]}; i=$i+1)); do
	echo "INFO: Call Stack ${FUNCNAME[$i]}"
    done
    exit $errorCode
}

#
# Print out an appropriate error message
#
function error_print {
    local errorCode=$1
    case $errorCode in
        $XDDCP_ERR_CODE_INVALID_ARGS) 
            echo "ERROR: Invalid command arguments" >/dev/stderr
            ;;
        $XDDCP_ERR_CODE_INVALID_FORMAT) 
            echo "ERROR: Invalid source/destination format" >/dev/stderr
            ;;
        $XDDCP_ERR_CODE_XDD_NOT_FOUND) 
            echo "ERROR: ${XDDCP_XDD_EXE} executable not found" >/dev/stderr
            ;;
        $XDDCP_ERR_CODE_QIP_NOT_FOUND) 
            echo "ERROR: qipcrm executable not found" >/dev/stderr
            ;;
        $XDDCP_ERR_CODE_INV_FLAGS) 
            echo "ERROR: Incompatible command line arguments" >/dev/stderr
            ;;
        $XDDCP_ERR_CODE_SRC_XST) 
            echo "ERROR: Cannot locate source file" >/dev/stderr
            ;;
        $XDDCP_ERR_CODE_INV_RST) 
            echo "ERROR: Invalid restart offset location" >/dev/stderr
            ;;
        $XDDCP_ERR_CODE_SSH_FAILURE) 
            echo "ERROR: Failure spawing process via SSH" >/dev/stderr
            ;;
        $XDDCP_ERR_CODE_SSH_ERROR) 
            echo "ERROR: Remote session failure" >/dev/stderr
            ;;
        $XDDCP_ERR_CODE_SMALL_FILE) 
            echo "ERROR: Cannot transfer files smaller than $XDDCP_DEFAULT_XFER_SIZE bytes" >/dev/stderr
            ;;
        $XDDCP_ERR_CODE_XFER_SIZE) 
            echo "ERROR: Requested transfer size is larger than file size" >/dev/stderr
            ;;
        $XDDCP_ERR_CODE_VERSION_MATCH) 
            echo "ERROR: ${XDDCP_XDD_EXE} versions differ on source and destination" >/dev/stderr
            ;;
        $XDDCP_ERR_CODE_NO_REMOTE) 
            echo "ERROR: Local file transfers are not permitted" >/dev/stderr
            ;;
        $XDDCP_ERR_CODE_XFER_FAIL) 
            echo "ERROR: File transfer failed." >/dev/stderr
            echo "  If the reason is \"Connection refused\", check the destination logfile." >/dev/stderr
            ;;
        $XDDCP_ERR_CODE_DEST_PORT) 
            echo "ERROR: Destination port is in use" >/dev/stderr
            ;;
        $XDDCP_ERR_CODE_DEST_DEV_DIRECT_IO)
            echo "ERROR: Destination is a character device, direct I/O is not allowed." >/dev/stderr
            ;;
        $XDDCP_ERR_CODE_SRC_DEV_DIRECT_IO)
            echo "ERROR: Source is a character device, direct I/O is not allowed." >/dev/stderr
            ;;
        $XDDCP_ERR_CODE_SRC_DEV_FILE_SIZE)
            echo "ERROR: Source is a character device, transfer size must be provided." >/dev/stderr
            ;;
	$XDDCP_ERR_CODE_DEST_DIR_NOT_XST)
	    echo "ERROR: Destination directory does not exist." >/dev/stderr
	    ;;
        $XDDCP_ERR_CODE_DEST_DIR_NOT_WR)
	    echo "ERROR: Destination directory is not writable." >/dev/stderr
	    ;;
        $XDDCP_ERR_CODE_DEST_TGT_NOT_WR)
	    echo "ERROR: Destination target is not writable." >/dev/stderr
	    ;;
        $XDDCP_ERR_CODE_DEST_IP)
	    echo "ERROR: Could not resolve destination IP address." >/dev/stderr
	    ;;
        $XDDCP_ERR_CODE_GETHOSTIP_NOT_FOUND)
	    echo "ERROR: Could not find xdd-gethostip program." >/dev/stderr
	    ;;
        $XDDCP_ERR_CODE_FIFO_ACCESS)
	    echo "ERROR: Invalid permissions to access FIFO." >/dev/stderr
	    ;;
        $XDDCP_ERR_CODE_FIFO_FAILED)
	    echo "ERROR: Could not create FIFO." >/dev/stderr
	    ;;
        $XDDCP_ERR_CODE_INV_RESTART)
	    echo "ERROR: Could not restart correctly." >/dev/stderr
	    ;;
        \?) 
            echo "ERROR: Unknown error code" >/dev/stderr
            ;;
    esac
}

#
# Handle trapped signals
#
function handle_signal_common {
    local signum=$1

    # Attempt to deliver the signal to source-side XDD
    if [ -1 -ne $g_xddcpSrcXddPid ]; then
        kill -$signum $g_xddcpSrcXddPid &>$XDDCP_DEV_NULL
	sleep 1
    fi

    # Attempt to destroy any open SSH sessions
    if [ -1 -ne $g_xddcpDestSSHPid ]; then
	kill $g_xddcpDestSSHPid &>$XDDCP_DEV_NULL
    fi

    # Remove the FIFO if it still exists
    if [ -e "$g_xddcpFifoPath" ]; then
	rm -f $g_xddcpFifoPath &>$XDDCP_DEV_NULL
    fi

    echo "INFO:  Transfer cancelled by user." >/dev/stderr
}

#
# Parse endpoint spec of the form [[user@]host:]path
#
# Call with spec and variable names as arguments, e.g.:
#
# spec="user@foo.bar.com:/home/user"
# srcRemoteFlag=0
# srcUser=""
# srcHost=""
# srcPath=""
# parse_endpoint_spec $spec srcRemoteFlag srcUser srcHostArray srcIPArray  srcPath
#
function parse_endpoint_spec {
    local spec=$1
    local pathRef="$2"
    local remoteFlagRef="$3"
    local userRef="$4"
    local hostArrayRef="$5"
    local addrArrayRef="$6"
    local nodeArrayRef="$7"
    
    # Construct default values for the outbound variables
    local tmpPath=""
    local tmpRemoteFlag=0
    local tmpUser=""
    local tmpHostArray=()
    local tmpAddrArray=()
    local tmpNodeArray=()

    # Determine if the spec describes a remote path
    local colonCount=$((`echo $spec|sed 's/[^:]//g'|wc -m`-1))
    if [ $colonCount -eq 0 ]; then
        # Set the path reference to the spec
        tmpPath=$spec
    else
        # Set the remote flag
        tmpRemoteFlag=1

        # Copy the spec for modification
        local modSpec=$spec

        # Set the path and remove from mod spec
        tmpPath=$(echo $modSpec |awk -F: '{print $2}')
        modSpec=$(echo $modSpec |awk -F: '{print $1}')

        # Set the username if exists and remove from mod spec
        local amp_count=$(\echo $modSpec |grep -c "@")
        if [ 1 -eq $amp_count ]; then
            tmpUser=$(echo $modSpec |awk -F@ '{print $1}')
            modSpec=$(echo $modSpec |awk -F@ '{print $2}')
        fi

        # Get the hosts and nodes
        local numHosts=$((`echo $modSpec|sed 's/[^,]//g'|wc -m`))
        for (( i=0; i < $numHosts; i++ )); do 

            # Select the comma delimited element
            local hostSpec=$(echo $modSpec |awk -F, "{print \$$((i+1))}")

            # Set the host, addr, and node
            tmpHostArray[$i]=${hostSpec%%%*}
            tmpAddrArray[$i]=$($XDDCP_GETHOSTIP_EXE -d ${tmpHostArray[$i]})
            tmpNodeArray[$i]=$(echo $hostSpec |awk -F% '{print $2}')

            # If no node is set, set a wildcard to avoid a sparse array
            if [ -z ${tmpNodeArray[$i]} ]; then
                tmpNodeArray[$i]="$XDDCP_NUMA_NODE_WILDCARD"
            fi
        done
    fi

    # Set the outbound variables
    eval "$pathRef=$tmpPath"
    eval "$remoteFlagRef=$tmpRemoteFlag"
    eval "$userRef=$tmpUser"
    eval "$hostArrayRef=( ${tmpHostArray[@]} )"
    eval "$addrArrayRef=( ${tmpAddrArray[@]} )"
    eval "$nodeArrayRef=( ${tmpNodeArray[@]} )"
}

#
# Check preconditions for the host
#
# Sideffects: Sets the global XDDCP version identifier
#
function check_host_preconditions {

    # Arguments
    local sourceSideFilename=${1}
    local fileListFlag=${2}
    local fileSizeFlag=${3}
    local recursiveFlag=${4}
    local resumeFlag=${5}
    local forceFlag=${6}

    # Set the XDD version information
    g_xddcpXddVersion=$(${XDDCP_XDD_EXE} -version)

    # Check for gethostip binary
    \type $XDDCP_GETHOSTIP_EXE &>$XDDCP_DEV_NULL
    if [ 0 -ne $? ]; then
        error_exit $XDDCP_ERR_CODE_GETHOSTIP_NOT_FOUND
    fi

    # Ensure flag combinations are valid
    if [ 1 -eq $fileListFlag -a 1 -eq $fileSizeFlag ]; then
        echo "INFO: -F option does not take an argument" >/dev/stderr
        error_exit $XDDCP_ERR_CODE_INV_FLAGS
    elif [ 1 -eq $fileListFlag -a 1 -eq $recursiveFlag ]; then
        echo "INFO: -F and -r flags cannot both be specified" >/dev/stderr
        error_exit $XDDCP_ERR_CODE_INV_FLAGS
    elif [ 1 -eq $recursiveFlag -a 1 -eq $fileSizeFlag ]; then
        echo "INFO: -r option does not take an argument" >/dev/stderr
        error_exit $XDDCP_ERR_CODE_INV_FLAGS
    fi

    # Restarts require write permission to the current directory
    if [ 1 -eq $resumeFlag -a ! -w $PWD ]; then
        echo "INFO: Resume/restart flag requires write permission to current directory." >/dev/stderr
        error_exit $XDDCP_ERR_CODE_INV_FLAGS
    fi
}

#
# Check preconditions for the file list transfer
#
function check_file_list_preconditions {

    # Arguments
    local sourceSideFilename=${1}
    local fileListFlag=${2}
    local fileSizeFlag=${3}
    local resumeFlag=${4}

    # Ensure source side file list filename exists and is readable
    if [ 1 -eq $fileListFlag -a ! -r "${sourceSideFilename}" ]; then
	echo "INFO: Cannot read ${sourceSideFilename}" >/dev/stderr
	error_exit $XDDCP_ERR_CODE_SRC_XST
    fi
}

#
# Check preconditions for the transfer
#
function check_transfer_preconditions {
    # Arguments
    local sourceSideFilename=${1}
    local destSidePathname=${2}
    local srcRemoteFlag=${3}
    local destRemoteFlag=${4}
    local srcDIOFlag=${5}
    local destDIOFlag=${6}
    local fileSizeFlag=${7}

    # Ensure at least one of the sides is remote
    if [ 0 -eq ${destRemoteFlag} -a 0 -eq ${srcRemoteFlag} ]; then
        error_exit $XDDCP_ERR_CODE_NO_REMOTE
    fi

    # Ensure source side file exists
    if [ ! -r "${sourceSideFilename}" ]; then
	echo "INFO: Cannot read ${sourceSideFilename}"
	error_exit $XDDCP_ERR_CODE_SRC_XST
    fi

    # Check if file is a character special device (like zero or null)
    local sfType=$(file -b ${sourceSideFilename} 2>$XDDCP_DEV_NULL)
    local dfType=$(file -b %F ${destSidePathname} 2>$XDDCP_DEV_NULL)

    # Ensure file is large enough
    if [ "$sfType" != "character special" ]; then
        local trueSize="$($XDDCP_GETFILESIZE_EXE $sourceSideFilename | cut -f 1 -d " ")"
        if [ $XDDCP_DEFAULT_XFER_SIZE -gt $trueSize ]; then
            error_exit $XDDCP_ERR_CODE_SMALL_FILE
        fi
    elif [ "$sfType" = "character special" ]; then
	if [ 0 -eq "$fileSizeFlag" ]; then
	    error_exit $XDDCP_ERR_CODE_SRC_DEV_FILE_SIZE
	fi
    fi

    # Ensure devices and Direct I/O are not combined
    if [ "$sfType" = "character special file" -a 0 -ne "${srcDIOFlag}" ]; then
        error_exit $XDDCP_ERR_CODE_SRC_DEV_DIRECT_IO
    elif [ "$dfType" = "character special file" -a 0 -ne "${destDIOFlag}" ]; then
        error_exit $XDDCP_ERR_CODE_DEST_DEV_DIRECT_IO
    fi
    return 0
}

#
# Fetches the binary ts dump, calculates running bandwidth
#    during the transfer, and plots the xfer if gnuplot is available.
#
function post_transfer_analysis {
	local srcPath=${1}
	local srcHost=$(\hostname -s)
	local srcUser=${3}
	local destPath=${4}
	local destHost=${5}
	local destIP=${6}
	local destUser=${7}
	local windowSize=${8}
	local kernelTrace=${9}

	# where the timestamp dumps should be right now
	local srcBase=$(\basename $srcPath)
	local dstBase=$(\basename $destPath)
        # If the supplied destination is a directory, append the source file name
        if [ -d $destPath ]; then
          dstBase=$srcBase
        fi
	local srcBinDump="xdd-$(\hostname)-${srcBase}-${XDDCP_DEFAULT_TIMESTAMP}.target.0000.bin"
	local dstBinDump="xdd-${destHost}-${dstBase}-${XDDCP_DEFAULT_TIMESTAMP}.target.0000.bin"
	local dstCsvFile="xdd-${destHost}-${dstBase}-${XDDCP_DEFAULT_TIMESTAMP}.target.0000.csv"
	local dstLogFile="xdd-${destHost}-${dstBase}-${XDDCP_DEFAULT_TIMESTAMP}.log"

	# where our data will be stored afterwards
	local dataPrefix="xdd-${srcHost}_to_${destHost}_${srcBase}_${XDDCP_DEFAULT_TIMESTAMP}"
	local dataDir="."
 	local myLogFile="${dataDir}/ANALYSIS_${dataPrefix}.log"
 	local tsPlotPrefix="${dataDir}/ANALYSIS_${dataPrefix}"

	echo "Running post transfer analysis... "

	# check dataDir for writability
	if [ ! -d ${dataDir} ] || [ ! -w ${dataDir} ]; then
		echo "INFO: Can not write to ${dataDir}.  Skipping analysis." >/dev/stderr
		return 1
	fi

	# print a helpful tidbit to the logfile
	echo "To change the sliding window size without rerunning the transfer, run:" >> ${myLogFile}
	echo "    $XDDCP_READTSDUMPS_EXE -t [window_size] -o plot_prefix src_${srcHost}.bin dest_${destHost}.bin" >> ${myLogFile}
	echo "    gnuplot plotit" >> ${myLogFile}
	echo "" >> ${myLogFile}

	# get/copy destination bin file from destination to source host
	local destRC=""
	if [ ! -z "${destUser}" ]; then
		sshOpts="-q -l $remoteUser"
	fi
	(ssh ${sshOpts} ${destIP} /bin/bash --login <<EOF
# If the supplied destination is a directory, append the source file name
destination_file=${destPath}
destination_dir=\$(\\dirname ${destPath})
if [ -d ${destPath} ]; then
	destination_file=${destPath}/${srcBase}
	destination_dir=${destPath}
fi
# If the filename uses a relative path, path complement it
path_char=\$(\\dirname \$destination_file |cut -c 1)
if [ "." = \$path_char ]; then
	destination_dir="\$(/bin/pwd)/\${destination_dir}"
fi
# If insufficient permissions for the log exist, direct to HOME
if [ ! -w \$destination_dir ]; then
	destination_dir="./"
fi
# send the file back through cpio
cd \${destination_dir}
ls ${dstBinDump} | /bin/cpio -o 2>/dev/null
EOF
) | /bin/cpio -i >> ${myLogFile} 2>&1
	destRC=$?

	# get/copy destination log file from destination to source host
        (ssh ${sshOpts} ${destIP} /bin/bash --login <<EOF
# Really after destination log file which should be here by all previous checks
# If the supplied destination is a directory, append the source file name
destination_file=${destPath}
destination_dir=\$(\\dirname ${destPath})
if [ -d ${destPath} ]; then
        destination_file=${destPath}/${srcBase}
        destination_dir=${destPath}
fi
# If the filename uses a relative path, path complement it
path_char=\$(\\dirname \$destination_file |cut -c 1)
if [ "." = \$path_char ]; then
        destination_dir="\$(/bin/pwd)/\${destination_dir}"
fi
# If insufficient permissions for the log exist, direct to HOME
if [ ! -w \$destination_dir ]; then
        destination_dir="./"
fi
# send the file back through cpio
cd \${destination_dir}
ls ${dstLogFile} | /bin/cpio -o 2>/dev/null
EOF
) | /bin/cpio -i >> ${myLogFile} 2>&1

        # get/copy destination timestamp csv file from destination to source host
        (ssh ${sshOpts} ${destIP} /bin/bash --login <<EOF
# Really after destination log file which should be here by all previous checks
# If the supplied destination is a directory, append the source file name
destination_file=${destPath}
destination_dir=\$(\\dirname ${destPath})
if [ -d ${destPath} ]; then
        destination_file=${destPath}/${srcBase}
        destination_dir=${destPath}
fi
# If the filename uses a relative path, path complement it
path_char=\$(\\dirname \$destination_file |cut -c 1)
if [ "." = \$path_char ]; then
        destination_dir="\$(/bin/pwd)/\${destination_dir}"
fi
# If insufficient permissions for the log exist, direct to HOME
if [ ! -w \$destination_dir ]; then
        destination_dir="./"
fi
# send the file back through cpio
cd \${destination_dir}
ls ${dstCsvFile} | /bin/cpio -o 2>/dev/null
EOF
) | /bin/cpio -i >> ${myLogFile} 2>&1

	# get/copy destination iotrace_data.out file from destination to source host
	if [ 1 -eq $kernelTrace ]; then
        (ssh ${sshOpts} ${destIP} /bin/bash --login <<EOF
# Really after destination log file which should be here by all previous checks
# If the supplied destination is a directory, append the source file name
destination_file=${destPath}
destination_dir=\$(\\dirname ${destPath})
if [ -d ${destPath} ]; then
        destination_file=${destPath}/${srcBase}
        destination_dir=${destPath}
fi
# If the filename uses a relative path, path complement it
path_char=\$(\\dirname \$destination_file |cut -c 1)
if [ "." = \$path_char ]; then
        destination_dir="\$(/bin/pwd)/\${destination_dir}"
fi
# If insufficient permissions for the log exist, direct to HOME
if [ ! -w \$destination_dir ]; then
        destination_dir="./"
fi
# send the file back through cpio
cd \${destination_dir}
ls iotrace_data*out | /bin/cpio -o 2>/dev/null
EOF
) | /bin/cpio -i >> ${myLogFile} 2>&1
fi
	destRC=$?
	if [ 0 -ne $destRC ]; then
		echo "INFO: Failed to copy iotrace_data.pid.out over ssh.  Skipping analysis" >/dev/stderr
		return 1
	fi

	# read the tsdumps and plot output
	if [ 1 -eq $kernelTrace ]; then
        # Set iotrace log files location
          export TRACE_LOG_LOC=\${PWD}
	  $XDDCP_READTSDUMPS_EXE -t ${windowSize} -k -o ${tsPlotPrefix} ${srcBinDump} ${dstBinDump} >> ${myLogFile} 2>&1
	else
	  $XDDCP_READTSDUMPS_EXE -t ${windowSize}    -o ${tsPlotPrefix} ${srcBinDump} ${dstBinDump} >> ${myLogFile} 2>&1
	fi
	if [ 0 -ne $? ]; then
		echo "INFO: Failed to read timestamp dumps with prefix ${dataPrefix} in ${dataDir}.  Skipping analysis" >/dev/stderr
		return 1
	fi

	echo "done"
}

#
# Execute xdd commands locally
#
function local_exec {
    local cmds="$1"
    /bin/bash --login <<EOF
$cmds
EOF
    
##    ) > /dev/null 2>&1
     
    # If the transfer failed, trigger appropriate error
    local rc=$?
    return $rc
}

#
# Execute xdd commands on remote host
#
function remote_exec {
    #echo "remote_exec Args: $@" >/dev/stderr
    local cmds="$1"
    local remoteHost="$2"
    local remoteUser="$3"
    local errorCheck="$4"

    # Construct ssh options
    sshOpts="-q -o ServerAliveInterval=30"
    if [ ! -z "${remoteUser}" ]; then
        sshOpts="$sshOpts -l $remoteUser"
    fi

    # Local decl must be on seperate line so $? is correct
    local destRC=""
    local remoteOutput=""
    #remoteOutput=$(ssh ${sshOpts} ${remoteHost} /bin/bash --login <<EOF
   if [ 2 -ne "${errorCheck}" ]; then
       (ssh ${sshOpts} ${remoteHost} /bin/bash --login <<EOF
$cmds
EOF
       ) > $XDDCP_DEV_NULL 2>&1
   else
       (ssh ${sshOpts} ${remoteHost} /bin/bash --login <<EOF
$cmds
EOF
       )
   fi
   destRC=$?

   remoteOutput="$(echo "ssh ${sshOpts} ${remoteHost} /bin/bash --login ${cmds}")"
   if [ 0 -ne "${errorCheck}" ]; then
       # Check the status of remote operations
       if [ 255 -eq $destRC ]; then
           echo "INFO: Remote output - $remoteOutput" >/dev/stderr
           error_exit $XDDCP_ERR_CODE_SSH_FAILURE
       elif [ 0 -ne $destRC -a ! -z "$remoteOutput" ]; then
           echo "INFO: Remote RC: $destRC Remote Error: $remoteOutput" >/dev/stderr
           error_print $destRC
           error_exit $XDDCP_ERR_CODE_SSH_ERROR
       elif [ 0 -ne $destRC ]; then
           echo "INFO: Remote operation failure, no cause detected" >/dev/stderr
           error_exit $XDDCP_ERR_CODE_SSH_ERROR
       fi
   fi
}

#
# Perform a remote execution using a FIFO to capture stdout
#
function remote_exec_with_fifo {
    #echo "remote_exec Args: $@" >/dev/stderr
    local cmds="$1"
    local fifoPath="$2"
    local remoteHost="$3"
    local remoteUser="$4"

    # If a fifo exists, remove it
    if [ -e "$fifoPath" ]; then
	\rm -f $fifoPath
	rc=$?
	if [ 0 -ne $rc ]; then
	    echo "INFO: Unable to remove existing FIFO: $fifoPath"
	    error_exit $XDDCP_ERR_CODE_FIFO_ACCESS
	fi
    fi

    # Create a new fifo
    \mkfifo $fifoPath &>$XDDCP_DEV_NULL
    rc=$?
    if [ 0 -ne $rc ]; then
	echo "INFO: Unable to create FIFO: $fifoPath"
	error_exit $XDDCP_ERR_CODE_FIFO_FAILED
    fi
    
    # Construct ssh options
    sshOpts="-q -o ServerAliveInterval=30"
    if [ ! -z "${remoteUser}" ]; then
        sshOpts="$sshOpts -l $remoteUser"
    fi

    # Local decl must be on seperate line so $? is correct
    (ssh ${sshOpts} ${remoteHost} /bin/bash --login <<EOF
$cmds
wait
EOF
    ) > $fifoPath &
    rc=$?

    # Modify the global state
    g_xddcpDestSSHPid=$!
    g_xddcpFifoPath=$fifoPath
    return $rc
}

#
# Return the file size
#
function get_file_size {
    #echo "get_file_size Args: $@" >/dev/stderr
    local filename=$1
    local remoteFlag=$2
    local host=$3
    local user=$4

    if [ 0 -eq "$remoteFlag" ]; then
        echo $($XDDCP_GETFILESIZE_EXE $filename)
    else
        cmd="$XDDCP_GETFILESIZE_EXE $filename"
        remote_exec "$cmd" "$host" "$user" "1"
    fi
}

#
# Return the destination side program
#
function get_destination_cmds {
    #echo "get_destination_cmds Args: $@" >/dev/stderr
    local destHostArray=(${1})
    local destIPArray=(${2})
    local destNodeArray=(${3})
    local destThreads=${4}
    local srcFile=${5}
    local destPath=${6}
    local totalBytes=${7}
    local e2ePort=${8}
    local dioFlag=${9}
    local forceFlag=${10}
    local serialOrderedFlag=${11}
    local resumeFlag=${12}
    local verbosity=${13}
    local binaryDumpFlag=${14}

    # Options that aren't yet settable
    local srcHost=$(\hostname)
    
    # Construct transfer settings
    declare -i xfer=${XDDCP_DEFAULT_XFER_SIZE}
    declare -i numreqs=$((totalBytes/xfer))
    declare -i blocksize=1024
    declare -i reqsize=$((xfer/blocksize))

    # Other variables
    local srcBase=$(\basename $srcFile)

    # Construct the e2e destinations
    local e2eDestinations=""
    local destCount=${#destHostArray[@]}
    local i=0
    for ((i = 0; i < destCount; i++)); do
        local ip=${destIPArray[$i]}
        local tcount=${destThreads}
        local port=$((e2ePort + i * tcount))
        local node=${destNodeArray[$i]}
        if [ -z "$node" -o "$XDDCP_NUMA_NODE_WILDCARD" = "$node" ]; then
	    e2eDestinations="$e2eDestinations -e2e dest ${ip}:${port},${tcount}" 
        else
	    e2eDestinations="$e2eDestinations -e2e dest ${ip}:${port},${tcount},${node}" 
        fi
    done    
    if [ -z "$e2eDestinations" ]; then
	\echo "ERROR: No destination interfaces specified"
	error_exit $XDDCP_ERR_CODE_NO_REMOTE
    fi

    # Direct I/O option
    if [ 1 -eq $dioFlag ]; then
        local destDIO="-dio"
    fi

    # Thread ordering option
    local orderedOpt="-noordering"
    if [ 1 -eq $serialOrderedFlag ]; then
        orderedOpt="-serialordering"
    fi

    # Verbose option
    if [ 1 -eq $verbosity ]; then
        local verboseOpt="-verbose"
    fi

    # If the supplied destination is a directory, append the source file name
    local destination_base=$(\basename $destPath)
    if [ -d $destPath ]; then
          destination_base=$srcBase
    fi

    # binary timestamp dump
    if [ 1 -eq $binaryDumpFlag -o 2 -eq $verbosity ]; then
        local binaryDumpPrefix="xdd-${destHostArray[0]}-${destination_base}-${XDDCP_DEFAULT_TIMESTAMP}"
    fi

    # if restart, get srcFile mod time
    srcFileMtime=0
    #if [ 1 -eq $resumeFlag ]; then
    #    local srcFileMtime=$(stat -c %Y $srcFile 2>$XDDCP_DEV_NULL)
    #fi
    
    cat <<EOF
# Ensure xdd is in the remote path
if [ "x${g_xddRemotePathAppend}" != "x" ] ; then
  export PATH=\${PATH}:${g_xddRemotePathAppend}
fi
\type ${XDDCP_XDD_EXE} &>/dev/null
if [ 0 -ne \$? ]; then
    echo "xdd binary is not in destination host PATH" >/dev/stderr
    exit ${XDDCP_ERR_CODE_XDD_NOT_FOUND}
fi

# Check that the correct version of XDD is available
dest_version=\$(${XDDCP_XDD_EXE} -version)
if [ "\$dest_version" != "$g_xddcpXddVersion" ]; then
    echo "XDD source and destionation version mismatch." >/dev/stderr
    exit ${XDDCP_ERR_CODE_VERSION_MATCH}
fi

# Path complement xdd so that iotracing can function
xdd_exe_path=\$(\\type -P ${XDDCP_XDD_EXE})

# Check that ports are available for binding (Linux only)
declare -i port_conflict=0
if [ "$(\uname)" = "Linux" ]; then
    \type $XDDCP_GETHOSTIP_EXE &>/dev/null
    hasIpTranslator=\$?
    if [ 1 -ne \$hasIpTranslator ]; then
        declare -i tcount_idx=0
        for iface in $destIfaces; do
            tcount_idx=\$((tcount+1))
                tcount=\$(\\echo $destIfaceThreads |cut -f \$tcount_idx -d ' ')
            iface_ip=\$($XDDCP_GETHOSTIP_EXE -d \$iface)
            e2eLB=$e2ePort
            e2eUB=\$((e2eLB+tcount))
#        echo "\$tcount_idx \$iface_ip \$e2eLB \$e2eUB" >>/tmp/bws
#        echo "netstat -nlt |grep \$iface_ip |cut -d : -f 2 |cut -d ' ' -f 1 |tr -d [:alpha:])" >>/tmp/bws
            used_ports=\$(\\netstat -nlt |grep \$iface_ip |cut -d : -f 2 |cut -d ' ' -f 1 |tr -d [:alpha:])
#        echo "Used ports: \$used_ports" >>/tmp/bws
            for p in \$used_ports; do
                if [ \$e2eLB -le \$p -a \$e2eUB -gt \$p ]; then
                    port_conflict=1
                    break
                fi
            done
        done
    fi
    # Use of force requested, so kill anything xdd that exists at destination.
    if [ 1 -eq $forceFlag ]; then
         pkill -9 -u ${USER} -U ${USER} -x xdd 2>/dev/null
         sleep $XDDCP_DEFAULT_NETWORK_CLEAR_SECS
    fi

    # If a port conflict exists, user may want to kill running XDD's and retry
    if [ 1 -eq \$port_conflict ]; then
        # Attempt to kill any running XDDs and re-check
        if [ 1 -eq $forceFlag ]; then
            xddpid=\$(\\ps -u \${USER} |grep xdd |grep -v grep |grep -v xddcp |cut -c-5)
            if [ ! -z "\$xddpid" ]; then
                kill \$xddpid 2>/dev/null
                sleep $XDDCP_DEFAULT_NETWORK_CLEAR_SECS
                kill -9 \$xddpid 2>/dev/null
                sleep $XDDCP_DEFAULT_NETWORK_CLEAR_SECS
            fi
        else
            echo "Requested port \$p is in use" >/dev/stderr
            exit ${XDDCP_ERR_CODE_DEST_PORT}
        fi

        tcount_idx=0
        for iface in $destIfaces; do
            tcount_idx+=1
            tcount=\$(\\echo $destIfaceThreads |cut -f \$tcount_idx -d ' ')
            e2eLB=$e2ePort
            e2eUB=\$((e2eLB+tcount))
            used_ports=\$(\\netstat -nlt |grep $iface |cut -d : -f 2 |cut -d ' ' -f 1 |tr -d [:alpha:])
            for p in \$used_ports; do
                if [ \$e2eLB -le \$p -a \$e2eUB -gt \$p ]; then
                    echo "Requested port \$p is in use" >/dev/stderr
                    exit ${XDDCP_ERR_CODE_DEST_PORT}
                fi
            done
        done
    fi
fi

# If the supplied destination is a directory, append the source file name
destination_file=$destPath
destination_base=\$(\\basename $destPath)
destination_dir=\$(\\dirname $destPath)
if [ -d $destPath ]; then
    destination_file=$destPath/$srcBase
    destination_base=$srcBase
    destination_dir=$destPath
fi

# If the filename uses a relative path, path complement it
path_char=\$(\\dirname \$destination_file |cut -c 1)
if [ "." = \$path_char ]; then
    default_dir=\$(\\pwd)
    destination_dir="\${default_dir}/\${destination_dir}"
    destination_file="\${default_dir}/\${destination_file}"
fi

# Create the log file name
destination_log_base="xdd-${destHostArray[0]}-\${destination_base}-${XDDCP_DEFAULT_TIMESTAMP}.log"
destination_log="\${destination_dir}/\${destination_log_base}"

# Ensure destination is writable
if [ ! -d \$destination_dir ]; then
    echo "Destination directory does not exist: \${destination_dir}" >/dev/stderr
    exit ${XDDCP_ERR_CODE_DEST_DIR_NOT_XST} 
elif [ -d \$destination_dir -a ! -e \$destination_file -a ! -w \$destination_dir ]; then
    echo "Destination directory is not writable: \$destination_dir"
    exit ${XDDCP_ERR_CODE_DEST_DIR_NOT_WR}
elif [ -e \$destination_file -a ! -w \$destination_file ]; then
    echo "Destination target exists but is not writable: \$destination_file" >/dev/stderr
    exit ${XDDCP_ERR_CODE_DEST_TGT_NOT_WR}
fi

# Perform restart if necessary
destination_restart=""
if [ 1 -eq $resumeFlag ]; then
    # Ensure sufficient permissions exist to create restart cookie
    if [ ! -w \$destination_dir ]; then
        echo "Restart option requires write access to: \$destination_dir" >/dev/stderr
        exit ${XDDCP_ERR_CODE_DEST_DIR_NOT_WR}
    fi

    # Add restart filename (cookie) to restart command
    restart_logfile="\${destination_dir}/.\${destination_base}.xrt"
    destination_restart="-restart file \${restart_logfile} ${g_dstRestartOpt}"


fi

# If insufficient permissions for the log exist, direct to HOME
if [ $verbosity -lt 1 ]; then
    destination_log=/dev/null
elif [ ! -w \$destination_dir -a -e \$destination_log -a ! -w \$destination_log ]; then
    echo "Logfile already exists and is not writable: \$destination_log" >/dev/stderr
    exit ${XDDCP_ERR_CODE_DEST_TGT_NOT_WR}
elif [ ! -w \$destination_dir -a ! -w \$destination_log ]; then
    home_dir_log="./\${destination_log_base}"
    if [ ! -w "./" ]; then
        echo "Could not create log file as \$destination_log or as \$home_dir_log"
        exit ${XDDCP_ERR_CODE_DEST_TGT_NOT_WR}
    fi
    echo "Warning: Writing log to: \$home_dir_log"
    destination_log=\$home_dir_log
fi
# Verbose option
  if [ 1 -eq $verbosity ]; then
        verboseopt="-verbose"
elif [ 2 -eq $verbosity ]; then
        verboseopt="-verbose -ts detailed -ts output \$(\\dirname \${destination_log})/$binaryDumpPrefix"
fi
if [ 1 -eq $binaryDumpFlag ]; then
	binary_dump_opts="-ts dump \$(\\dirname \${destination_log})/$binaryDumpPrefix"
fi

# Truncate the destination to the correct size if necessary
if [ -e \$destination_file ]; then
    cur_size=\$($XDDCP_GETFILESIZE_EXE \${destination_file} | cut -f 1 -d " ")
    if [ \$cur_size -gt $totalBytes ]; then
        $XDDCP_TRUNCATE_EXE -s $totalBytes \${destination_file}
    fi
fi

# XDD Command
#xdd_cmd="\${xdd_exe_path} -target \${destination_file} -op write -minall ${orderedOpt} \${verboseopt} \${binary_dump_opts} -bytes ${totalBytes} -reqsize $reqsize -e2e isdestination ${e2eDestinations} ${destDIO} \${destination_restart} -preallocate ${totalBytes} -stoponerror -output \${destination_log} -errout \${destination_log}"
xdd_cmd="\${xdd_exe_path} -target \${destination_file} -op write -minall ${orderedOpt} \${verboseopt} \${binary_dump_opts} -bytes ${totalBytes} -reqsize $reqsize -e2e isdestination ${e2eDestinations} ${destDIO} \${destination_restart} -preallocate ${totalBytes} -stoponerror > \${destination_log}"

# Log XDD Command
echo "Destination-side invocation: \${xdd_cmd}" > \${destination_log}

# Set iotrace log files location
export TRACE_LOG_LOC=\${destination_dir}

# Write out the restart offset
restart_offset="\$(cat \${destination_log})"
echo "$XDDCP_RESTART_DELIM \${restart_offset}"

# Invoke XDD
\${xdd_cmd} >> \${destination_log} 2>&1 &
EOF
}

#
# Return the source side program
#
function get_source_cmds {
    #echo "get_source_cmds Args: $@" >/dev/stderr
    local destIPArray=(${1})
    local srcNodeArray=(${2})
    local srcFile=${3}
    local totalBytes=${4}
    local destThreadCount=${5}
    local e2ePort=${6}
    local srcDIOFlag=${7}
    local serialOrderedFlag=${8}
    local resumeFlag=${9}
    local verbosity=${10}
    local binaryDumpFlag=${11}

    # Construct XDD transfer settings
    xfer=${XDDCP_DEFAULT_XFER_SIZE}
    numReqs=$((totalBytes/xfer))
    blockSize=1024
    reqSize=$((xfer/blockSize))

    # Construct the e2e destinations
    local e2eDestinations=""
    local destCount=${#destIPArray[@]}
    local i=0
    for (( i = 0; i < $destCount; i++ )); do
        local ip=${destIPArray[$i]}
        local tcount=$destThreadCount
        local port=$((e2ePort + i * tcount))
        local node=${srcNodeArray[$i]}
        if [ "$XDDCP_NUMA_NODE_WILDCARD" != "$node" ]; then
	    e2eDestinations="$e2eDestinations -e2e dest ${ip}:${port},${tcount},${node}" 
        else
	    e2eDestinations="$e2eDestinations -e2e dest ${ip}:${port},${tcount}" 
        fi
    done
    if [ -z "$e2eDestinations" ]; then
	echo "ERROR: No destination interfaces specified"
	error_exit $XDDCP_ERR_CODE_NO_REMOTE
    fi

    # Construct source XDD settings
    local srcBase=$(\basename ${srcFile})
    local srcLog="xdd-$(\hostname)-${srcBase}-${XDDCP_DEFAULT_TIMESTAMP}.log"

    # Direct I/O option
    if [ 1 -eq $srcDIOFlag ]; then
        local srcDIO="-dio"
    fi

    # Thread ordering option
    local orderedOpt="-looseordering"
    if [ 1 -eq $serialOrderedFlag ]; then
        orderedOpt="-serialordering"
    fi

    # Verbose option
    if [ 1 -eq $verbosity ]; then
        local verboseOpt="-verbose"
    elif [ 2 -eq $verbosity ]; then
        local verboseOpt="-verbose -ts detailed -ts output xdd-$(\hostname)-${srcBase}-${XDDCP_DEFAULT_TIMESTAMP}"
    fi

    # binary timestamp dump option
    if [ 1 -eq $binaryDumpFlag ]; then
        local binaryDumpOpt="-ts dump xdd-$(\hostname)-${srcBase}-${XDDCP_DEFAULT_TIMESTAMP}"
    fi
    
    # Determine if output can be sent to log file
    local srcOutput="-output ${srcLog}"
    if [ ! -w "./" ]; then
        echo "WARNING:  Cannot create log file: ./$srcLog, logging output to stdout" >/dev/stderr
        sourceOutput=""
    fi

    # Build the command string
    cat <<EOF
# Ensure xdd is in the path
if [ "x${g_xddRemotePathAppend}" != "x" ] ; then
  export PATH=\${PATH}:${g_xddRemotePathAppend}
fi
\type ${XDDCP_XDD_EXE} &>/dev/null
if [ 0 -ne \$? ]; then
    echo "xdd binary is not in the source host PATH"
    exit ${XDDCP_ERR_CODE_XDD_NOT_FOUND}
fi

# Check that the correct version of XDD is available
source_version=\$(${XDDCP_XDD_EXE} -version)
if [ "\$source_version" != "$g_xddcpXddVersion" ]; then
    echo "XDD source and destionation version mismatch."
    exit ${XDDCP_ERR_CODE_VERSION_MATCH}
fi

# Path complement xdd so that iotracing can function
xdd_exe_path=\$(\\type -P ${XDDCP_XDD_EXE})

# Ensure source side file exists
if [ ! -r "${srcFile}" ]; then
    echo "ERROR: Cannot read source file: ${srcFile}"
    exit ${XDDCP_ERR_CODE_SRC_XST}
fi

# Add the command to the log file
if [ $verbosity -gt 0 ]; then
    src_log="xdd-\$(\hostname)-${srcBase}-${XDDCP_DEFAULT_TIMESTAMP}.log"
else
    src_log=/dev/null
fi

xdd_cmd="\${xdd_exe_path} -targets 1  ${srcFile} -op read -minall ${orderedOpt} ${verboseOpt} ${binaryDumpOpt} -bytes ${totalBytes} -reqsize ${reqSize} -e2e issource ${e2eDestinations} ${srcDIO} ${g_srcRestartOpt} -output \${src_log} -hb ${XDDCP_DEFAULT_HEARTBEAT_SECS} -hb pct -stoponerror"

# Set iotrace log files location
export TRACE_LOG_LOC=\${PWD}

# Construct local transport endpoint
echo "Source-side invocation: \${xdd_cmd}" > \${src_log}
\${xdd_cmd}

src_xdd_rc=\$?
if [ \${src_xdd_rc} -ne 0 ]; then
    exit ${XDDCP_ERR_CODE_XFER_FAIL}
fi
EOF
}

#
# Retrieve restart file from destination directory
#
function get_destination_restart_files {
    local srcPath=${1}
    local destPath=${2}
    local destHost=${3}
    local destIP=${4}
    local destUser=${5}

    local dataDir=$PWD
    # check dataDir for writability
    if [ ! -d ${dataDir} ] || [ ! -w ${dataDir} ]; then
	echo "INFO: Can not write to ${dataDir}. Skipping get_destination_restart_files." >/dev/stderr
	return 1
    fi
    local host=""
    if [ ! -z "${destIP}" ]; then
	host="${destIP}"
    elif [ ! -z "${destHost}" ]; then
	host="${destHost}"
    else
        echo "scripting error in get_destination_restart_files, fix it!" >/dev/stderr
    fi
    # Save top level destination directory for restart cookie files
    local dstpath="$destPath"
    local dfType=$(ssh $host \stat -c %F ${destPath} 2>/dev/null)
    if [ "$dfType" = "" -o "$dfType" = "regular file" -o "$dfType" = "regular empty file" ]; then
        dstpath=$(\dirname ${destPath})
    fi
    if [ -d "${srcPath}" ]; then
        srcbase=$(\basename ${srcPath})
        g_RestartFileDir="${dstpath}/${srcbase}"
    elif [ -f "${srcPath}" ]; then
        g_RestartFileDir="${dstpath}"
    else
        echo "INFO: Cannot determine g_RestartFileDir. Skipping get_destination_restart_files." >/dev/stderr
        return 1
    fi

    # get/copy destination restart file(s) from destination to source host
    (scp ${USER}@${host}:${g_RestartFileDir}/${g_filebaseTransferRst}\* ${PWD}) > /dev/null 2>&1
}

# If restart, get file transfer history from destination if it exists.
function get_file_transfer_history {
    local srcPath=${1}
    local destPath=${2}
    local destHost=${3}
    local destIP=${4}
    local destUser=${5}

    # If restart, read in table(s) of transfer completed and/or in progress
    let "g_currentFileIndex = -1"
    get_destination_restart_files "${srcPath}" "${destPath}" "${destHost}" "${destIP}" "${destUser}"
    local srcRestartFile="${PWD}/$g_completeTransfersRst"
    if [ -e "$srcRestartFile" -a -s "$srcRestartFile" ]; then
        if [ -s "$srcRestartFile" ]; then
            while read line
            do
                let "g_currentFileIndex += 1"
                g_srcFilePath[$g_currentFileIndex]=$(echo "$line" | cut -f 1 -d " ")
                g_srcFileMtime[$g_currentFileIndex]=$(echo "$line" | cut -f 2 -d " ")
                g_srcFileOffset[$g_currentFileIndex]=$(echo "$line" | cut -f 3 -d " ")
            done < ${srcRestartFile}
        #mv ${srcRestartFile} "${srcRestartFile}.${retries}"
            rm -f  ${srcRestartFile}
        fi
    fi

    # stick it at the end; restart because offset < file size
    # this is trapped accordingly in transfer_file
    local srcRestartFile="${PWD}/$g_currentTransferRst"
    if [ -e "$srcRestartFile" ]; then
        if [ -s "$srcRestartFile" ]; then
            let "g_currentFileIndex += 1"
            g_srcFilePath[$g_currentFileIndex]=$(\cat $srcRestartFile | cut -f 1 -d " ")
            g_srcFileMtime[$g_currentFileIndex]=$(\cat $srcRestartFile | cut -f 2 -d " ")
            g_srcFileOffset[$g_currentFileIndex]=$(\cat $srcRestartFile | cut -f 3 -d " ")
            
            # More surgical than the forceFlag option, which does not always seem to work
            # If dstKillpid no longer exist, no harm done.
            local dstKillpid=$(\cat $srcRestartFile | cut -f 5 -d " ")
            local cmd="\kill -9 ${dstKillpid}"
            remote_exec "${cmd}" "${destHost}" "${destUser}" "0"
        fi
          #mv ${srcRestartFile} "${srcRestartFile}.${retries}"
        rm -f  ${srcRestartFile}
    fi
    # Remove source side restart files. Always get fresh copies from destination.
    # Source will start with $g_currentFileIndex if not complete, or next file if complete
    # Completion with a file is needed if g_srcFileOffset < filesize. Determined in transfer_file

    return 0
} 

# Locate input file in g_srcFilePath list, check mod time and return index
# return index. If new file, add it to list and transfer
# prev assumes ordered list or tree traversal, speeds up find
function check_if_file_transferred_previously {
    local path=${1} 
    local found
    local n
    
    let "found = -1"
    for (( n=0; n <= g_currentFileIndex; n++ ))
    do 
        if [ "$path" != "${g_srcFilePath[$n]}" ]; then
            continue
        fi
        let "found = $n"
        break
    done
    # If new file, add to end of list and increment grand total
    # If new file transfer aborts, this becomes the new restart file
    if [ 0 -gt "$found" ]; then
        let "g_currentFileIndex += 1"
        g_srcFilePath[$g_currentFileIndex]=$path
        local cutline=$(stat -c "%Y %s" $path 2>/dev/null)
        #g_srcFileMtime[$g_currentFileIndex]=$(echo "$cutline" | cut -f 1 -d " ")
        g_srcFileMtime[$g_currentFileIndex]="0"
        g_srcFileOffset[$g_currentFileIndex]="0"
        let "found = $g_currentFileIndex"
    fi
    return "$found"
}

#
# Read the restart file from the destination into a global assoc. array
#
function read_file_resume_data {
    local srcPath=${1}
    local destPath=${2}
    local destHost=${3}
    local destUser=${4}

    # Retrieve the file resume data
    if [ ! -z ${destUser} ]; then
        spec="${destUser}@${destHost}"
    else
        spec="$destHost"
    fi

    # If srcPath is a 
    restartFileDir=$(\dirname ${destPath})/$(\basename $srcPath)
    echo "(scp ${spec}:${restartFileDir}/${g_filebaseTransferRst}\* ${PWD})"
    (scp ${spec}:${restartFileDir}/${g_filebaseTransferRst}\* ${PWD}) > /dev/null 2>&1
}

#
# Set the two global variables that control the restart/resume offsets
#
function set_resume_options {
    local srcPath=${1}
    local destPath=${2}
    local destHost=${3}
    local destUser=${4}
    
    # Make sure the resume data is current
    #if [ 0 -eq ${#g_fileResumeDataArray} ]; then
    #    read_file_resume_data "${srcPath}" "${destPath}" "${destHost}" \
    #        "${destUser}"
    #fi

    # Set the options based on the restart data
    #restartData=$(\grep "$srcPath" "${g_filebaseTransferRst}*")
    #if [ ! -z "$restartData" ]; then
    #    local offset=$(echo ${restartData} |cut -f 2 -d ' ')
    #    local mtime=$(echo ${restartData} |cut -f 1 -d ' ')
    #    g_srcRestartOpt="-restart enable -restart offset ${offset}"
    #    g_destRestartOpt="${g_srcRestartOpt} -e2e srcpath ${srcPath} ${mtime}"
    #fi
}

#
# Create a directory on the destination side
#
function create_destination_directory {
    local destPath=${1}
    local remoteFlag=${2}
    local destHost=${3}
    local destIP=${4}
    local destUser=${5}

    # Create destination commands
    local destCmds="mkdir -v -p $destPath"

    # Execute destination side directory creation
    local destResult=""
    local execRC=1
    if [ 1 -eq ${remoteFlag} ]; then
        # resolve remote host name/ip
        local host=""
        if [ ! -z "${destIP}" ]; then
                host="${destIP}"
        elif [ ! -z "${destHost}" ]; then
                host="${destHost}"
        else
          echo "scripting error in create_destination_directory, fix it!" >/dev/stderr
        fi
        destResult=$(remote_exec "${destCmds}" "${host}" "${destUser}" "1")
        execRC=$?
    else
        destResult=$(local_exec "${destCmds}")
        execRC=$?
    fi

    # Error handling
    if [ 0 -ne $execRC ]; then
        error_exit $execRC
    fi
    return 0
}

#
# Start XDD on the destination side.  Set g_xddcpResumeOffset as a side effect. 
#
function start_destination_xdd {
    #echo "start_destination_xdd Args: $@" >/dev/stderr
    local srcPath=${1}
    local destPath=${2}
    local totalBytes=${3}
    local queueDepth=${4}
    local e2ePort=${5}
    local dioFlag=${6}
    local forceFlag=${7}
    local orderedFlag=${8}
    local resumeFlag=${9}
    local verbosity=${10}
    local binaryDumpFlag=${11}
    local remoteFlag=${12}
    local destHostArray=(${13})
    local destIPArray=(${14})
    local destNodeArray=(${15})
    local destUser=${16}

    # Get destination commands
    local execRC=1
    local destResult=""
    local destCmds=$(get_destination_cmds "${destHostArray[*]}" \
        "${destIPArray[*]}" "${destNodeArray[*]}" \
        "$queueDepth" "$srcPath" "$destPath" \
        "$totalBytes" "$e2ePort" "$dioFlag" "$forceFlag" "$orderedFlag" \
        "$resumeFlag" "$verbosity" "$binaryDumpFlag")
    execRC=$?
    if [ 0 -ne $execRC ]; then
        error_exit $execRC
    fi

    # Execute destination side commands
    if [ 1 -eq ${remoteFlag} ]; then
        remote_exec_with_fifo "${destCmds}" "${XDDCP_DEFAULT_FIFO_PATH}" "${destIPArray[0]}" "${destUser}" "1"
        execRC=$?
    else
	error_exit $XDDCP_ERR_CODE_NO_REMOTE
    fi

    # Wait to ensure the destination side has setup network and accepting
    sleep $XDDCP_DEFAULT_NETWORK_SLEEP_SECS
    sleep $XDDCP_DEFAULT_NETWORK_SLEEP_SECS

    # The destination side pauses while blocking on FIFO IO,
    # read the IO to allow progress
    if [ 0 -eq $execRC ]; then
        while read line; do
            # Parse out the resume offset if needed
            if [ 1 -eq $resumeFlag ]; then
                restartLine=$(\echo $line |grep $XDDCP_RESTART_DELIM)
                if [ ! -z "$restartLine" ]; then
                    g_xddcpResumeOffset=$(/bin/echo $restartLine |rev |cut -d ' ' -f 1 |rev)

	            # If the restart value is non-numeric, just set it to 0
		    echo "$g_xddcpResumeOffset" |egrep "^[0-9]+$" &>/dev/null
		    if [ 0 -ne $? ]; then
		        g_xddcpResumeOffset=0
		    fi
                    break
                fi
            else
                break
            fi
        done < ${g_xddcpFifoPath}
    fi

    return $execRC
}

#
# Start XDD on the source side
#
function start_source_xdd {
    #echo "start_source_xdd Args: $@" >/dev/stderr
    local path=${1}
    local totalBytes=${2}
    local queueDepth=${3}
    local e2ePort=${4}
    local dioFlag=${5}
    local orderedFlag=${6}
    local resumeFlag=${7}
    local verbosity=${8}
    local binaryDumpFlag=${9}
    local destIPArray=(${10})
    local srcNodeArray=(${11})
    local remoteFlag=${12}
    local srcHost=${13}
    local srcUser=${14}

    # Get source commands
    local execRC=1
    srcCmds=$(get_source_cmds "${destIPArray[*]}" "${srcNodeArray[*]}" \
        "${path}" "${totalBytes}" "${queueDepth}" "${e2ePort}" "${dioFlag}" \
        "${orderedFlag}" "${resumeFlag}" "${verbosity}" "${binaryDumpFlag}" )
    execRC=$?
    if [ 0 -ne $execRC ]; then
        error_exit $execRC
    fi

    # Execute source commands
    if [ 1 -eq ${remoteFlag} ]; then
        remote_exec "${srcCmds}" "${srcHost}" "${srcUser}" "2"
        execRC=$?
    else
        local_exec "${srcCmds}"
        execRC=$?
    fi

    return $execRC
}

#
# Perform transfer when the source spec is a file containing a list of files
#
function transfer_file_list {
    local srcFileList=${1}
    local srcHost=${2}
    local srcUser=${3}
    local srcRemoteFlag=${4}
    local srcDIOFlag=${5}
    local srcOrderedFlag=${6}
    local destPath=${7}
    local destHostArray=(${8})
    local destIPArray=(${9})
    local destNodeArray=(${10})
    local destUser=${11}
    local destRemoteFlag=${12}
    local destDIOFlag=${13}
    local destOrderedFlag=${14}
    local queueDepth=${15}
    local e2ePort=${16}
    local fileSizeFlag=${17}
    local forceFlag=${18}
    local resumeFlag=${19}
    local verbosity=${20}
    local binaryDumpFlag=${21}

    # Perform precondition checks for file list transfers
    check_file_list_preconditions "${srcFileList}" "1" "${fileSizeFlag}" \
	"${resumeFlag}"
    rc=$?
    if [ 0 -ne $rc ]; then
	error_exit $rc
    fi

    # Create destination directory for file list transfer for resumeFlag
    create_destination_directory "${destPath}" "${destRemoteFlag}" \
        "${destHostArray[0]}" "${destIPArray[0]}" "${destUser}"
    rc=$?
    if [ 0 -ne $rc ]; then
	echo "INFO: Failure while creating destination directory ${destPath}"
	error_exit $rc
    fi

    # Get all of the source specs and path complement
    local srcFileSpecDir=$(\dirname ${srcFileList})
    local fileNames=""
    for name in $(\cat ${srcFileList}); do
	local pathChar=$(\dirname $name |cut -c 1)
	if [ "." = "$pathChar" ]; then
	    fileNames="$fileNames ${srcFileSpecDir}/${name}"
	else
	    fileNames="$fileNames $name"
	fi
    done

    # Set the path modified file names as the source specs
    srcFileSpecList="$fileNames"

    # Process all source file specs
    local iters=0
    for srcFileSpec in ${srcFileSpecList}; do
	# Modify the destination path for file list transfers
	local srcFileName=$(\basename ${srcFileSpec})
	destFileSpec=${destPath}/${srcFileName}

        # Wait a few moments so that remote ports are free
        if [ 0 -ne $iters ]; then
            sleep $XDDCP_DEFAULT_NETWORK_CLEAR_SECS
            iters=1
        fi
	#Transfer the file
        srcRemoteFlag=0
	transfer_file "${srcFileSpec}" "${srcHost}" "${srcUser}" \
	    "${srcRemoteFlag}" "${srcDIOFlag}" "${srcOrderedFlag}" \
	    "${destFileSpec}" "${destHostArray[*]}" "${destIPArray[*]}" \
            "${destNodeArray[*]}" "${destUser}" "${destRemoteFlag}" \
            "${destDIOFlag}" "${destOrderedFlag}" "${totalBytes}" \
            "${queueDepth}" "${e2ePort}" "${fileSizeFlag}" "${forceFlag}" \
            "${resumeFlag}" "${verbosity}" "${binaryDumpFlag}"
	    
	rc=$?
	if [ 0 -ne $rc ]; then
	    echo "INFO: Failure while transferring ${srcFileSpec} to ${destFileSpec}"
            return $rc
	fi
    done
    return 0
}

#
# Perform transfer when the source spec is a file containing a list of 
# fully qualified paths of source/destination files
#
function transfer_recursive_file_list {
    #echo "transfer_recursive_file_list args: $@ >/dev/stderr
    local srcDir=${1}
    local srcHost=${2}
    local srcUser=${3}
    local srcRemoteFlag=${4}
    local srcDIOFlag=${5}
    local srcOrderedFlag=${6}
    local destPath=${7}
    local destHostArray=(${8})
    local destIPArray=(${9})
    local destNodeArray=(${10})
    local destUser=${11}
    local destRemoteFlag=${12}
    local destDIOFlag=${13}
    local destOrderedFlag=${14}
    local queueDepth=${15}
    local e2ePort=${16}
    local fileSizeFlag=${17}
    local forceFlag=${18}
    local resumeFlag=${19}
    local verbosity=${20}
    local binaryDumpFlag=${21}

    # Check recursive transfer preconditions

    # Create a file list in the working directory
    local fileList="${PWD}/${XDDCP_RECURSIVE_LIST_FILE_NAME}"

    # Create the remote directories

    # Use the regular file list transfer mechanism
    transfer_file_list "${fileList}" "${srcHost}" "${srcUser}" \
        "${srcRemoteFlag}" "${srcDIOFlag}" "${srcOrderedFlag}" \
        "${destPath}" "${destHostArray[*]}" "${destIPArray[*]}" \
        "${destNodeArray[*]}" "${destUser}" "${destRemoteFlag}" \
        "${destDIOFlag}" "${destOrderedFlag}" "${queueDepth}" \
        "${e2ePort}" "${fileSizeFlag}" "${forceFlag}" "${resumeFlag}" \
        "${verbosity}" "${binaryDumpFlag}" 
    local rc=$?

    # Clean up the file list
    \rm -f $fileList

    # Return the transfer code
    return $rc

    # Perform precondition checks for file list transfers
    check_file_list_preconditions "${srcFileList}" "1" "${fileSizeFlag}" \
	"${resumeFlag}"
    rc=$?
    if [ 0 -ne $rc ]; then
	error_exit $rc
    fi

            # Perform special processing for recursive transfers:
            #  Construct a filename for the list of files to recursive transfer
            #  Remove any file with that name (UNSAFE)
            #  Store the name in a global variable to to pass as argument to transfer
            g_fileRecursiveList="${PWD}/${g_filebaseRecusiveList}.$(\basename ${srcPath})"
            rm -f $g_fileRecursiveList
            transfer_recursive_path_setup "${srcPath}" "${destPath}" \
                "${destHostArray[0]}" "${destIPArray[0]}" "${destUser}" \
                "${destRemoteFlag}"
            rc=$?
	    if [ 0 -ne $rc ]; then
	        echo "INFO: Failure while creating .xdd_recursive_transfer_list "
	        error_exit $rc
	    fi

    # Parse the source side spec
    srcRemoteFlag=0

    let "FileIndex = -1"
    while read line
    do
        let "FileIndex += 1"
        srcFileName=$(echo "$line" | cut -f 1 -d " ")
        destFileName=$(echo "$line" | cut -f 2 -d " ")
        # Transfer the file
        transfer_file "${srcFileName}" "${srcHost}" "${srcUser}" \
	    "${srcRemoteFlag}" "${srcDIOFlag}" "${srcOrderedFlag}" \
	    "${destFileName}" "${destHostArray[*]}" "${destIPArray[*]}" \
            "${destNodeArray[*]}" "${destUser}" "${destRemoteFlag}" \
            "${destDIOFlag}" "${destOrderedFlag}" \
	    "${totalBytes}" "${queueDepth}" "${e2ePort}" \
	    "${fileSizeFlag}" "${forceFlag}" "${resumeFlag}" \
	    "${verbosity}" "${binaryDumpFlag}"
	rc=$?
	if [ 0 -ne $rc ]; then
	    echo "INFO: Failure while transferring ${srcFileName} to ${destFileName}"
            return $rc
	fi
    done < ${srcFileList}

    return 0
}

#
# Make file list from a recursive path for recursive transfer
# Create destination directories too
# Do it once. Otherwise restarts could get very expensive
#
function transfer_recursive_path_setup {
    local srcPath=${1}
    local destPath=${2}
    local destHost=${3}
    local destIP=${4}
    local destUser=${5}
    local destRemoteFlag=${6}

    # If the source is a directory, create it on the destination
    if [ -d "$srcPath" ]; then
	# Determine the corresponding destination name for the source name
	# Modify the destination path for file list transfers
	local srcName=$(\basename $srcPath)
	local destFileSpec=${destPath}/${srcName}
	create_destination_directory "${destFileSpec}" "${destRemoteFlag}" \
                                  "${destHost}" "${destIP}" "${destUser}"
	rc=$?
	if [ 0 -ne $rc ]; then
	    echo "INFO: Failure while creating directory ${destFileSpec}"
	    error_exit $rc
	fi
    fi

    # Get names from source spec, if its a directory, transfer its contents recursively
    # Otherwise, just transfer the file and end
    for entry in $(/bin/ls $srcPath); do
	local srcFileSpec=$srcPath/$entry
	local destFileSpec=$destPath/$(\basename $srcPath)
	if [ -d "$srcFileSpec" ]; then
	    transfer_recursive_path_setup "${srcFileSpec}" "${destFileSpec}" \
                "${destHost}" "${destIP}" "${destUser}" "${destRemoteFlag}" 
	else
	    echo "${srcFileSpec} ${destFileSpec}" >> "${g_fileRecursiveList}"
	fi
    done
    return  0
}

#
# Perform transfer for a single file
#
function transfer_file {
    #echo "transfer_file Args: $@" >/dev/stderr
    local srcFileSpec=${1}
    local srcHost=${2}
    local srcUser=${3}
    local srcRemoteFlag=${4}
    local srcDIOFlag=${5}
    local srcOrderedFlag=${6}
    local destFileSpec=${7}
    local destHostArray=(${8})
    local destIPArray=(${9})
    local destNodeArray=(${10})
    local destUser=${11}
    local destRemoteFlag=${12}
    local destDIOFlag=${13}
    local destOrderedFlag=${14}
    local totalBytes=${15}
    local queueDepth=${16}
    local e2ePort=${17}
    local fileSizeFlag=${18}
    local forceFlag=${19}
    local resumeFlag=${20}
    local verbosity=${21}
    local binaryDumpFlag=${22}

    # Check the transfer preconditions
    check_transfer_preconditions "${srcFileSpec}" "${destFileSpec}" \
	"${srcRemoteFlag}" "${destRemoteFlag}" "${srcDIOFlag}" \
	"${destDIOFlag}" "${fileSizeFlag}"

    # Determine the source side file size if none specified
    if [ 0 -eq $fileSizeFlag ]; then
        totalBytes="$($XDDCP_GETFILESIZE_EXE $srcFileSpec | cut -f 1 -d ' ')"
    fi

    # Set the file resume options if needed
    if [ 1 -eq $resumeFlag ]; then
        set_resume_options "${srcFileSpec}" "${destFileSpec}" \
            "${destIPArray[0]}" "${destUser}"
    fi
    
    # Start destination-side XDD (also sets resume offset if needed)
    start_destination_xdd "${srcFileSpec}" "${destFileSpec}" "${totalBytes}" \
        "${queueDepth}" "${e2ePort}" "${destDIOFlag}" "${forceFlag}" \
        "${destOrderedFlag}" "${resumeFlag}" \
	"${verbosity}" "${binaryDumpFlag}" \
	"${destRemoteFlag}" "${destHostArray[*]}" "${destIPArray[*]}" \
        "${destNodeArray[*]}" "${destUser}"
    destRC=$?

    # Continue if the destination started correctly
    if [ 0 -eq $destRC ]; then
        # Start source-side XDD
	start_source_xdd "${srcFileSpec}" "${totalBytes}" \
            "${queueDepth}" "${e2ePort}" "${srcDIOFlag}" \
            "${srcOrderedFlag}" "${resumeFlag}" \
	    "${verbosity}" "${binaryDumpFlag}" "${destIPArray[*]}" \
            "${destNodeArray[*]}" "${srcRemoteFlag}" "${srcHost}" "${srcUser}"
	srcRC=$?

	# Wait on the destination side
	if [ 0 -ne $srcRC ]; then
	    rc=$srcRC
	    echo "INFO: Source-side XDD exited with an error: $srcRC" >/dev/stderr
            kill -9 "${g_xddcpDestSSHPid}" &> $XDDCP_DEV_NULL
        else
	    wait
	    destRC=$?

	    # Increment the transfer count if the source completed successfully
	    if [ 0 -ne $destRC ]; then
	        rc=$destRC
	        echo "INFO: Destination-side XDD exited with an error: $destRC" >/dev/stderr
	        echo "INFO: Source-side XDD exited with code: $srcRC" >/dev/stderr
	    else
	        # Signal success
	        rc=0
                echo "INFO: #$g_transferCount: $srcFileSpec transfer completed" >/dev/stderr
                # Increment the number of transfers
	        g_transferCount=$((g_transferCount+1))
	    fi
        fi
    else
	rc=$destRC
	echo "INFO: Destination-side XDD exited with an error during launch: $destRC" >/dev/stderr
    fi
 
    return $rc
}

#
# XDDCP Main
#
function xddcp_main {
    #echo "main Args: $@"
    #
    # Install necessary signal handlers
    #
    # Note: We still need to pass the signal thru for Posix compliance.  See
    #  http://www.cons.org/cracauer/sigint.html
    #
    trap 'handle_signal_common 2; trap 2; echo "sending 2"; kill -2 $$' 2 
    trap 'handle_signal_common 3; trap 3; echo "sending 3"; kill -3 $$' 3 
    trap 'handle_signal_common 15; trap 15; echo "sending 15"; kill -15 $$' 15
    trap exit

    # Print a helpful message if user is just typing command to get syntax
    if [ "$1" = "-h" ]; then
        print_usage
        return 0
    elif [ $# -lt 2 ]; then
        echo "usage: $0 [OPTION] /full_path/source_file destination_host:/full_path/destination_file [bytes_to_transfer]"
        echo "Try '$0 -h' for more information."
        return $XDDCP_ERR_CODE_INVALID_ARGS
    fi

    # Parse options
    destDIOFlag=0
    destOrderedFlag=0
    e2ePort=$XDDCP_DEFAULT_E2E_PORT
    fileListFlag=0
    fileListFile=""
    forceFlag=1
    queueDepth=$XDDCP_DEFAULT_QUEUE_DEPTH
    recursiveFlag=0
    retryCount=3
    resumeFlag=0
    srcDIOFlag=0
    srcOrderedFlag=0
    sshOption=$XDDCP_DEFAULT_SSH_PSEUDO_TERMINAL_OPT
    verbosity=0
    binaryDumpFlag=0
    kernelTraceFlag=0
    windowSize=0

    while getopts ":FYab:cDd:fhl:n:o:p:rsTt:vVw:W:" option; do
        case $option in
            F) 
                fileListFlag=1
		fileListFile=$OPTARG
                ;;
            Y) 
                sshOption="-tt"
                ;;
            a) 
                resumeFlag=1
                ;;
            b)
                g_xddRemotePathAppend=${OPTARG}
                ;;
            c)
                forceFlag=0
                ;;
	    d) 
		if [ "$OPTARG" = "dest" -o "$OPTARG" = "d" ]; then
                    destDIOFlag=1
		elif [ "$OPTARG" = "source" -o "$OPTARG" = "s" ]; then
		    srcDIOFlag=1
		elif [ "$OPTARG" = "both" -o "$OPTARG" = "b" -o "$OPTARG" = "sd" ]; then
		    destDIOFlag=1
		    srcDIOFlag=1
		else
                    echo "INFO: Unsupported dio argument: -$option $OPTARG" >/dev/stderr 
                    error_exit $XDDCP_ERR_CODE_INVALID_ARGS
		fi
                ;;
	    f) 
                forceFlag=1
                ;;
	    h) 
                print_usage 
                return 0
                ;;
            l)  
                export PATH=${OPTARG}:${PATH}
                ;;
	    n)
		retryCount=$OPTARG
		;;
            o) 
		if [ "$OPTARG" = "dest" -o "$OPTARG" = "d" ]; then
                    destOrderedFlag=1
		elif [ "$OPTARG" = "source" -o "$OPTARG" = "s" ]; then
		    srcOrderedFlag=1
		elif [ "$OPTARG" = "both" -o "$OPTARG" = "b" -o "$OPTARG" = "sd" ]; then
		    destOrderedFlag=1
		    srcOrderedFlag=1
		else
                    echo "INFO: Unsupported dio argument: -$option $OPTARG" >/dev/stderr 
                    error_exit $XDDCP_ERR_CODE_INVALID_ARGS
		fi
                ;;
            p) 
                e2ePort=$OPTARG
                ;;
	    r) 
                recursiveFlag=1
                ;;
	    t) 
                queueDepth=$OPTARG
                ;;
	    v) 
		if [ $verbosity -lt 1 ]; then
                    verbosity=1
		fi
                ;;
	    V) 
		if [ $verbosity -lt 2 ]; then
                    verbosity=2
		fi
                ;;
	    w) 
                verbosity=2
		binaryDumpFlag=1
		windowSize=$OPTARG
		expr $windowSize + 1 >$XDDCP_DEV_NULL 2>&1
		if [ $? -ne 0 ]; then
			echo "INFO: Window size (-w arg) must be an integer." >/dev/stderr
			error_exit $XDDCP_ERR_CODE_INVALID_ARGS
		elif [ $windowSize -le 0 ]; then
			echo "INFO: Window size (-w arg) must be greater than zero." >/dev/stderr
			error_exit $XDDCP_ERR_CODE_INVALID_ARGS
		fi
                ;;
	    W) 
                verbosity=2
		binaryDumpFlag=1
		kernelTraceFlag=1
		windowSize=$OPTARG
		expr $windowSize + 1 >$XDDCP_DEV_NULL 2>&1
		if [ $? -ne 0 ]; then
			echo "INFO: Window size (-w arg) must be an integer." >/dev/stderr
			error_exit $XDDCP_ERR_CODE_INVALID_ARGS
		elif [ $windowSize -le 0 ]; then
			echo "INFO: Window size (-w arg) must be greater than zero." >/dev/stderr
			error_exit $XDDCP_ERR_CODE_INVALID_ARGS
		fi
                type -P XDDCP_IOTRACE_EXE
                if [ $? -ne 0 ]; then
                    echo "INFO: kernel trace mode requires the '$XDDCP_IOTRACE_EXE' command. Install or use -w option."
                    error_exit $XDDCP_ERR_CODE_MISSING_KERNEL_TRACE_COMPONENT
                fi
                if [ ! -c /dev/iotrace_data ]; then
                    echo "INFO: kernel trace mode requires the '/dev/iotrace_data' device. Install or use -w option."
                    error_exit $XDDCP_ERR_CODE_MISSING_KERNEL_TRACE_COMPONENT
                fi
                type -P XDDCP_IOTRACE_DECODE_EXE
                if [ $? -ne 0 ]; then
                    echo "INFO: kernel trace mode requires the '$XDDCP_IOTRACE_DECODE_EXE' command. Install or use -w option."
                    error_exit $XDDCP_ERR_CODE_MISSING_KERNEL_TRACE_COMPONENT
                fi
                ;;
            \?)
                echo "INFO: Unsupported option: -$option $OPTARG" >/dev/stderr 
                error_exit $XDDCP_ERR_CODE_INVALID_ARGS
                ;;
        esac
    done
    shift $((OPTIND-1))

    # The force flag only works on Linux, disable it everywhere else
    if [ "Linux" != "$(\uname)" ]; then
	forceFlag=0
	echo "Warning: File transfer forcing disabled for non-Linux platforms." >/dev/stderr
    fi

    # Get the source path
    srcPath="${1}"
    srcRemoteFlag=0

    # Parse the destination endpoint spec
    destRemoteFlag=0
    parse_endpoint_spec "${2}" destPath destRemoteFlag destUser destHostArray \
        destIPArray destNodeArray
    echo "destUser is $destUser"

    # Get the specified size if it is defined
    fileSizeFlag=0
    totalBytes=0
    if [ ! -z "${3}" ]; then
        fileSizeFlag=1
        totalBytes=${3}
    fi

    # Ensure local option preconditions are met
    check_host_preconditions "${srcPath}" "${fileListFlag}" "${fileSizeFlag}" \
	"${recursiveFlag}" "${resumeFlag}" "${forceFlag}"

    ####################################################################################################
    #
    # Option Parsing Completed
    #
    ####################################################################################################

    #
    # Begin a transfer try
    #
    transferRC=1
    retries=0
    while [ 0 -ne "${transferRC}" -a "${retries}" -le "${retryCount}" ]; do

        # Get transfer history from destination if it exists
        #if [ 1 -eq $resumeFlag ]; then
	#    g_currentTransferRst="${g_filebaseTransferRst}_partial"
	#    g_completeTransfersRst="${g_filebaseTransferRst}_complete"
        #    get_file_transfer_history "${srcPath}" "${destPath}" "${destHostArray[0]}" \
        #        "${destIPArray[0]}" "${destUser}"
        #fi

        # Transfer file(s)
        if [ 1 -eq "${recursiveFlag}" ]; then
	    transfer_recursive_file_list "${g_fileRecursiveList}" "${srcHost}" "${srcUser}"\
	        "${srcRemoteFlag}" "${srcDIOFlag}" "${srcOrderedFlag}" \
	        "${destPath}" "${destHostArray[*]}" "${destIPArray[*]}" \
                "${destNodeArray[*]}" "${destUser}" \
	        "${destRemoteFlag}" "${destDIOFlag}" "${destOrderedFlag}" \
		"${queueDepth}" "${e2ePort}" \
	        "${fileSizeFlag}" "${forceFlag}" "${resumeFlag}" \
	        "${verbosity}" "${binaryDumpFlag}"
            transferRC=$?
        elif [ 1 -eq "${fileListFlag}" ]; then
	    transfer_file_list "${srcPath}" "${srcHost}" "${srcUser}"\
	        "${srcRemoteFlag}" "${srcDIOFlag}" "${srcOrderedFlag}" \
	        "${destPath}" "${destHostArray[*]}" "${destIPArray[*]}" \
                "${destNodeArray[*]}" "${destUser}" "${destRemoteFlag}" "${destDIOFlag}" \
                "${destOrderedFlag}" "${queueDepth}" \
                "${e2ePort}" "${fileSizeFlag}" "${forceFlag}" "${resumeFlag}" \
	        "${verbosity}" "${binaryDumpFlag}"
            transferRC=$?
        else
	    transfer_file "${srcPath}" "${srcHost}" "${srcUser}"\
	        "${srcRemoteFlag}" "${srcDIOFlag}" "${srcOrderedFlag}" \
	        "${destPath}" "${destHostArray[*]}" "${destIPArray[*]}" \
                "${destNodeArray[*]}" "${destUser}" "${destRemoteFlag}" "${destDIOFlag}" \
                "${destOrderedFlag}" "${totalBytes}" "${queueDepth}" \
                "${e2ePort}" "${fileSizeFlag}" "${forceFlag}" "${resumeFlag}" \
	        "${verbosity}" "${binaryDumpFlag}"
	    transferRC=$?
        fi

        # Reset global state so that the next try can continue
        if [ 0 -ne "${transferRC}" ]; then
	    # Print a retry message
	    echo "Transfer failed.  Retry attempts: $retries"
            retries=$((retries+1))
	    sleep $XDDCP_DEFAULT_RETRY_SLEEP_SECS
	    reset_global_data
            # Clean up xdd procs at source, destination
            # BUG:  Fix use of pkill since it kills anything named XDD, not
            # just the spawned process, and the user did not request
            # this specific behavior
            #local cmd="pkill -9 -u ${USER} -U ${USER} -x xdd"
            #remote_exec "${cmd}" "${destHost}" "${destUser}" "0"
            #local_exec  "${cmd}"
        fi
    done

    # Perform post transfer analysis
    if [ 1 -eq ${binaryDumpFlag} -a 0 -eq $rc ]; then
        post_transfer_analysis "${srcPath}" "${srcHost}" "${srcUser}" \
	    "${destPath}" "${destHostArray[0]}" "${destIPArray[0]}" \
            "${destUser}" "${windowSize}" "${kernelTraceFlag}"
    fi

    if [ 0 -eq "${transferRC}" ]; then
	echo ""
	echo "Transfer complete.  Verify results with md5sum."
            #All files transfered ok, remove source side list
        rm -f $g_fileRecursiveList	
    else
	echo "Transfer failed.  Error code: ${transferRC}  Retries: $retries of $retryCount"
    fi
    return "${transferRC}"
}

#
# Execute xddcp
#
xddcp_main "$@"
exit $?
