#!/bin/bash
#
# This program is free software; you can redistribute it and/or modify 
# it under the terms of the GNU General Public License as published by 
# the Free Software Foundation; either version 2 of the License, or 
# (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful, but 
# WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY 
# or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License 
# for more details.
# 
# You should have received a copy of the GNU General Public License along 
# with this program; if not, write to the Free Software Foundation, Inc., 
# 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
#
#
# This file is part of XDD
#
# Copyright (C) 2010, Brad Settlemyer
#
# Description:  This script enables the use of XDD as a remote data movement
# engine.  Its functionality loosely mimics the capabilities of scp and bbcp,
# however, with hopefully much improved performance.
#
# Notes: XDDCP has only been tested on Linux environments.  The
# following POSIX utilities are required to utilize XDDCP:
#    /bin/basename
#    /bin/cat
#    /bin/cut
#    /bin/date
#    /bin/echo
#    /bin/grep
#    /bin/hostname
#    /bin/ps
#    /bin/uname
#
# The following utilities (non-POSIX) are required to utilize XDDCP:
#    dirname
#    ssh
#    stat
#    tr
#    truncate
#    xdd.Linux
#
# The following utilities are optionally used by XDDCP:
#    gethostip
#    netstat 
#


# XDD Configurable global settings
XDDCP_DEFAULT_E2E_PORT=40010
XDDCP_DEFAULT_XFER_SIZE=33554432
XDDCP_DEFAULT_QUEUE_DEPTH=8
XDDCP_DEFAULT_SSH_PSEUDO_TERMINAL_OPT="-T"
XDDCP_DEFAULT_HEARTBEAT_SECS=4
XDDCP_DEFAULT_TIMESTAMP="$(/bin/date -u +'%Y-%m-%d-%H%M%S')-GMT"
XDDCP_DEFAULT_NETWORK_SLEEP_SECS=4
XDDCP_DEFAULT_XDD="xdd.$(/bin/uname)"

# XDDCP Error Codes
XDDCP_ERR_CODE_INVALID_ARGS=1
XDDCP_ERR_CODE_INVALID_FORMAT=2
XDDCP_ERR_CODE_XDD_NOT_FOUND=3
XDDCP_ERR_CODE_QIP_NOT_FOUND=4
XDDCP_ERR_CODE_INV_FLAGS=5
XDDCP_ERR_CODE_SRC_XST=6
XDDCP_ERR_CODE_INV_RST=7
XDDCP_ERR_CODE_SSH_ERROR=8
XDDCP_ERR_CODE_SSH_FAILURE=9
XDDCP_ERR_CODE_SMALL_FILE=10
XDDCP_ERR_CODE_XFER_SIZE=11
XDDCP_ERR_CODE_VERSION_MATCH=12
XDDCP_ERR_CODE_NO_REMOTE=13
XDDCP_ERR_CODE_XFER_FAIL=14
XDDCP_ERR_CODE_DEST_PORT=15
XDDCP_ERR_CODE_SRC_DEV_DIRECT_IO=16
XDDCP_ERR_CODE_DEST_DEV_DIRECT_IO=17
XDDCP_ERR_CODE_DEST_DEV_FILE_SIZE=18
XDDCP_ERR_CODE_DEST_DIR_NOT_XST=19
XDDCP_ERR_CODE_DEST_DIR_NOT_WR=20
XDDCP_ERR_CODE_DEST_TGT_NOT_WR=21

#
# Global variables
#
g_xddcpXddVersion="-1"
g_xddcpDestXddPid="-1"
g_xddcpSrcXddPid="-1"
g_xddcpResumeOffset="0"


#
# Print out the usage information
#
function print_usage() {
    echo "xddcp [OPTIONS] source_file destination_host:destination_file [size]"
    echo ""
    echo "source_file       - complete /filepath/name for source file on source host"
    echo "destination_host  - destination host IP or Name over which data is transferred"
    echo "destination_file  - complete /filepath/name for destination file on destination host"
    echo "size              - number of bytes to transfer [Default: size of source file]"
    echo ""
    echo "OPTIONS: "
    echo " -a		- Resume transfer if it was only partially completed and the -a flag was specified"
    echo " -d		- Use direct I/O on the destination end"
    echo " -f           - If ports are unavailable on destination, attempt to kill running XDD and retry"
    echo " -F		- Transfer a list of files named in source_file"
    echo " -h		- Print out usage information"
    echo " -p portnum   - First port to use for transfer [Default: $XDDCP_DEFAULT_E2E_PORT]" 
    echo " -o		- Ordered-mode, write data in serial order"
#    echo " -r		- Copy sub-directories and contents recursively"
    echo " -s		- Use direct I/O on the source end"
    echo " -t threads	- Use 'threads' number of threads during transfer [Default: $XDDCP_DEFAULT_QUEUE_DEPTH]"
    echo " -v		- Add verbose output to logs"
    echo " -w		- Add verbose output to logs and create a binary timestamp dump"
    #echo "-Y		- Force SSH to create psueo-terminal tty"
    #echo "NOTE: 'xdd.Linux' and script 'qipcrm' must be in your PATH env on both source and destination hosts!!!"
    echo "NOTE: 'xdd.Linux' must be in your PATH env on both source and destination hosts!!!"
}

#
# Print out an appropriate error message and exit
#
function error_exit() {
    local errorCode=$1

    #trap "multilevel_exit_handler $errorCode" EXIT
    error_print $errorCode
    exit $errorCode
}

#
# Print out an appropriate error message
#
function error_print() {
    local errorCode=$1
    case $errorCode in
        $XDDCP_ERR_CODE_INVALID_ARGS) 
            echo "ERROR: Invalid command arguments" >/dev/stderr
            ;;
        $XDDCP_ERR_CODE_INVALID_FORMAT) 
            echo "ERROR: Invalid source/destination format" >/dev/stderr
            ;;
        $XDDCP_ERR_CODE_XDD_NOT_FOUND) 
            echo "ERROR: ${XDDCP_DEFAULT_XDD} executable not found" >/dev/stderr
            ;;
        $XDDCP_ERR_CODE_QIP_NOT_FOUND) 
            echo "ERROR: qipcrm executable not found" >/dev/stderr
            ;;
        $XDDCP_ERR_CODE_INV_FLAGS) 
            echo "ERROR: Incompatible command line arguments" >/dev/stderr
            ;;
        $XDDCP_ERR_CODE_SRC_XST) 
            echo "ERROR: Cannot locate source file" >/dev/stderr
            ;;
        $XDDCP_ERR_CODE_INV_RST) 
            echo "ERROR: Invalid restart offset location" >/dev/stderr
            ;;
        $XDDCP_ERR_CODE_SSH_FAILURE) 
            echo "ERROR: Failure spawing process via SSH" >/dev/stderr
            ;;
        $XDDCP_ERR_CODE_SSH_ERROR) 
            echo "ERROR: Remote session failure" >/dev/stderr
            ;;
        $XDDCP_ERR_CODE_SMALL_FILE) 
            echo "ERROR: Cannot transfer files smaller than $XDDCP_DEFAULT_XFER_SIZE bytes" >/dev/stderr
            ;;
        $XDDCP_ERR_CODE_XFER_SIZE) 
            echo "ERROR: Requested transfer size is larger than file size" >/dev/stderr
            ;;
        $XDDCP_ERR_CODE_VERSION_MATCH) 
            echo "ERROR: ${XDDCP_DEFAULT_XDD} versions differ on source and destination" >/dev/stderr
            ;;
        $XDDCP_ERR_CODE_NO_REMOTE) 
            echo "ERROR: Local file transfers are not permitted" >/dev/stderr
            ;;
        $XDDCP_ERR_CODE_XFER_FAIL) 
            echo "ERROR: File transfer failed." >/dev/stderr
            echo "  If the reason is \"Connection refused\", check the destination logfile." >/dev/stderr
            ;;
        $XDDCP_ERR_CODE_DEST_PORT) 
            echo "ERROR: Destination port is in use" >/dev/stderr
            ;;
        $XDDCP_ERR_CODE_DEST_DEV_DIRECT_IO)
            echo "ERROR: Destination is raw device, direct I/O is not allowed." >/dev/stderr
            ;;
        $XDDCP_ERR_CODE_SRC_DEV_DIRECT_IO)
            echo "ERROR: Source is raw device, direct I/O is not allowed." >/dev/stderr
            ;;
        $XDDCP_ERR_CODE_SRC_DEV_FILE_SIZE)
            echo "ERROR: Source is raw device, transfer size must be provided." >/dev/stderr
            ;;
	$XDDCP_ERR_CODE_DEST_DIR_NOT_XST)
	    echo "ERROR: Destination directory does not exist." >/dev/stderr
	    ;;
        $XDDCP_ERR_CODE_DEST_DIR_NOT_WR)
	    echo "ERROR: Destination directory is not writable." >/dev/stderr
	    ;;
        $XDDCP_ERR_CODE_DEST_TGT_NOT_WR)
	    echo "ERROR: Destination target is not writable." >/dev/stderr
	    ;;
        \?) 
            echo "ERROR: Unknown error code" >/dev/stderr
            ;;
    esac
}

#
# Handle trapped signals
#
function handle_signal_common() {
    local signum=$1

    # Attempt to deliver the signal to XDD
    if [ -1 -ne $g_xddcpSrcXddPid ]; then
        kill -$signum $g_xddcpSrcXddPid
    fi
    echo "INFO:  Transfer cancelled by user." >/dev/stderr
}

#
# Parse endpoint spec of the form [[user@]host:]path
#
# Call with spec and variable names as arguments, e.g.:
#
# spec="user@foo.bar.com:/home/user"
# srcRemoteFlag=0
# srcUser=""
# srcHost=""
# srcPath=""
# parse_endpoint_spec $spec srcRemoteFlag srcUser srcHost srcPath
#
function parse_endpoint_spec() {
    local spec=$1
    local remoteFlagRef="$2"
    local remoteUserRef="$3"
    local remoteHostRef="$4"
    local remotePathRef="$5"
    
    # Set the outbound defaults
    eval "$remoteFlagRef=0"
    eval "$remoteUserRef=\"\""
    eval "$remoteHostRef=\"\""
    eval "$remotePathRef=\"\""
    
    # Parse out remote host and file
    local colon_count=`/bin/echo $spec | grep -c ":"`
    if [ $colon_count -eq 1 ]; then

        # Set the remote flag
        eval "$remoteFlagRef=1"

        # Set the path
        eval "$remotePathRef=$(/bin/echo $spec | awk -F: '{print $2}')"

        # Set the host
        local _tmp=$(/bin/echo $spec | awk -F: '{print $1}')
        eval "$remoteHostRef=$(/bin/echo $spec | awk -F: '{print $1}')"
        
        # Set the username if it exists
        local amp_count=$(/bin/echo $_tmp |grep -c "@")
        if [ 1 -eq $amp_count ]; then
            eval "$remoteUserRef=$(/bin/echo $_tmp |awk -F@ '{print $1}')"
            eval "$remoteHostRef=$(/bin/echo $_tmp |awk -F@ '{print $2}')"
        fi
    else
        eval "$remotePathRef=$spec"
    fi
}

#
# Check preconditions for the host
#
# Sideffects: Sets the global XDDCP version identifier
#
function check_host_preconditions() {

    # Arguments
    local sourceSideFilename=$1
    local fileListFlag=$2
    local fileSizeFlag=$3
    local resumeFlag=$4

    # Check for xdd.Linux binary
    type ${XDDCP_DEFAULT_XDD} &>/dev/null
    if [ 0 -ne $? ]; then
        error_exit $XDDCP_ERR_CODE_XDD_NOT_FOUND
    else
        g_xddcpXddVersion=$(${XDDCP_DEFAULT_XDD} -version)
    fi

    # Ensure flag combinations are valid
    if [ 1 -eq $fileListFlag -a 1 -eq $resumeFlag ]; then
        echo "INFO: -F and -a flags cannot both be specified" >/dev/stderr
        error_exit $XDDCP_ERR_CODE_INV_FLAGS
    elif [ 1 -eq $fileListFlag -a 1 -eq $fileSizeFlag ]; then
        echo "INFO: -F option does not take an argument" >/dev/stderr
        error_exit $XDDCP_ERR_CODE_INV_FLAGS
    fi

    # Ensure source side file list filename exists
    if [ 1 -eq $fileListFlag -a ! -r "${sourceSideFilename}" ]; then
	echo "INFO: Cannot read ${sourceSideFilename}" >/dev/stderr
	error_exit $XDDCP_ERR_CODE_SRC_XST
    fi
}


#
# Check preconditions for the transfer
#
function check_transfer_preconditions() {

    # Arguments
    local sourceSideFilename=$1
    local destSidePathname=$2
    local srcRemoteFlag=$3
    local destRemoteFlag=$4
    local srcDIOFlag=$5
    local destDIOFlag=$6
    local fileSizeFlag=$7
    local transferSize=$8

    # Ensure at least one of the sides is remote
    if [ 0 -eq ${destRemoteFlag} -a 0 -eq ${srcRemoteFlag} ]; then
        error_exit $XDDCP_ERR_CODE_NO_REMOTE
    fi

    # Ensure source side file exists
    if [ ! -r "${sourceSideFilename}" ]; then
	echo "INFO: Cannot read ${sourceSideFilename}"
	error_exit $XDDCP_ERR_CODE_SRC_XST
    fi

    # Ensure file is large enough
    local totalBytes="$transferSize"
    local sourceDir="${sourceSideFilename:0:4}"
    if [ "$sourceDir" != "/dev" ]; then
        local trueSize="$(get_file_size $sourceSideFilename 0)"
        if [ $XDDCP_DEFAULT_XFER_SIZE -gt $trueSize ]; then
            error_exit $XDDCP_ERR_CODE_SMALL_FILE
        elif [ 1 -eq $fileSizeFlag -a $transferSize -gt $trueSize ]; then
            error_exit $XDDCP_ERR_CODE_XFER_SIZE
        fi
    elif [ "$sourceDir" = "/dev" ]; then
	if [ 0 -eq "$fileSizeFlag" ]; then
	    error_exit $XDDCP_ERR_CODE_SRC_DEV_FILE_SIZE
	elif [ $XDDCP_DEFAULT_XFER_SIZE -gt "$transferSize" ]; then
            error_exit $XDDCP_ERR_CODE_XFER_SIZE
	fi
    fi

    # Ensure devices and Direct I/O are not combined
    local destDir="${destSidePathname:0:4}"
    if [ "$sourceDir" = "/dev" -a 0 -ne $srcDIOFlag ]; then
        error_exit $XDDCP_ERR_CODE_SRC_DEV_DIRECT_IO
    elif [ "$destDir" = "/dev" -a 0 -ne $destDIOFlag ]; then
        error_exit $XDDCP_ERR_CODE_DEST_DEV_DIRECT_IO
    fi
    return 0
}

#
# Execute xdd commands locally
#
function local_exec() {
    local cmds="$1"
    /bin/bash <<EOF
$cmds
EOF
    
    # If the transfer failed, trigger appropriate error
    local rc=$?
    if [ 0 -ne "$rc" ]; then
        error_exit "$rc"
    fi
}

#
# Execute xdd commands on remote host
#
function remote_exec() {
    #echo "remote_exec Args: $@" >/dev/stderr
    local cmds="$1"
    local remoteHost="$2"
    local remoteUser="$3"

    # Construct ssh options
    if [ ! -z "${remoteUser}" ]; then
        sshOpts="-l $remoteUser"
    fi

    # Local decl must be on seperate line so $? is correct
    local destRC=""
    local remoteOutput=""
    remoteOutput=$(ssh ${sshOpts} ${remoteHost} bash <<EOF
$cmds
EOF
        )
    destRC=$?

    # Check the status of remote operations
    if [ 255 -eq $destRC ]; then
        echo "INFO: Remote output - $remoteOutput" >/dev/stderr
        error_exit $XDDCP_ERR_CODE_SSH_FAILURE
    elif [ 0 -ne $destRC -a ! -z "$remoteOutput" ]; then
        echo "INFO: Remote RC: $destRC Remote Error: $remoteOutput" >/dev/stderr
        error_print $destRC
        error_exit $XDDCP_ERR_CODE_SSH_ERROR
    elif [ 0 -ne $destRC ]; then
        echo "INFO: Remote operation failure, no cause detected" >/dev/stderr
        error_exit $XDDCP_ERR_CODE_SSH_ERROR
    fi
    echo "$remoteOutput"
}

#
# Return the file size
#
function get_file_size() {
    #echo "get_file_size Args: $@" >/dev/stderr
    local filename=$1
    local remoteFlag=$2
    local host=$3
    local user=$4

    if [ 0 -eq "$remoteFlag" ]; then
        echo $(stat -c %s $filename)
    else
        cmd="stat -c %s $filename"
        remote_exec $cmd $host $user
    fi
}

#
# Return the destination side program
#
function get_destination_cmds() {
    #echo "get_destination_cmds Args: $@" >/dev/stderr
    local destHost=${1}
    local destIfaces=${2}
    local destIfaceThreads=${3}
    local srcFile=${4}
    local destFile=${5}
    local totalBytes=${6}
    local e2ePort=${7}
    local dioFlag=${8}
    local forceFlag=${9}
    local serialOrderedFlag=${10}
    local recursionFlag=${11}
    local resumeFlag=${12}
    local verboseFlag=${13}

    # Options that aren't yet settable
    local srcHost=$(/bin/hostname)
    
    # Construct transfer settings
    let "xfer      = ${XDDCP_DEFAULT_XFER_SIZE}"
    let "numreqs   = $totalBytes / $xfer"
    let "blocksize = 1024"
    let "reqsize   = $xfer / $blocksize"

    # Other variables
    local srcBase=$(/bin/basename $srcFile)
    local destBase=$(/bin/basename $destFile)
    local destDirname=$(dirname $destFile)
    local destLog="xdd.${destHost}.${destBase}.${XDDCP_DEFAULT_TIMESTAMP}.log"
    local destQD="-queuedepth ${queueDepth}"

    # Construct the e2e destinations
    local e2eDestinations=""
    declare idx=0
    for iface in $destIfaces; do
	idx=$((idx+1))
	tcount=$(/bin/echo $destIfaceThreads |cut -f $idx -d ' ')
	e2eDestinations="$e2eDestinations -e2e dest ${iface}:${e2ePort},${tcount}" 
    done
    if [ -z "$e2eDestinations" ]; then
	/bin/echo "ERROR: No destination interfaces specified"
	error_exit $XDDCP_ERR_CODE_NO_REMOTE
    fi

    # Direct I/O option
    if [ 1 -eq $dioFlag ]; then
        local destDIO="-dio"
    fi

    # Thread ordering option
    local orderedOpt="-noordering"
    if [ 1 -eq $serialOrderedFlag ]; then
        orderedOpt="-serialordering"
    fi

    # Verbose option
    if [ 1 -eq $verboseFlag ]; then
        local verboseOpt="-ts detailed -ts output e2e"
    fi
    
    cat <<EOF
# Ensure xdd is in the remote path
\$(hash ${XDDCP_DEFAULT_XDD}) >/dev/null
if [ 0 -ne \$? ]; then
    echo "xdd.Linux is not in destination host PATH"
    exit ${XDDCP_ERR_CODE_XDD_NOT_FOUND}
fi

# Check that the correct version of XDD is available
dest_version=\$(${XDDCP_DEFAULT_XDD} -version)
if [ "\$dest_version" != "$g_xddcpXddVersion" ]; then
    echo "XDD source and destionation version mismatch."
    exit ${XDDCP_ERR_CODE_VERSION_MATCH}
fi

# Check that ports are available for binding
declare -i port_conflict=0
type gethostip &>/dev/null
hasIpTranslator=\$?
if [ 1 -ne \$hasIpTranslator ]; then
    declare -i tcount_idx=0
    for iface in $destIfaces; do
        tcount_idx=\$((tcount+1))
        tcount=\$(/bin/echo $destIfaceThreads |cut -f \$tcount_idx -d ' ')
        iface_ip=\$(gethostip -d \$iface)
        e2eLB=$e2ePort
        e2eUB=\$((e2eLB+tcount))
        echo "\$tcount_idx \$iface_ip \$e2eLB \$e2eUB" >>/tmp/bws
        echo "netstat -nat |grep \$iface_ip |cut -d : -f 2 |cut -d ' ' -f 1 |tr -d [:alpha:])" >>/tmp/bws
        used_ports=\$(netstat -nlt |grep \$iface_ip |cut -d : -f 2 |cut -d ' ' -f 1 |tr -d [:alpha:])
        echo "Used ports: \$used_ports" >>/tmp/bws
        for p in \$used_ports; do
            if [ \$e2eLB -le \$p -a \$e2eUB -gt \$p ]; then
                port_conflict=1
                break
            fi
        done
    done
fi

# If a port conflict exists, user may want to kill running XDD's and retry
if [ 1 -eq \$port_conflict ]; then
    # Attempt to kill any running XDDs and re-check
    if [ 1 -eq $forceFlag ]; then
        xddpid=\$(/bin/ps -u \${USER} |grep xdd |grep -v grep |grep -v xddcp |cut -c-5)
        if [ ! -z "\$xddpid" ]; then
            kill \$xddpid 2>/dev/null
            sleep 1
            kill -9 \$xddpid 2>/dev/null
            sleep 1
        fi
    else
        echo "Requested port \$p is in use"
        exit ${XDDCP_ERR_CODE_DEST_PORT}
    fi

    tcount_idx=0
    for iface in $destIfaces; do
        tcount_idx+=1
        tcount=\$(/bin/echo $destIfaceThreads |cut -f \$tcount_idx -d ' ')
        e2eLB=$e2ePort
        e2eUB=\$((e2eLB+tcount))
        used_ports=\$(netstat -nlt |grep $iface |cut -d : -f 2 |cut -d ' ' -f 1 |tr -d [:alpha:])
        for p in \$used_ports; do
            if [ \$e2eLB -le \$p -a \$e2eUB -gt \$p ]; then
                echo "Requested port \$p is in use"
                exit ${XDDCP_ERR_CODE_DEST_PORT}
            fi
        done
    done
fi

# If the filename uses a relative path, path complement it
path_char=\$(dirname $destFile |cut -c 1)
if [ "." == \$path_char ]; then
    default_dir=\$(/bin/pwd)
    destination_dir="\${default_dir}/${destDirname}"
    destination_file="\${default_dir}/${destFile}"
    destination_log="\${default_dir}/${destLog}"
else
    destination_dir="${destDirname}"
    destination_file="${destFile}"
    destination_log="\${destination_dir}/${destLog}"
fi

# Ensure destination is writable
if [ ! -d \$destination_dir ]; then
    echo "Destination directory does not exist: \$destination_dir"
    exit ${XDDCP_ERR_CODE_DEST_DIR_NOT_XST}
elif [ -d \$destination_dir -a ! -e \$destination_file -a ! -w \$destination_dir ]; then
    echo "Destination directory is not writable: \$destination_dir"
    exit ${XDDCP_ERR_CODE_DEST_DIR_NOT_WR}
elif [ -e \$destination_file -a ! -w \$destination_file ]; then
    echo "Destination target exists but is not writable: \$destination_file"
    exit ${XDDCP_ERR_CODE_DEST_TGT_NOT_WR}
fi

# Perform restart if necessary
if [ 1 == $resumeFlag ]; then
    # Ensure sufficient permissions exist to create restart cookie
    if [ ! -w \$destination_dir ]; then
        echo "Restart option requires write access to: \$destination_dir"
        exit ${XDDCP_ERR_CODE_DEST_DIR_NOT_WR}
    fi

    # Create the name for a new restart cookie
    restart_logfile="\${destination_dir}/xdd.${srcHost}.${srcBase}.${destHost}.${destBase}.${XDDCP_DEFAULT_TIMESTAMP}.rst"

    # Check for the existence a restart cookie
    most_recent_restart_cookie=\$(/bin/ls \${destination_dir}/xdd.${srcHost}.${srcBase}.${destHost}.${destBase}.*.rst 2>/dev/null |tail -1)
    echo "Using restart cookie: \$most_recent_restart_cookie"
    if [ -z "\$most_recent_restart_cookie" ]; then
       destination_restart="-restart file \${restart_logfile} -restart enable"
    else
       destination_restart="-restart file \${restart_logfile} -restart enable \$(/bin/cat \$most_recent_restart_cookie)"
    fi
fi

# If insufficient permissions for the log exist, direct to HOME
if [ ! -w \$destination_dir -a -e \$destination_log -a ! -w \$destination_log ]; then
    echo "Logfile already exists and is not writable: \$destination_log" 
    exit ${XDDCP_ERR_CODE_DEST_TGT_NOT_WR}
elif [ ! -w \$destination_dir -a ! -w \$destination_log ]; then
    home_dir_log="./${destLog}"
    if [ ! -w "./" ]; then
        echo "Could not create log file as \$destination_log or as \$home_dir_log"
        exit ${XDDCP_ERR_CODE_DEST_TGT_NOT_WR}
    fi
    echo "Warning: Writing log to: \$home_dir_log"
    destination_log=\$home_dir_log
fi

# Truncate the destination to the correct size if necessary
if [ -e \$destination_file ]; then
    cur_size=\$(stat -c '%s' \${destination_file})
    if [ \$cur_size -gt $totalBytes ]; then
        truncate -s $totalBytes \${destination_file}
    fi
fi

# XDD Command
xdd_cmd="${XDDCP_DEFAULT_XDD} -target \${destination_file} -op write -minall ${orderedOpt} ${verboseOpt} -bytes ${totalBytes} -reqsize $reqsize -e2e isdestination ${e2eDestinations} ${destDIO} \${destination_restart} -preallocate ${totalBytes} -verbose > \${destination_log}"

# Log XDD Command
#if [ 1 -eq $verboseFlag ]; then
    echo "Destination-side invocation: \${xdd_cmd}" > \${destination_log}
#fi

# Invoke XDD
\${xdd_cmd} >> \${destination_log} 2>&1 &

# Send the restart offset back to the source side via an exit code
if [ 1 -eq $resumeFlag ]; then
    echo "XDDCP RESTART TOKENS: \${destination_restart}"
else
    echo "XDD started without restart capability"
fi
EOF
}

#
# Return the source side program
#
function get_source_cmds() {
    #echo "get_source_cmds Args: $@" >/dev/stderr
    local destIfaces=${1}
    local srcFile=${2}
    local totalBytes=${3}
    local destIfaceThreads=${4}
    local e2ePort=${5}
    local srcDIOFlag=${6}
    local serialOrderedFlag=${7}
    local resumeFlag=${8}
    local verboseFlag=${9}
    local resumeOffset=${10}

    # Construct XDD transfer settings
    let "xfer      = ${XDDCP_DEFAULT_XFER_SIZE}"
    let "numReqs   = ${totalBytes} / $xfer"
    let "blockSize = 1024"
    let "reqSize   = $xfer / $blockSize"

    # Construct the e2e destinations
    local e2eDestinations=""
    declare idx=0
    for iface in $destIfaces; do
	idx=$((idx+1))
	tcount=$(/bin/echo $destIfaceThreads |cut -f $idx -d ' ')
	e2eDestinations="$e2eDestinations -e2e dest ${iface}:${e2ePort},${tcount}" 
    done
    if [ -z "$e2eDestinations" ]; then
	/bin/echo "ERROR: No destination interfaces specified"
	error_exit $XDDCP_ERR_CODE_NO_REMOTE
    fi

    # Validate restart flag if necessary
    srcRestart=""
    if [ 1 == $resumeFlag ]; then
        if [ "enable" == "$resumeOffset" ]; then
            srcRestart="-restart enable"
        elif [ "capability" == "$resumeOffset" ]; then
            error_exit $XDDCP_ERR_CODE_INV_RESTART
        elif [ 0 -le "$resumeOffset" ]; then
            echo "INFO: Resuming XDD file transfer at offset: $resumeOffset" >/dev/stderr
            srcRestart="-restart enable -restart offset $resumeOffset"
        else
            error_exit $XDDCP_ERR_CODE_INV_RESTART
        fi
    fi

    # Construct source XDD settings
    local srcBase=$(/bin/basename ${srcFile})
    local srcQD="-queuedepth ${queueDepth}"
    local srcLog="xdd.$(/bin/hostname).${srcBase}.${XDDCP_DEFAULT_TIMESTAMP}.log"

    # Direct I/O option
    if [ 1 -eq $srcDIOFlag ]; then
        local srcDIO="-dio"
    fi

    # Thread ordering option
    local orderedOpt="-looseordering"
    if [ 1 -eq $serialOrderedFlag ]; then
        orderedOpt="-serialordering"
    fi

    # Verbose option
    if [ 1 -eq $verboseFlag ]; then
        local verboseOpt="-ts detailed -ts output e2e"
    fi
    
    # Determine if output can be sent to log file
    local srcOutput="-output ${srcLog}"
    if [ ! -w "./" ]; then
        echo "WARNING:  Cannot create log file: ./$srcLog, logging output to stdout" >/dev/stderr
        sourceOutput=""
    fi

    # Build the command string
    cat <<EOF
# Ensure xdd is in the path
\$(hash ${XDDCP_DEFAULT_XDD}) >/dev/null
if [ 0 -ne \$? ]; then
    echo "xdd.Linux is not in the source host PATH"
    exit ${XDDCP_ERR_CODE_XDD_NOT_FOUND}
fi

# Check that the correct version of XDD is available
source_version=\$(${XDDCP_DEFAULT_XDD} -version)
if [ "\$source_version" != "$g_xddcpXddVersion" ]; then
    echo "XDD source and destionation version mismatch."
    exit ${XDDCP_ERR_CODE_VERSION_MATCH}
fi

# Ensure source side file exists
if [ ! -r "${srcFile}" ]; then
    echo "ERROR: Cannot read source file: ${srcFile}"
    exit ${XDDCP_ERR_CODE_SRC_XST}
fi

# Add the command to the log file
src_log="xdd.\$(/bin/hostname).${srcBase}.${XDDCP_DEFAULT_TIMESTAMP}.log"

xdd_cmd="${XDDCP_DEFAULT_XDD} -targets 1  ${srcFile} -op read -minall ${orderedOpt} ${verboseOpt} -bytes ${totalBytes} -reqsize ${reqSize} -e2e issource ${e2eDestinations} ${srcDIO} ${srcRestart} -output \${src_log} -hb ${XDDCP_DEFAULT_HEARTBEAT_SECS} -hb pct"
echo "Source-side invocation: \${xdd_cmd}" > \${src_log}

# Construct local transport endpoint
\${xdd_cmd}

src_xdd_rc=\$?
if [ \${src_xdd_rc} -ne 0 ]; then
    exit ${XDDCP_ERR_CODE_XFER_FAIL}
fi
EOF
}

function start_destination_xdd() {
    #echo "start_destination_xdd Args: $@" >/dev/stderr
    local srcPath=${1}
    local destPath=${2}
    local totalBytes=${3}
    local queueDepth=${4}
    local e2ePort=${5}
    local dioFlag=${6}
    local forceFlag=${7}
    local orderedFlag=${8}
    local recursionFlag=${9}
    local resumeFlag=${10}
    local verboseFlag=${11}
    local remoteFlag=${12}
    local destHost=${13}
    local destUser=${14}
    local destIfaces=${15}

    # Get source commands
    local execRC=1
    local destResult=""
    local destCmds=$(get_destination_cmds "$destHost" "$destIfaces" \
        "$queueDepth" "$srcPath" "$destPath" \
        "$totalBytes" "$e2ePort" "$dioFlag" "$forceFlag" "$orderedFlag" \
        "$recursionFlag" "$resumeFlag" "$verboseFlag")
    execRC=$?
    if [ 0 -ne $execRC ]; then
        exit $execRC
    fi

    # Execute destination side commands
    if [ 1 -eq ${remoteFlag} ]; then
        destResult=$(remote_exec "${destCmds}" "${destHost}" "${destUser}")
        execRC=$?
    else
        destResult=$(local_exec "${destCmds}")
        execRC=$?
    fi
    if [ 0 -ne $execRC ]; then
        exit $execRC
    fi
    
    # Extract the resume offset from the remote output
    if [ 1 == $resumeFlag ]; then
        g_xddcpResumeOffset=$(/bin/echo $destResult |rev |cut -d ' ' -f 1 |rev)
        if [ -z "$g_xddcpResumeOffset" ]; then
            error_exit $XDDCP_ERR_CODE_INV_RESTART
        fi
    fi    
    return 0
}

function start_source_xdd() {
    #echo "start_source_xdd Args: $@" >/dev/stderr
    local path=${1}
    local totalBytes=${2}
    local queueDepth=${3}
    local e2ePort=${4}
    local dioFlag=${5}
    local orderedFlag=${6}
    local resumeFlag=${7}
    local verboseFlag=${8}
    local resumeOffset=${9}
    local destHost=${10}
    local remoteFlag=${11}
    local srcHost=${12}
    local srcUser=${13}

    # Get source commands
    local execRC=1
    srcCmds=$(get_source_cmds "${destHost}" "${path}" "${totalBytes}" \
	"${queueDepth}" "${e2ePort}" "${dioFlag}" "${orderedFlag}" \
	"${resumeFlag}" "${verboseFlag}" "${resumeOffset}")
    execRC=$?
    if [ 0 -ne $execRC ]; then
        exit $execRC
    fi

    # Execute source commands
    if [ 1 -eq ${remoteFlag} ]; then
        remote_exec "${srcCmds}" "${srcHost}" "${srcUser}"
        execRC=$?
    else
        local_exec "${srcCmds}"
        execRC=$?
    fi
    if [ 0 -ne $execRC ]; then
        exit $execRC
    fi

    return $execRC
}

#
# XDDCP Main
#
function xddcp_main() {
    #echo "main Args: $@"
    #
    # Install necessary signal handlers
    #
    # Note: We still need to pass the signal thru for Posix compliance.  See
    #  http://www.cons.org/cracauer/sigint.html
    #
    trap 'handle_signal_common 2; trap 2; kill -2 $$' 2 
    trap 'handle_signal_common 3; trap 3; kill -3 $$' 3 
    trap 'handle_signal_common 15; trap 15; kill -15 $$' 15
    trap exit

    # Print a helpful message if user is just typing command to get syntax
    if [ "$1" == "-h" ]; then
        print_usage
        return 0
    elif [ $# -lt 2 ]; then
        echo "usage: $0 [OPTION] /full_path/source_file destination_host:/full_path/destination_file [bytes_to_transfer]"
        echo "Try '$0 -h' for more information."
        return $XDDCP_ERR_CODE_INVALID_ARGS
    fi

    # Parse options
    destDIOFlag=0
    e2ePort=$XDDCP_DEFAULT_E2E_PORT
    fileListFlag=0
    fileListFile=""
    forceFlag=0
    orderedFlag=0
    queueDepth=$XDDCP_DEFAULT_QUEUE_DEPTH
    recursiveFlag=0
    resumeFlag=0
    srcDIOFlag=0
    sshOption=$XDDCP_DEFAULT_SSH_PSEUDO_TERMINAL_OPT
    verboseFlag=0
    binaryDumpFlag=0

    while getopts ":FYadfhp:orst:vw" option; do
        case $option in
            F) 
                fileListFlag=1
		fileListFile=$OPTARG
                ;;
            Y) 
                sshOption="-tt"
                ;;
            a) 
                resumeFlag=1
                ;;
	    d) 
                destDIOFlag=1
                ;;
	    f) 
                forceFlag=1
		type gethostip &>/dev/null
		if [ $? -ne 0 ]; then
		    echo "INFO: Force mode requires the gethostip command, force disabled."
		fi
                ;;
	    h) 
                print_usage 
                return 0
                ;;
            o) 
                orderedFlag=1
                ;;
            p) 
                e2ePort=$OPTARG
                ;;
	    r) 
                recursiveFlag=1
                echo "INFO: Unsupported option: -$OPTARG" >/dev/stderr 
                error_exit $XDDCP_ERR_CODE_INVALID_ARGS
                ;;
	    s) 
                srcDIOFlag=1
                ;;
	    t) 
                queueDepth=$OPTARG
                ;;
	    v) 
                verboseFlag=1
                ;;
	    w) 
                verboseFlag=1
		binaryDumpFlag=1
                ;;
            \?)
                echo "INFO: Unsupported option: -$OPTARG" >/dev/stderr 
                error_exit $XDDCP_ERR_CODE_INVALID_ARGS
                ;;
        esac
    done
    shift $((OPTIND-1))

    # Handle a set of input files
    srcFileSpecList="${1}"

    # Parse the destination endpoint spec
    destRemoteFlag=0
    parse_endpoint_spec "${2}" destRemoteFlag destUser destHost destPath

    # Get the specified size if it is defined
    fileSizeFlag=0
    totalBytes=0
    if [ ! -z "${3}" ]; then
        fileSizeFlag=1
        totalBytes=${3}
    fi

    # Ensure local option preconditions are met
    check_host_preconditions ${srcFileSpecList} ${fileListFlag} \
        ${fileSizeFlag} ${resumeFlag}

    # If using the file list, get all of the source specs and path complement
    if [ 1 -eq $fileListFlag ]; then
	local srcFileSpecDir=$(dirname ${srcFileSpecList})
	local fileNames=""
	for name in $(/bin/cat ${srcFileSpecList}); do
	    local pathChar=$(dirname $name |cut -c 1)
	    if [ "." == "$pathChar" ]; then
		fileNames="${srcFileSpecDir}/${name} $fileNames"
	    else
		fileNames="$name $fileNames"
	    fi
	done

	# Set the path modified file names as the source specs
	srcFileSpecList="$fileNames"
    fi

    # Process all source file specs
    for srcFileSpec in ${srcFileSpecList}; do

	# Modify the destination path for file list transfers
	local destFileSpec=$destPath
	if [ 1 -eq ${fileListFlag} ]; then
	    local srcFileName=$(basename ${srcFileSpec})
	    destFileSpec=${destPath}/${srcFileName}
	fi

        # Parse the source side spec
        srcRemoteFlag=0
        parse_endpoint_spec ${srcFileSpec} srcRemoteFlag srcUser srcHost srcPath

	# Check the transfer preconditions
	check_transfer_preconditions "${srcFileSpec}" "${destFileSpec}" \
	    "${srcRemoteFlag}" "${destRemoteFlag}" "${srcDIOFlag}" "${destDIOFlag}" \
	    "${fileSizeFlag}" "${totalBytes}"

        # Determine the source file size
        if [ 0 -eq $fileSizeFlag ]; then
            totalBytes=$(get_file_size ${srcFileSpec} \
                ${srcRemoteFlag} ${srcHost} ${srcUser})
        fi

        # Ensure the source file is large enough
        if [ "$XDDCP_DEFAULT_XFER_SIZE" -gt "$totalBytes" ]; then
            echo "INFO: $srcPath file size is $totalBytes bytes" >/dev/stderr
            error_exit $XDDCP_ERR_CODE_SMALL_FILE
        fi

        # Start destination-side XDD (also sets resume offset if needed)
        start_destination_xdd "${srcFileSpec}" "${destFileSpec}" "${totalBytes}" \
            "${queueDepth}" "${e2ePort}" "${destDIOFlag}" "${forceFlag}" \
            "${orderedFlag}" "${recursiveFlag}" "${resumeFlag}" "${verboseFlag}" \
	    "${destRemoteFlag}" "${destHost}" "${destUser}" "${destHost}"
        rc=$?
        if [ 0 -ne $rc ]; then
           error_exit $rc
        fi
 
        # Wait to ensure the destination side has setup network and accepting
        sleep $XDDCP_DEFAULT_NETWORK_SLEEP_SECS

        # Start source-side XDD
        start_source_xdd "${srcFileSpec}" "${totalBytes}" \
            "${queueDepth}" "${e2ePort}" "${srcDIOFlag}" \
            "${orderedFlag}" "${resumeFlag}" "${verboseFlag}" \
            "${g_xddcpResumeOffset}" "${destHost}" \
            "${srcRemoteFlag}" "${srcHost}" "${srcUser}"
        rc=$?
        if [ 0 -ne $rc ]; then
            error_exit $rc
        fi

        echo ""
        echo "Transfer complete.  Verify results with md5sum."
    done
    return 0
}

#
# Execute xddcp
#
xddcp_main "$@"
exit $?
