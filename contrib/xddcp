#!/bin/bash
#
# IMPORTANT NOTE: I found it necessary to delete the destination file
# before every test *IF* the same namespace is used AND the test used
# a smaller file size than the previous test. It seems as though the
# destination file is not truncated to the newer, SMALLER size, thus
# md5sum goes after the old size and gives different sums. I know WHAT
# happens, but not WHY. Is this an XDD or XFS issue??? Just be forewarned.
#
#

# XDD Configurable global settings
XDDCP_DEFAULT_E2E_PORT=40010
XDDCP_DEFAULT_XFER_SIZE=16777216
XDDCP_DEFAULT_QUEUE_DEPTH=4
XDDCP_DEFAULT_SSH_PSEUDO_TERMINAL_OPT="-T"

#
# Print out the usage information
#
function print_usage() {
    echo "xddcp [OPTIONS] source_file destination_host:destination_file"
    echo ""
    echo "source_file       - complete /filepath/name for source file on source host"
    echo "destination_host  - destination host IP or Name over which data is transferred"
    echo "destination_file  - complete /filepath/name for destination file on destination host"
    echo ""
    echo "OPTIONS: "
    echo " -a		- Resume transfer if it was only partially completed and the -a flag was specified"
    echo " -d		- Use direct I/O on the destination end"
    echo " -F		- Transfer a list of files named in source_file"
    echo " -h		- Print out usage information"
    echo " -p portnum   - First port to use for transfer [Default: $XDDCP_DEFAULT_E2E_PORT]" 
    echo " -s		- Use direct I/O on the source end"
    echo " -t threads	- Use 'threads' number of threads during transfer [Default: $XDDCP_DEFAULT_QUEUE_DEPTH]"
    #echo "-Y		- Force SSH to create psueo-terminal tty"
    echo "NOTE: 'xdd.Linux' and script 'qipcrm' must be in your PATH env on both source and destination hosts!!!"
}

#
# Check preconditions
#
function check_preconditions() {
    source_side_filename="$1"

    # Check for qipcrm script
    which qipcrm > /dev/null 2> /dev/null
    if [ $? -eq 1 ]; then
	echo "ERROR: qipcrm executable was not found.  Please make sure it is in your PATH."
	exit -1
    fi

    # Check for xdd.Linux binary
    which xdd.Linux >/dev/null 2> /dev/null
    if [ $? -eq 1 ]; then
        echo "ERROR: xdd.Linux executable was not found.  Please make sure it is in your PATH."
        exit -2
    fi

    # Check for confidence directory
    if [ ! -d /dev/shm/condata ]; then
	mkdir /dev/shm/condata
	chmod 1777 /dev/shm/condata
    fi

    # Ensure confidence directory is writable
    if [ ! -w /dev/shm/condata ]; then
	echo "ERROR: /dev/shm/condata needs to be writeable"
	exit -3
    fi

    # Ensure source side file exists
    if [ ! -r "${source_side_filename}" ]; then
	echo "ERROR: Cannot read source file: ${source_side_filename}"
	exit -4
    fi

    # Ensure source side file is larger than 16MB
    source_file_size=$(stat -c "%s" ${source_side_filename})
    if [ $source_file_size -lt 16777216 ]; then
	echo "ERROR: Source file must be larger than 16777216, actual size: $source_file_size"
	exit -5
    fi
}

#
# Perform local cleanup operations
#
function perform_local_cleanup() {
    qipcrm ${USER}
    pgrep -u ${USER} -f xdd.Linux | xargs kill -9 2> /dev/null
}

#
# Initialize local transfer
#
function init_local_transfer() {

    # Arguments
    local remoteHost=$1
    local sourceFile=$2
    local totalBytes=$3
    local queueDepth=$4
    local e2ePort=$5
    local sourceDIOFlag=$6
    local resumeFlag=$7
    local resumeOffset=$8

    # Construct XDD transfer settings
    let "xfer      = ${XDDCP_DEFAULT_XFER_SIZE}"
    let "numreqs   = ${totalBytes} / $xfer"
    let "blocksize = 1024"
    let "reqsize   = $xfer / $blocksize"

    # Validate restart flag if necessary
    sourceRestart=""
    if [ 1 == $resumeFlag ]; then
        if [ "enable" == "$resumeOffset" ]; then
            sourceRestart="-restart enable"
        elif [ 0 -le $resumeOffset ]; then
            echo "INFO: Resuming XDD file transfer at offset: $resumeOffset"
            sourceRestart="-restart enable -restart offset $resumeOffset"
        else
	    echo "ERROR: Invalid restart offset: $resumeOffset"
	    exit -10
        fi
    fi

    # Construct source XDD settings
    local sourceBase=$(basename ${sourceFile})
    local sourceQD="-queuedepth ${queuedepth}"
    local sourceLog="nt1.qd${queueDepth}.${xfer}x${numReqs}.file-to-file.xfs.xdd.${sourceBase}.out"
    if [ 1 -eq $sourceDIOFlag ]; then
        local sourceDIO="-dio"
    fi

    # Construct local transport endpoint
    xdd.Linux -targets 1  ${sourceFile} -op read -minall \
        -bytes ${totalBytes} -reqsize ${reqsize} ${sourceQD} \
        -e2e issource -e2e dest ${remoteHost} -e2e port ${e2ePort} \
        ${sourceDIO} ${sourceRestart} \
        -timerinfo -verbose &> ${sourceLog}

    # Check transfer completion status
    transfer_rc=$?
    if [ 0 -eq "$transfer_rc" ]; then
        echo "Transfer finished (use md5sum to validate transfer)."
    else
        echo "ERROR: Transfer did not complete.  XDD Error Code: $transfer_rc"
        exit -11
    fi
}

#
# Perform remote cleanup and construct remote transport endpoint
#
function init_remote_transfer() {
    # Arguments
    local remoteHost="$1"
    local sshOpts="$2"
    local destFile="$3"
    local totalBytes="$4"
    local queueDepth="$5"
    local e2ePort="$6"
    local destDIOFlag="$7"
    local resumeFlag="$8"

    # Construct transfer settings
    let "xfer      = ${XDDCP_DEFAULT_XFER_SIZE}"
    let "numreqs   = $totalBytes / $xfer"
    let "blocksize = 1024"
    let "reqsize   = $xfer / $blocksize"

    # Other variables
    local destinationBase=$(basename $destFile)
    local destinationDir=$(dirname $destFile)
    local destinationLog="nt1.qd${queueDepth}.${xfer}x${numReqs}.file-to-file.xfs.xdd.${destinationBase}.out"
    local destinationQD="-queuedepth ${queueDepth}"
    if [ 1 -eq $destDIOFlag ]; then
        local destinationDIO="-dio"
    fi
    remote_output=$(ssh ${sshOpts} ${remoteHost} bash <<EOF

# Kill any stale xdd processes
pgrep -u \${USER} -fl xdd.Linux |grep -v pgrep |cut -f 1 -d ' ' |xargs -r kill -9 

# Cleanup leaked system resources
qipcrm \${USER} &>/dev/null

# If the filename uses a relative path, path complement it
path_char=\$(dirname $destFile |cut -c 1)
echo "First path char: \$path_char"
if [ "." == \$path_char ]; then
    default_dir=\$(pwd)
    destinationFile="\${default_dir}/${destFile}"
    destinationLog="\${default_dir}/${destinationLog}"
else
    destinationFile="${destFile}"
    destinationLog="${destinationLog}"
fi
echo "Path complemented filename is \$destinationFile"
echo "Path complemented logfile is \$destinationLog"

# Ensure destination is writable
if [ ! -d $destinationDir ]; then
    echo "Cannot write to directory: $destinationDir"
    exit -1
fi

# Perform restart if neccesary
if [ 1 == $resumeFlag ]; then

    # Check for the existence a restart cookie
    restart_file=\$(basename ${TDDestin})
    most_recent_restart_cookie=\$(ls -l destination.NA.NA.${HDestinIP}.\${restart_file}.*.rst 2>/dev/null |tail -1 | cut -d ' ' -f 9)
    echo "Using restart cookie: \$most_recent_restart_cookie"
    if [ -z "\$most_recent_restart_cookie" ]; then
       destinationRestart="-restart enable"
    else
       destinationRestart="-restart enable \$(cat \$most_recent_restart_cookie)"
    fi
fi

# Start the XDD process
xdd.Linux -targets 1 \${destinationFile} -op write -minall \
    -bytes ${totalBytes} -reqsize $reqsize ${destinationQD} \
    -e2e isdestination -e2e dest ${remoteHost} -e2e port ${e2ePort} \
    ${destinationDIO} \${destinationRestart} \
    -verbose &> \${destinationLog} &

# Send the restart offset back to the source side via an exit code
if [ 1 == $resumeFlag ]; then
    echo "XDDCP RESTART TOKENS: \${destinationRestart}"
fi

EOF
    )

    # Check the status of remote operations
    dest_rc=$?
    #echo "Remote output strings are >$remote_output<"
    #echo "Remote return code is: $dest_rc"
    if [ 255 -eq $dest_rc ]; then
        echo "ERROR: Failure spawning remote XDD: $remote_output"
        exit -7
    elif [ -z "$remote_output" ]; then
        echo "ERROR: Remote session failed."
        exit -8
    fi

    # Extract the resume offset from the remote output
    if [ 1 == $resumeFlag ]; then
        resumeOffset=$(echo $remote_output |rev |cut -d ' ' -f 1 |rev)
        if [ -z "$resumeOffset" ]; then
            echo "ERROR: SSH psueo-terminal problems.  Adding '-Y' to the command line may fix this problem."
            exit -9
        fi
    fi
}

#
# Main
#
if [ "$1" == "-h" ]; then
    print_usage
    exit 0
elif [ $# -lt 2 ]; then
    echo "usage: $0 [OPTION] /full_path/source_file destination_host:/full_path/destination_file [bytes_to_transfer]"
    echo "Try '$0 -h' for more information."
    exit -1
fi

# Parse options
resumeFlag=0
destinationDIOFlag=0
e2eport=$XDDCP_DEFAULT_E2E_PORT
fileListFlag=0
sourceDIOFlag=0
queuedepth=$XDDCP_DEFAULT_QUEUE_DEPTH
sshoption=$XDDCP_DEFAULT_SSH_PSEUDO_TERMINAL_OPT

while getopts adFhp:st:Y option
do case $option in
        a) resumeFlag=1;;
	d) destinationDIOFlag=1;;
        F) fileListFlag=1;;
	h) print_usage; exit 0;;
        p) e2eport=$OPTARG;;
	s) sourceDIOFlag=1;;
	t) queuedepth=$OPTARG;;
        Y) sshoption="-tt";;
	esac
done
shift $((OPTIND-1))

# Parse filenames
HSourceIP=`hostname`      # HSourceIP - Source Host IP over which data is transferred
HDestinIP="$2"            # HDestinIP - Destin Host IP over which data is transferred
HSource=$HSourceIP        # assume Hostname==HostIP
TDSource="$1"             # complete filepath for source file
HDestin="$2"              # assume Hostname==HostIP
TDDestin="$3"             # complete filepath for destination file

colon_count=`echo $2 | grep -c ":"`
if [ $colon_count -eq 1 ]; then
	HDestin=`echo $2 | awk -F: '{print $1}'`
	HDestinIP=$HDestin
	TDDestin=`echo $2 | awk -F: '{print $2}'`
fi

# Handle a set of input file
sourceFileList="${TDSource}"
if [ 1 -eq $fileListFlag ]; then
    if [ 1 -eq $resumeFlag ]; then
        echo "ERROR: The -a and -F flags cannot be used simulataneously."
        exit -12
    fi
    sourceFileList=$(cat ${TDSource})
fi

# Process all source files
for sourceFile in ${sourceFileList}; do

    # Construct the detination filename if there are multiple sources
    destFile=${TDDestin}
    if [ 1 -eq $fileListFlag ]; then
        sourceNameBase=$(basename $sourceFile)
        destFile="${TDDestin}/${sourceNameBase}"
        echo "INFO: Starting transfer for: $sourceFile"
    fi

    # Ensure local-side preconditions are met
    check_preconditions ${sourceFile}

    # Perform source side cleanup
    perform_local_cleanup

    # Determine file size
    totalbytes=$(stat -c "%s" ${sourceFile})

    # Initialize the remote transfer (note $resumeOffset is set as a side effect of init_remote_transfer
    init_remote_transfer ${HDestinIP} ${sshoption} ${destFile} ${totalbytes} ${queuedepth} ${e2eport} ${destinationDIOFlag} ${resumeFlag} 
    if [ 1 -eq "${resumeFlag}" ]; then
        if [ -z "${resumeOffset}" ]; then
            echo "ERROR: Restart offset could not be determined."
            exit -10
        fi
    fi

    # Initialize the local-side transfer (note $resumeOffset is set as a side effect of init_remote_transfer)
    init_local_transfer ${HDestinIP} ${sourceFile} ${totalbytes} ${queuedepth} ${e2eport} ${sourceDIOFlag} ${resumeFlag} ${resumeOffset}

done

# Return success
exit 0
