#!/bin/bash
#
# This program is free software; you can redistribute it and/or modify 
# it under the terms of the GNU General Public License as published by 
# the Free Software Foundation; either version 2 of the License, or 
# (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful, but 
# WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY 
# or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License 
# for more details.
# 
# You should have received a copy of the GNU General Public License along 
# with this program; if not, write to the Free Software Foundation, Inc., 
# 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
#
#
# This file is part of XDD
#
# Copyright (C) 2010, Brad Settlemyer
#
# Description:  This script enables the use of XDD as a remote data movement
# engine.  Its functionality loosely mimics the capabilities of scp and bbcp,
# however, with hopefully much improved performance.
#
# Notes: XDDCP has been tested on AIX and Linux environments.  
#
# The following POSIX utilities are required to utilize XDDCP:
#    basename
#    cat
#    cut
#    date
#    echo
#    egrep
#    grep
#    hostname
#    kill
#    ps
#    uname
#
# The following utilities are provided by the XDD distribution
#    xdd-getfilesize
#    xdd-gethostip
#    xdd-truncate
#    xdd
#
# The following utilities (non-POSIX) are required to utilize XDDCP:
#    dirname
#    mkfifo
#    pkill
#    ssh
#    stat
#    tr
#
# The following utilities are optionally used by XDDCP:
#    netstat 
#


# XDD Configurable global settings
XDDCP_DEFAULT_E2E_PORT=40010
XDDCP_DEFAULT_XFER_SIZE=33554432
XDDCP_DEFAULT_QUEUE_DEPTH=8
XDDCP_DEFAULT_SSH_PSEUDO_TERMINAL_OPT="-T"
XDDCP_DEFAULT_HEARTBEAT_SECS=4
XDDCP_DEFAULT_TIMESTAMP="$(\date -u +'%Y-%m-%d-%H%M%S')-GMT"
XDDCP_DEFAULT_NETWORK_SLEEP_SECS=4
XDDCP_DEFAULT_RETRY_SLEEP_SECS=4
XDDCP_DEFAULT_NETWORK_CLEAR_SECS=2
XDDCP_DEFAULT_FIFO_PATH="/tmp/xddcp-$USER.$$"
XDDCP_IOTRACE_EXE=""

# XDD package executables
XDDCP_XDD_EXE="xdd"
XDDCP_GETHOSTIP_EXE="xdd-gethostip"
XDDCP_TRUNCATE_EXE="xdd-truncate"
XDDCP_GETFILESIZE_EXE="xdd-getfilesize"
XDDCP_READTSDUMPS_EXE="xdd-read-tsdumps"
XDDCP_PLOTTSDUMPS_EXE="xdd-plot-tsdumps"
XDDCP_PLOTTSDUMPSDK_EXE="xdd-plot-tsdumps-dk"

# XDDCP Error Codes
XDDCP_ERR_CODE_INVALID_ARGS=101
XDDCP_ERR_CODE_INVALID_FORMAT=102
XDDCP_ERR_CODE_XDD_NOT_FOUND=103
XDDCP_ERR_CODE_QIP_NOT_FOUND=104
XDDCP_ERR_CODE_INV_FLAGS=105
XDDCP_ERR_CODE_SRC_XST=106
XDDCP_ERR_CODE_INV_RST=107
XDDCP_ERR_CODE_SSH_ERROR=108
XDDCP_ERR_CODE_SSH_FAILURE=109
XDDCP_ERR_CODE_SMALL_FILE=110
XDDCP_ERR_CODE_XFER_SIZE=111
XDDCP_ERR_CODE_VERSION_MATCH=112
XDDCP_ERR_CODE_NO_REMOTE=113
XDDCP_ERR_CODE_XFER_FAIL=114
XDDCP_ERR_CODE_DEST_PORT=115
XDDCP_ERR_CODE_SRC_DEV_DIRECT_IO=116
XDDCP_ERR_CODE_DEST_DEV_DIRECT_IO=117
XDDCP_ERR_CODE_DEST_DEV_FILE_SIZE=118
XDDCP_ERR_CODE_DEST_DIR_NOT_XST=119
XDDCP_ERR_CODE_DEST_DIR_NOT_WR=120
XDDCP_ERR_CODE_DEST_TGT_NOT_WR=121
XDDCP_ERR_CODE_DEST_IP=122
XDDCP_ERR_CODE_GETHOSTIP_NOT_FOUND=123
XDDCP_ERR_CODE_FIFO_ACCESS=124
XDDCP_ERR_CODE_FIFO_FAILED=125
XDDCP_ERR_CODE_MISSING_KERNEL_TRACE_COMPONENT=126
XDDCP_ERR_CODE_INV_RESTART=127

#
# Global variables
#
g_xddcpXddVersion="-1"
g_xddcpFifoPath=""
g_xddcpDestSSHPid="-1"
g_xddcpSrcXddPid="-1"
g_transferCount="0"
g_xddRemotePathAppend=""
g_srcFilePath=""
g_srcFileMtime="0"
g_srcFileOffset="0"
g_currentFileIndex="0"
g_RestartFileDir=""
g_filebaseTransferRst=".xdd_transfer"
g_currentTransferRst=""
g_completeTransfersRst=""
g_srcRestartOpt=""
g_dstRestartOpt=""
g_START="-1"
g_timerFlag="0"
g_debugFlag="0"
g_devOut=""
g_xddcpRecursiveTransferError="0"
g_filebaseRecusiveList=".xdd_recursive_file_list"
g_fileRecursiveList=""
g_totalNICs="1"
g_destIfaces=""

function debugPrint {
    local msg=${1}
    if [ 0 -ne ${g_debugFlag} ]; then
      echo "${msg}" > ${g_devOut}
    fi
}
function timerbeg {
  if [ 0 -ne ${g_timerFlag} ]; then
    local i=${1}
    g_START[$i]=$(date +%s.%N)
  fi
}
function timerend {
  if [ 0 -ne ${g_timerFlag} ]; then
    local i=${1}
    local location="${2}"

    local END="$(date +%s.%N)"
    local DIFF="$(echo "$END - ${g_START[$i]}" | bc)"
    echo "${DIFF}s #$i: ${location}" > ${g_devOut}
  fi
}

#
# Reset global variables before retry
#
function reset_global_data {
    g_xddcpDestSSHPid="-1"
    g_xddcpSrcXddPid="-1"
    g_xddcpRecursiveTransferError="0"
}

#
# Print out the usage information
#
function print_usage {
    echo "xddcp [OPTIONS] source_file destination_host[:destination_host]:destination_file [size]"
    echo ""
    echo "source_file       - complete /filepath/name for source file on source host"
    echo "destination_host  - 1 or more destination host IP(s) or Name(s) over which data is transferred"
    echo "destination_file  - complete /filepath/name for destination file on destination host"
    echo "size              - number of bytes to transfer [Default: size of source file]"
    echo ""
    echo "OPTIONS: "
    echo " -a		- Resume transfer if it was only partially completed and the -a flag was specified"
    echo " -b           - path containing remote XDD binaries"
    echo " -c		- If ports are unavailable on destination, indicate error rather than trying to force transfer"
    echo " -d s|d|b	- Use direct I/O the end specified (s for source, d for dest, b for both)"
    echo " -f		- Attempt to kill any running XDD process at destination before spawning XDD for this transfer"
    echo " -F		- Transfer a list of files named in source_file"
    echo " -h		- Print out usage information"
    echo " -l           - local path containing remote XDD binaries"
    echo " -n		- If operation fails for any reason, retry up to n times"
    echo " -p portnum	- First port to use for transfer [Default: $XDDCP_DEFAULT_E2E_PORT]" 
    echo " -o s|d|b	- Perform file I/O in serial order on end specified (s for source, d for dest, b for both)"
    echo " -r		- Copy sub-directories and contents recursively"
    echo " -t threads	- Use 'threads' number of threads during transfer [Default: $XDDCP_DEFAULT_QUEUE_DEPTH]"
    echo " -v		- Turn on logging"
    echo " -V		- Add timestamping output to logs"
    echo " -w sec	- Add post-analysis: plot bandwidth over time with sliding window of 'sec' seconds. (sec >= 1)"
    echo " -W sec	- Add post-analysis: -w option with kernel tracing. (sec >= 1)"
    #echo "-Y           - Force SSH to create psueo-terminal tty"
    echo "NOTE: 'xdd' must be in your PATH env on both source and destination hosts!!!"
    echo "       otherwise you must specifiy the '-b' and/or the '-l' options"

}

#
# Print out an appropriate error message and exit
#
function error_exit {
    local errorCode=$1

    error_print $errorCode

#    echo "Call stack: $FUNCNAME"
#    for ((i=0; i < ${#FUNCNAME[@]}; i=$i+1)); do
#	echo "INFO: Call Stack ${FUNCNAME[$i]}"
#    done

    # Exit the program with the error code
    exit $errorCode
}

#
# Print out an appropriate error message
#
function error_print {
    local errorCode=$1
    case $errorCode in
        $XDDCP_ERR_CODE_INVALID_ARGS) 
            echo "ERROR: Invalid command arguments" >/dev/stderr
            ;;
        $XDDCP_ERR_CODE_INVALID_FORMAT) 
            echo "ERROR: Invalid source/destination format" >/dev/stderr
            ;;
        $XDDCP_ERR_CODE_XDD_NOT_FOUND) 
            echo "ERROR: ${XDDCP_XDD_EXE} executable not found" >/dev/stderr
            ;;
        $XDDCP_ERR_CODE_QIP_NOT_FOUND) 
            echo "ERROR: qipcrm executable not found" >/dev/stderr
            ;;
        $XDDCP_ERR_CODE_INV_FLAGS) 
            echo "ERROR: Incompatible command line arguments" >/dev/stderr
            ;;
        $XDDCP_ERR_CODE_SRC_XST) 
            echo "ERROR: Cannot locate source file" >/dev/stderr
            ;;
        $XDDCP_ERR_CODE_INV_RST) 
            echo "ERROR: Invalid restart offset location" >/dev/stderr
            ;;
        $XDDCP_ERR_CODE_SSH_FAILURE) 
            echo "ERROR: Failure spawing process via SSH" >/dev/stderr
            ;;
        $XDDCP_ERR_CODE_SSH_ERROR) 
            echo "ERROR: Remote session failure" >/dev/stderr
            ;;
        $XDDCP_ERR_CODE_SMALL_FILE) 
            echo "ERROR: Cannot transfer files smaller than $XDDCP_DEFAULT_XFER_SIZE bytes" >/dev/stderr
            ;;
        $XDDCP_ERR_CODE_XFER_SIZE) 
            echo "ERROR: Requested transfer size is larger than file size" >/dev/stderr
            ;;
        $XDDCP_ERR_CODE_VERSION_MATCH) 
            echo "ERROR: ${XDDCP_XDD_EXE} versions differ on source and destination" >/dev/stderr
            ;;
        $XDDCP_ERR_CODE_NO_REMOTE) 
            echo "ERROR: Local file transfers are not permitted" >/dev/stderr
            ;;
        $XDDCP_ERR_CODE_XFER_FAIL) 
            echo "ERROR: File transfer failed." >/dev/stderr
            echo "  If the reason is \"Connection refused\", check the destination logfile." >/dev/stderr
            ;;
        $XDDCP_ERR_CODE_DEST_PORT) 
            echo "ERROR: Destination port is in use" >/dev/stderr
            ;;
        $XDDCP_ERR_CODE_DEST_DEV_DIRECT_IO)
            echo "ERROR: Destination is a character device, direct I/O is not allowed." >/dev/stderr
            ;;
        $XDDCP_ERR_CODE_SRC_DEV_DIRECT_IO)
            echo "ERROR: Source is a character device, direct I/O is not allowed." >/dev/stderr
            ;;
        $XDDCP_ERR_CODE_SRC_DEV_FILE_SIZE)
            echo "ERROR: Source is a character device, transfer size must be provided." >/dev/stderr
            ;;
	$XDDCP_ERR_CODE_DEST_DIR_NOT_XST)
	    echo "ERROR: Destination directory does not exist." >/dev/stderr
	    ;;
        $XDDCP_ERR_CODE_DEST_DIR_NOT_WR)
	    echo "ERROR: Destination directory is not writable." >/dev/stderr
	    ;;
        $XDDCP_ERR_CODE_DEST_TGT_NOT_WR)
	    echo "ERROR: Destination target is not writable." >/dev/stderr
	    ;;
        $XDDCP_ERR_CODE_DEST_IP)
	    echo "ERROR: Could not resolve destination IP address." >/dev/stderr
	    ;;
        $XDDCP_ERR_CODE_GETHOSTIP_NOT_FOUND)
	    echo "ERROR: Could not find xdd-gethostip program." >/dev/stderr
	    ;;
        $XDDCP_ERR_CODE_FIFO_ACCESS)
	    echo "ERROR: Invalid permissions to access FIFO." >/dev/stderr
	    ;;
        $XDDCP_ERR_CODE_FIFO_FAILED)
	    echo "ERROR: Could not create FIFO." >/dev/stderr
	    ;;
        $XDDCP_ERR_CODE_INV_RESTART)
	    echo "ERROR: Could not restart correctly." >/dev/stderr
	    ;;
        \?) 
            echo "ERROR: Unknown error code" >/dev/stderr
            ;;
    esac
}

#
# Handle trapped signals
#
function handle_signal_common {
    local signum=$1

    # Attempt to deliver the signal to source-side XDD
    if [ -1 -ne $g_xddcpSrcXddPid ]; then
        kill -$signum $g_xddcpSrcXddPid &>/dev/null
	sleep 1
    fi

    # Attempt to destroy any open SSH sessions
    if [ -1 -ne $g_xddcpDestSSHPid ]; then
	kill $g_xddcpDestSSHPid &>/dev/null
    fi

    # Remove the FIFO if it still exists
    if [ -e "$g_xddcpFifoPath" ]; then
	rm -f $g_xddcpFifoPath &>/dev/null
    fi

    echo "INFO:  Transfer cancelled by user." >/dev/stderr
}

#
# Parse endpoint spec of the form [[user@]host:]path
#
# Call with spec and variable names as arguments, e.g.:
#
# spec="user@foo.bar.com:/home/user"
# srcRemoteFlag=0
# srcUser=""
# srcHost=""
# srcPath=""
# parse_endpoint_spec $spec srcRemoteFlag srcUser srcHost srcIP srcPath
#
function parse_endpoint_spec {
    local spec=$1
    local remoteFlagRef="$2"
    local remoteUserRef="$3"
    local remoteHostRef="$4"
    local remoteIPadRef="$5"
    local remotePathRef="$6"
    
    # Set the outbound defaults
    eval "$remoteFlagRef=0"
    eval "$remoteUserRef=\"\""
    eval "$remoteHostRef=\"\""
    eval "$remoteIPadRef=\"\""
    eval "$remotePathRef=\"\""
    
    # Parse out remote host and file
    local colon_count=$((`echo $spec|sed 's/[^:]//g'|wc -m`-1))
    if [ $colon_count -eq 0 ]; then
       eval "$remotePathRef=$spec"
    else
    # Set the remote flag
    eval "$remoteFlagRef=1"
    local totalNICs="1"
    local destHost=""
    local _tmp=$(\echo $spec | awk -F: '{print $1}')
    # Set the username if it exists
    local amp_count=$(\echo $_tmp |grep -c "@")
    if [ 1 -eq $amp_count ]; then
        eval "$remoteUserRef=$(\echo $_tmp |awk -F@ '{print $1}')"
        destHost[$totalNICs]=$(\echo $_tmp | \cut -f 2 -d "@")
    else
        destHost[$totalNICs]=$(\echo $spec | \cut -f 1 -d ":")
    fi

    while [ $totalNICs -lt $colon_count ]
    do
       # Set the path
        let        "totalNICs += 1"
        destHost[$totalNICs]=$(\echo $spec | \cut -f ${totalNICs} -d ":")
     done
     # Set the path
     let "ipath = $totalNICs + 1"
     eval "$remotePathRef=$(\echo $spec | cut -f $ipath -d ":")"
    fi
    g_destIfaces=""
    local    iNIC="1"
    while [ $iNIC -le $totalNICs ]
    do
      # Convert the destination host to its IP to avoid DNS round-robin issues
      $XDDCP_GETHOSTIP_EXE -d ${destHost[$iNIC]} &> /dev/null
      if [ 0 -ne $? ]; then
          error_exit $XDD_ERR_CODE_DEST_IP
      fi
      g_destIfaces="$g_destIfaces $($XDDCP_GETHOSTIP_EXE -d ${destHost[$iNIC]})"
      debugPrint "$iNIC : $g_destIfaces"
      let "iNIC += 1"
    done
    eval "$remoteHostRef=${destHost[1]}"
    eval "$remoteIPadRef=$($XDDCP_GETHOSTIP_EXE -d ${destHost[1]})"
}

#
# Check preconditions for the host
#
# Sideffects: Sets the global XDDCP version identifier
#
function check_host_preconditions {

    # Arguments
    local sourceSideFilename=${1}
    local fileListFlag=${2}
    local fileSizeFlag=${3}
    local recursiveFlag=${4}
    local resumeFlag=${5}
    local forceFlag=${6}

    # Set the XDD version information
    g_xddcpXddVersion=$(${XDDCP_XDD_EXE} -version)

    # Check for gethostip binary
    \type $XDDCP_GETHOSTIP_EXE &>/dev/null
    if [ 0 -ne $? ]; then
        error_exit $XDDCP_ERR_CODE_GETHOSTIP_NOT_FOUND
    fi

    # Ensure flag combinations are valid
    if [ 1 -eq $fileListFlag -a 1 -eq $fileSizeFlag ]; then
        echo "INFO: -F option does not take an argument" >/dev/stderr
        error_exit $XDDCP_ERR_CODE_INV_FLAGS
    elif [ 1 -eq $fileListFlag -a 1 -eq $recursiveFlag ]; then
        echo "INFO: -F and -r flags cannot both be specified" >/dev/stderr
        error_exit $XDDCP_ERR_CODE_INV_FLAGS
    elif [ 1 -eq $recursiveFlag -a 1 -eq $fileSizeFlag ]; then
        echo "INFO: -r option does not take an argument" >/dev/stderr
        error_exit $XDDCP_ERR_CODE_INV_FLAGS
    fi

    # Ensure tools required for force flag exist
    \type $XDDCP_GETHOSTIP_EXE &>/dev/null
    if [ $? -ne 0 ]; then
        echo "INFO: Force mode requires the gethostip command, force disabled."
        eval "forceFlag=0"
    fi
}

#
# Check preconditions for the file list transfer
#
function check_file_list_preconditions {

    # Arguments
    local sourceSideFilename=$1
    local fileSizeFlag=$3
    local resumeFlag=$4

    # Ensure source side file list filename exists and is readable
    if [ 1 -eq $fileListFlag -a ! -r "${sourceSideFilename}" ]; then
	echo "INFO: Cannot read ${sourceSideFilename}" >/dev/stderr
	error_exit $XDDCP_ERR_CODE_SRC_XST
    fi
}

#
# Check preconditions for a recursive transfer
#
function check_recursive_preconditions {

    # Arguments
    local sourceSidePath=$1
    local fileSizeFlag=$3
    local resumeFlag=$4

    # If source side name is a file, ensure its readable
    # if it is a directory, is readable and searchable
    if [ -f "${sourceSidePath}" -a ! -r "${sourceSidePath}" ]; then
	echo "INFO: Cannot read ${sourceSidePath}" >/dev/stderr
	error_exit $XDDCP_ERR_CODE_SRC_XST
    elif [ -d "${sourceSidePath}" ]; then
	if [ ! -r "${sourceSidePath}" -o ! -x "${sourceSidePath}" ]; then
	    echo "INFO: Cannot read/search ${sourceSidePath}" >/dev/stderr
	    error_exit $XDDCP_ERR_CODE_SRC_XST
	fi
    fi
}

#
# Check preconditions for the transfer
#
function check_transfer_preconditions {

    # Arguments
    local sourceSideFilename=$1
    local destSidePathname=$2
    local srcRemoteFlag=$3
    local destRemoteFlag=$4
    local srcDIOFlag=$5
    local destDIOFlag=$6
    local fileSizeFlag=$7
    local transferSize=$8

    # Ensure at least one of the sides is remote
    if [ 0 -eq ${destRemoteFlag} -a 0 -eq ${srcRemoteFlag} ]; then
        error_exit $XDDCP_ERR_CODE_NO_REMOTE
    fi

    # Ensure source side file exists
    if [ ! -r "${sourceSideFilename}" ]; then
	echo "INFO: Cannot read ${sourceSideFilename}"
	error_exit $XDDCP_ERR_CODE_SRC_XST
    fi

    # Check if file is a character special device (like zero or null)
    local sfType=$(stat -c %F ${sourceSideFilename} 2>/dev/null)
    local dfType=$(stat -c %F ${destSidePathname} 2>/dev/null)

    # Ensure file is large enough
    local totalBytes="$transferSize"
    if [ "$sfType" != "character special file" ]; then
        local trueSize="$($XDDCP_GETFILESIZE_EXE $sourceSideFilename | cut -f 1 -d " ")"
        if [ $XDDCP_DEFAULT_XFER_SIZE -gt $trueSize ]; then
            echo "Hello, file: $sourceSideFilename is too small"
            error_exit $XDDCP_ERR_CODE_SMALL_FILE
        elif [ 1 -eq $fileSizeFlag -a $transferSize -gt $trueSize ]; then
            error_exit $XDDCP_ERR_CODE_XFER_SIZE
        fi
    elif [ "$sfType" = "character special file" ]; then
	if [ 0 -eq "$fileSizeFlag" ]; then
	    error_exit $XDDCP_ERR_CODE_SRC_DEV_FILE_SIZE
	elif [ $XDDCP_DEFAULT_XFER_SIZE -gt "$transferSize" ]; then
            error_exit $XDDCP_ERR_CODE_XFER_SIZE
	fi
    fi

    # Ensure devices and Direct I/O are not combined
    if [ "$sfType" = "character special file" -a 0 -ne $srcDIOFlag ]; then
        error_exit $XDDCP_ERR_CODE_SRC_DEV_DIRECT_IO
    elif [ "$dfType" = "character special file" -a 0 -ne $destDIOFlag ]; then
        error_exit $XDDCP_ERR_CODE_DEST_DEV_DIRECT_IO
    fi
    return 0
}

#
# Execute xdd commands locally
#
function local_exec {
    local cmds="$1"
    /bin/bash --login <<EOF
$cmds
EOF
    
##    ) > /dev/null 2>&1
     
    # If the transfer failed, trigger appropriate error
    local rc=$?
    return $rc
}

#
# Execute xdd commands on remote host
#
function remote_exec {
    #echo "remote_exec Args: $@" >/dev/stderr
    local cmds="$1"
    local remoteHost="$2"
    local remoteUser="$3"
    local errorCheck="$4"

    # Construct ssh options
    if [ ! -z "${remoteUser}" ]; then
        sshOpts="-q -l $remoteUser"
    fi

    # Local decl must be on seperate line so $? is correct
    local destRC=""
    local remoteOutput=""
    #remoteOutput=$(ssh ${sshOpts} ${remoteHost} /bin/bash --login <<EOF
   if [ 2 -ne "${errorCheck}" ]; then
    (ssh ${sshOpts} ${remoteHost} /bin/bash --login <<EOF
$cmds
EOF
    ) > /dev/null 2>&1
    else
    (ssh ${sshOpts} ${remoteHost} /bin/bash --login <<EOF
$cmds
EOF
    )
    fi
    destRC=$?
   remoteOutput="$(echo "ssh ${sshOpts} ${remoteHost} /bin/bash --login ${cmds}")"
   if [ 0 -ne "${errorCheck}" ]; then
    # Check the status of remote operations
    if [ 255 -eq $destRC ]; then
        echo "INFO: Remote output - $remoteOutput" >/dev/stderr
        error_exit $XDDCP_ERR_CODE_SSH_FAILURE
    elif [ 0 -ne $destRC -a ! -z "$remoteOutput" ]; then
        echo "INFO: Remote RC: $destRC Remote Error: $remoteOutput" >/dev/stderr
        error_print $destRC
        error_exit $XDDCP_ERR_CODE_SSH_ERROR
    elif [ 0 -ne $destRC ]; then
        echo "INFO: Remote operation failure, no cause detected" >/dev/stderr
        error_exit $XDDCP_ERR_CODE_SSH_ERROR
    fi
   # echo "remoteOutput=$remoteOutput"
   fi
}

#
# Perform a remote execution using a FIFO to capture stdout
#
function remote_exec_with_fifo {
    #echo "remote_exec Args: $@" >/dev/stderr
    local cmds="$1"
    local fifoPath="$2"
    local remoteHost="$3"
    local remoteUser="$4"

    # If a fifo exists, remove it
    if [ -e "$fifoPath" ]; then
	\rm -f $fifoPath
	rc=$?
	if [ 0 -ne $rc ]; then
	    echo "INFO: Unable to remove existing FIFO: $fifoPath"
	    error_exit $XDDCP_ERR_CODE_FIFO_ACCESS
	fi
    fi

    # Create a new fifo
    \mkfifo $fifoPath &>/dev/null
    rc=$?
    if [ 0 -ne $rc ]; then
	echo "INFO: Unable to create FIFO: $fifoPath"
	error_exit $XDDCP_ERR_CODE_FIFO_FAILED
    fi
    
    # Construct ssh options
    if [ ! -z "${remoteUser}" ]; then
        sshOpts="-q -o ServerAliveInterval 30 -l $remoteUser"
    fi

    # Local decl must be on seperate line so $? is correct
    ssh ${sshOpts} ${remoteHost} /bin/bash --login <<EOF > $fifoPath &
$cmds
wait
EOF
    rc=$?
    g_xddcpDestSSHPid=$!
    g_xddcpFifoPath=$fifoPath
    return $rc
}

#
# Return the file size
#
function get_file_size {
    #echo "get_file_size Args: $@" >/dev/stderr
    local filename=$1
    local remoteFlag=$2
    local host=$3
    local user=$4

    if [ 0 -eq "$remoteFlag" ]; then
        echo $($XDDCP_GETFILESIZE_EXE $filename)
    else
        cmd="$XDDCP_GETFILESIZE_EXE $filename"
        remote_exec "$cmd" "$host" "$user" "1"
    fi
}

#
# Return the destination side program
#
function get_destination_cmds {
    #echo "get_destination_cmds Args: $@" >/dev/stderr
    local destHost=${1}
    local destIP=${2}
    local destIfaces=${3}
    local destIfaceThreads=${4}
    local srcFile=${5}
    local destPath=${6}
    local totalBytes=${7}
    local e2ePort=${8}
    local dioFlag=${9}
    local forceFlag=${10}
    local serialOrderedFlag=${11}
    local recursionFlag=${12}
    local resumeFlag=${13}
    local verbosity=${14}
    local binaryDumpFlag=${15}

    # Options that aren't yet settable
    local srcHost=$(\hostname)
    
    # Construct transfer settings
    declare -i xfer=${XDDCP_DEFAULT_XFER_SIZE}
    declare -i numreqs=$((totalBytes/xfer))
    declare -i blocksize=1024
    declare -i reqsize=$((xfer/blocksize))

    # Other variables
    local srcBase=$(\basename $srcFile)
    local destQD="-queuedepth ${queueDepth}"

    # Construct the e2e destinations
    local e2eDestinations=""
    declare idx=0
    for iface in $destIfaces; do
	idx=$((idx+1))
	tcount=$(\echo $destIfaceThreads |cut -f $idx -d ' ')
	e2eDestinations="$e2eDestinations -e2e dest ${iface}:${e2ePort},${tcount}" 
    done
    if [ -z "$e2eDestinations" ]; then
	\echo "ERROR: No destination interfaces specified"
	error_exit $XDDCP_ERR_CODE_NO_REMOTE
    fi

    # Direct I/O option
    if [ 1 -eq $dioFlag ]; then
        local destDIO="-dio"
    fi

    # Thread ordering option
    local orderedOpt="-noordering"
    if [ 1 -eq $serialOrderedFlag ]; then
        orderedOpt="-serialordering"
    fi

    # Verbose option
    if [ 1 -eq $verbosity ]; then
        local verboseOpt="-verbose"
    fi

    # If the supplied destination is a directory, append the source file name
    local destination_base=$(\basename $destPath)
    if [ -d $destPath ]; then
          destination_base=$srcBase
    fi

    # binary timestamp dump
    if [ 1 -eq $binaryDumpFlag -o 2 -eq $verbosity ]; then
        local binaryDumpPrefix="xdd-${destHost}-${destination_base}-${XDDCP_DEFAULT_TIMESTAMP}"
    fi

    # if restart, get srcFile mod time
    if [ 1 -eq $resumeFlag ]; then
        local srcFileMtime=$(stat -c %Y $srcFile)
    fi
    
    cat <<EOF
# Ensure xdd is in the remote path
if [ "x${g_xddRemotePathAppend}" != "x" ] ; then
  export PATH=\${PATH}:${g_xddRemotePathAppend}
fi
\type ${XDDCP_XDD_EXE} &>/dev/null
if [ 0 -ne \$? ]; then
    echo "xdd binary is not in destination host PATH" >/dev/stderr
    exit ${XDDCP_ERR_CODE_XDD_NOT_FOUND}
fi

# Check that the correct version of XDD is available
dest_version=\$(${XDDCP_XDD_EXE} -version)
if [ "\$dest_version" != "$g_xddcpXddVersion" ]; then
    echo "XDD source and destionation version mismatch." >/dev/stderr
    exit ${XDDCP_ERR_CODE_VERSION_MATCH}
fi

# Path complement xdd so that iotracing can function
xdd_exe_path=\$(\\type -P ${XDDCP_XDD_EXE})

# Check that ports are available for binding (Linux only)
declare -i port_conflict=0
if [ "$(\uname)" = "Linux" ]; then
    \type $XDDCP_GETHOSTIP_EXE &>/dev/null
    hasIpTranslator=\$?
    if [ 1 -ne \$hasIpTranslator ]; then
        declare -i tcount_idx=0
        for iface in $destIfaces; do
            tcount_idx=\$((tcount+1))
                tcount=\$(\\echo $destIfaceThreads |cut -f \$tcount_idx -d ' ')
            iface_ip=\$($XDDCP_GETHOSTIP_EXE -d \$iface)
            e2eLB=$e2ePort
            e2eUB=\$((e2eLB+tcount))
#        echo "\$tcount_idx \$iface_ip \$e2eLB \$e2eUB" >>/tmp/bws
#        echo "netstat -nlt |grep \$iface_ip |cut -d : -f 2 |cut -d ' ' -f 1 |tr -d [:alpha:])" >>/tmp/bws
            used_ports=\$(\\netstat -nlt |grep \$iface_ip |cut -d : -f 2 |cut -d ' ' -f 1 |tr -d [:alpha:])
#        echo "Used ports: \$used_ports" >>/tmp/bws
            for p in \$used_ports; do
                if [ \$e2eLB -le \$p -a \$e2eUB -gt \$p ]; then
                    port_conflict=1
                    break
                fi
            done
        done
    fi
    # Use of force requested, so kill anything xdd that exists at destination.
    if [ 1 -eq $forceFlag ]; then
         pkill -9 -u ${USER} -U ${USER} -x xdd 2>/dev/null
         sleep $XDDCP_DEFAULT_NETWORK_CLEAR_SECS
    fi

    # If a port conflict exists, user may want to kill running XDD's and retry
    if [ 1 -eq \$port_conflict ]; then
        # Attempt to kill any running XDDs and re-check
        if [ 1 -eq $forceFlag ]; then
            xddpid=\$(\\ps -u \${USER} |grep xdd |grep -v grep |grep -v xddcp |cut -c-5)
            if [ ! -z "\$xddpid" ]; then
                kill \$xddpid 2>/dev/null
                sleep $XDDCP_DEFAULT_NETWORK_CLEAR_SECS
                kill -9 \$xddpid 2>/dev/null
                sleep $XDDCP_DEFAULT_NETWORK_CLEAR_SECS
            fi
        else
            echo "Requested port \$p is in use" >/dev/stderr
            exit ${XDDCP_ERR_CODE_DEST_PORT}
        fi

        tcount_idx=0
        for iface in $destIfaces; do
            tcount_idx+=1
            tcount=\$(\\echo $destIfaceThreads |cut -f \$tcount_idx -d ' ')
            e2eLB=$e2ePort
            e2eUB=\$((e2eLB+tcount))
            used_ports=\$(\\netstat -nlt |grep $iface |cut -d : -f 2 |cut -d ' ' -f 1 |tr -d [:alpha:])
            for p in \$used_ports; do
                if [ \$e2eLB -le \$p -a \$e2eUB -gt \$p ]; then
                    echo "Requested port \$p is in use" >/dev/stderr
                    exit ${XDDCP_ERR_CODE_DEST_PORT}
                fi
            done
        done
    fi
fi

# If the supplied destination is a directory, append the source file name
destination_file=$destPath
destination_base=\$(\\basename $destPath)
destination_dir=\$(\\dirname $destPath)
if [ -d $destPath ]; then
    destination_file=$destPath/$srcBase
    destination_base=$srcBase
    destination_dir=$destPath
fi

# If the filename uses a relative path, path complement it
path_char=\$(\\dirname \$destination_file |cut -c 1)
if [ "." = \$path_char ]; then
    default_dir=\$(\\pwd)
    destination_dir="\${default_dir}/\${destination_dir}"
    destination_file="\${default_dir}/\${destination_file}"
fi

# Create the log file name
destination_log_base="xdd-${destHost}-\${destination_base}-${XDDCP_DEFAULT_TIMESTAMP}.log"
destination_log="\${destination_dir}/\${destination_log_base}"

# Ensure destination is writable
if [ ! -d \$destination_dir ]; then
    echo "Destination directory does not exist: \${destination_dir}" >/dev/stderr
    exit ${XDDCP_ERR_CODE_DEST_DIR_NOT_XST} 
elif [ -d \$destination_dir -a ! -e \$destination_file -a ! -w \$destination_dir ]; then
    echo "Destination directory is not writable: \$destination_dir"
    exit ${XDDCP_ERR_CODE_DEST_DIR_NOT_WR}
elif [ -e \$destination_file -a ! -w \$destination_file ]; then
    echo "Destination target exists but is not writable: \$destination_file" >/dev/stderr
    exit ${XDDCP_ERR_CODE_DEST_TGT_NOT_WR}
fi

# Perform restart if necessary
destination_restart=""
if [ 1 -eq $resumeFlag ]; then
    # Ensure sufficient permissions exist to create restart cookie
    if [ ! -w \$destination_dir ]; then
        echo "Restart option requires write access to: \$destination_dir" >/dev/stderr
        exit ${XDDCP_ERR_CODE_DEST_DIR_NOT_WR}
    fi

    # Destination already sent restart file(s) to source which constructed global opt 
    # Add restart filename (cookie) to restart command
    restart_logfile="${g_RestartFileDir}/${g_filebaseTransferRst}"
    destination_restart="-restart file \${restart_logfile} ${g_dstRestartOpt}"
fi

# If insufficient permissions for the log exist, direct to HOME
if [ $verbosity -lt 1 ]; then
    destination_log=/dev/null
elif [ ! -w \$destination_dir -a -e \$destination_log -a ! -w \$destination_log ]; then
    echo "Logfile already exists and is not writable: \$destination_log" >/dev/stderr
    exit ${XDDCP_ERR_CODE_DEST_TGT_NOT_WR}
elif [ ! -w \$destination_dir -a ! -w \$destination_log ]; then
    home_dir_log="./\${destination_log_base}"
    if [ ! -w "./" ]; then
        echo "Could not create log file as \$destination_log or as \$home_dir_log"
        exit ${XDDCP_ERR_CODE_DEST_TGT_NOT_WR}
    fi
    echo "Warning: Writing log to: \$home_dir_log"
    destination_log=\$home_dir_log
fi
# Verbose option
  if [ 1 -eq $verbosity ]; then
        verboseopt="-verbose"
elif [ 2 -eq $verbosity ]; then
        verboseopt="-verbose -ts detailed -ts output \$(\\dirname \${destination_log})/$binaryDumpPrefix"
fi
if [ 1 -eq $binaryDumpFlag ]; then
	binary_dump_opts="-ts dump \$(\\dirname \${destination_log})/$binaryDumpPrefix"
fi

# Truncate the destination to the correct size if necessary
if [ -e \$destination_file ]; then
    cur_size=\$($XDDCP_GETFILESIZE_EXE \${destination_file} | cut -f 1 -d " ")
    if [ \$cur_size -gt $totalBytes ]; then
        $XDDCP_TRUNCATE_EXE -s $totalBytes \${destination_file}
    fi
fi

# XDD Command
#xdd_cmd="${XDDCP_IOTRACE_EXE} \${xdd_exe_path} -target \${destination_file} -op write -minall ${orderedOpt} \${verboseopt} \${binary_dump_opts} -bytes ${totalBytes} -reqsize $reqsize -e2e isdestination ${e2eDestinations} ${destDIO} \${destination_restart} -preallocate ${totalBytes} -stoponerror -output \${destination_log} -errout \${destination_log}"
xdd_cmd="${XDDCP_IOTRACE_EXE} \${xdd_exe_path} -target \${destination_file} -op write -minall ${orderedOpt} \${verboseopt} \${binary_dump_opts} -bytes ${totalBytes} -reqsize $reqsize -e2e isdestination ${e2eDestinations} ${destDIO} \${destination_restart} -preallocate ${totalBytes} -stoponerror > \${destination_log}"

# Log XDD Command
echo "Destination-side invocation: \${xdd_cmd}" > \${destination_log}

# Set iotrace log files location
export TRACE_LOG_LOC=\${destination_dir}

# Invoke XDD
\${xdd_cmd} >> \${destination_log} 2>&1 &

EOF
}

#
# Return the source side program
#
function get_source_cmds {
    #echo "get_source_cmds Args: $@" >/dev/stderr
    local destIfaces=${1}
    local srcFile=${2}
    local totalBytes=${3}
    local destIfaceThreads=${4}
    local e2ePort=${5}
    local srcDIOFlag=${6}
    local serialOrderedFlag=${7}
    local resumeFlag=${8}
    local verbosity=${9}
    local binaryDumpFlag=${10}

    # Construct XDD transfer settings
    xfer=${XDDCP_DEFAULT_XFER_SIZE}
    numReqs=$((totalBytes/xfer))
    blockSize=1024
    reqSize=$((xfer/blockSize))

    # Construct the e2e destinations
    local e2eDestinations=""
    declare idx=0
    for iface in $destIfaces; do
	idx=$((idx+1))
	tcount=$(\echo $destIfaceThreads |cut -f $idx -d ' ')
	e2eDestinations="$e2eDestinations -e2e dest ${iface}:${e2ePort},${tcount}" 
    done
    if [ -z "$e2eDestinations" ]; then
	echo "ERROR: No destination interfaces specified"
	error_exit $XDDCP_ERR_CODE_NO_REMOTE
    fi

    # Construct source XDD settings
    local srcBase=$(\basename ${srcFile})
    local srcQD="-queuedepth ${queueDepth}"
    local srcLog="xdd-$(\hostname)-${srcBase}-${XDDCP_DEFAULT_TIMESTAMP}.log"

    # Direct I/O option
    if [ 1 -eq $srcDIOFlag ]; then
        local srcDIO="-dio"
    fi

    # Thread ordering option
    local orderedOpt="-looseordering"
    if [ 1 -eq $serialOrderedFlag ]; then
        orderedOpt="-serialordering"
    fi

    # Verbose option
    if [ 1 -eq $verbosity ]; then
        local verboseOpt="-verbose"
    elif [ 2 -eq $verbosity ]; then
        local verboseOpt="-verbose -ts detailed -ts output xdd-$(\hostname)-${srcBase}-${XDDCP_DEFAULT_TIMESTAMP}"
    fi

    # binary timestamp dump option
    if [ 1 -eq $binaryDumpFlag ]; then
        local binaryDumpOpt="-ts dump xdd-$(\hostname)-${srcBase}-${XDDCP_DEFAULT_TIMESTAMP}"
    fi
    
    # Determine if output can be sent to log file
    local srcOutput="-output ${srcLog}"
    if [ ! -w "./" ]; then
        echo "WARNING:  Cannot create log file: ./$srcLog, logging output to stdout" >/dev/stderr
        sourceOutput=""
    fi

    # Build the command string
    cat <<EOF
# Ensure xdd is in the path
if [ "x${g_xddRemotePathAppend}" != "x" ] ; then
  export PATH=\${PATH}:${g_xddRemotePathAppend}
fi
\type ${XDDCP_XDD_EXE} &>/dev/null
if [ 0 -ne \$? ]; then
    echo "xdd binary is not in the source host PATH"
    exit ${XDDCP_ERR_CODE_XDD_NOT_FOUND}
fi

# Check that the correct version of XDD is available
source_version=\$(${XDDCP_XDD_EXE} -version)
if [ "\$source_version" != "$g_xddcpXddVersion" ]; then
    echo "XDD source and destionation version mismatch."
    exit ${XDDCP_ERR_CODE_VERSION_MATCH}
fi

# Path complement xdd so that iotracing can function
xdd_exe_path=\$(\\type -P ${XDDCP_XDD_EXE})

# Ensure source side file exists
if [ ! -r "${srcFile}" ]; then
    echo "ERROR: Cannot read source file: ${srcFile}"
    exit ${XDDCP_ERR_CODE_SRC_XST}
fi

# Add the command to the log file
if [ $verbosity -gt 0 ]; then
    src_log="xdd-\$(\hostname)-${srcBase}-${XDDCP_DEFAULT_TIMESTAMP}.log"
else
    src_log=/dev/null
fi

xdd_cmd="${XDDCP_IOTRACE_EXE} \${xdd_exe_path} -targets 1  ${srcFile} -op read -minall ${orderedOpt} ${verboseOpt} ${binaryDumpOpt} -bytes ${totalBytes} -reqsize ${reqSize} -e2e issource ${e2eDestinations} ${srcDIO} ${g_srcRestartOpt} -output \${src_log} -hb ${XDDCP_DEFAULT_HEARTBEAT_SECS} -hb pct -stoponerror"

# Set iotrace log files location
export TRACE_LOG_LOC=\${PWD}

# Construct local transport endpoint
echo "Source-side invocation: \${xdd_cmd}" > \${src_log}
\${xdd_cmd}

src_xdd_rc=\$?
if [ \${src_xdd_rc} -ne 0 ]; then
    exit ${XDDCP_ERR_CODE_XFER_FAIL}
fi
EOF
}

#
# Create a directory on the destination side
#
function create_destination_directory {
    local destPath=${1}
    local remoteFlag=${2}
    local destHost=${3}
    local destIP=${4}
    local destUser=${5}

    # Create destination commands
    local destCmds="mkdir -v -p $destPath"

    # Execute destination side directory creation
    local destResult=""
    local execRC=1
    if [ 1 -eq ${remoteFlag} ]; then
        # resolve remote host name/ip
        local host=""
        if [ ! -z "${destIP}" ]; then
                host="${destIP}"
        elif [ ! -z "${destHost}" ]; then
                host="${destHost}"
        else
          echo "scripting error in create_destination_directory, fix it!" >/dev/stderr
        fi
        destResult=$(remote_exec "${destCmds}" "${host}" "${destUser}" "1")
        execRC=$?
    else
        destResult=$(local_exec "${destCmds}")
        execRC=$?
    fi

    # Error handling
    if [ 0 -ne $execRC ]; then
        error_exit $execRC
    fi
    return 0
}

#
# Start XDD on the destination side
#
function start_destination_xdd {
    #echo "start_destination_xdd Args: $@" >/dev/stderr
    local srcPath=${1}
    local destPath=${2}
    local totalBytes=${3}
    local queueDepth=${4}
    local e2ePort=${5}
    local dioFlag=${6}
    local forceFlag=${7}
    local orderedFlag=${8}
    local recursionFlag=${9}
    local resumeFlag=${10}
    local verbosity=${11}
    local binaryDumpFlag=${12}
    local remoteFlag=${13}
    local destHost=${14}
    local destIP=${15}
    local destUser=${16}
    local destIfaces=${17}

    # Get destination commands
    local execRC=1
    local destResult=""
    debugPrint "start_destination_xdd: before call to get_destination_cmds"
    local destCmds=$(get_destination_cmds "$destHost" "$destIP" "$destIfaces" \
        "$queueDepth" "$srcPath" "$destPath" \
        "$totalBytes" "$e2ePort" "$dioFlag" "$forceFlag" "$orderedFlag" \
        "$recursionFlag" "$resumeFlag" "$verbosity" "$binaryDumpFlag")
    execRC=$?
    if [ 0 -ne $execRC ]; then
        error_exit $execRC
    fi
    debugPrint "start_destination_xdd: after call to get_destination_cmds"

    # Execute destination side commands
    if [ 1 -eq ${remoteFlag} ]; then
       # remote_exec_with_fifo "${destCmds}" "${XDDCP_DEFAULT_FIFO_PATH}" "${destIP}" "${destUser}"
       debugPrint "start_destination_xdd: before call to remote_exec. destIP=${destIP} destUser=${destUser}"
        remote_exec "${destCmds}" "${destIP}" "${destUser}" "1"
        execRC=$?
    else
	error_exit $UNKNOWN
        #destResult=$(local_exec "${destCmds}")
        #execRC=$?
    fi

    # Remove the fifo, as it is no longer needed
    #rm -f ${XDDCP_DEFAULT_FIFO_PATH}

    return $execRC
}

#
# Start XDD on the source side
#
function start_source_xdd {
    #echo "start_source_xdd Args: $@" >/dev/stderr
    local path=${1}
    local totalBytes=${2}
    local queueDepth=${3}
    local e2ePort=${4}
    local dioFlag=${5}
    local orderedFlag=${6}
    local resumeFlag=${7}
    local verbosity=${8}
    local binaryDumpFlag=${9}
    local destIfaces=${10}
    local remoteFlag=${11}
    local srcHost=${12}
    local srcUser=${13}

    # Get source commands
    local execRC=1
    srcCmds=$(get_source_cmds "${destIfaces}" "${path}" "${totalBytes}" \
	"${queueDepth}" "${e2ePort}" "${dioFlag}" "${orderedFlag}" \
	"${resumeFlag}" "${verbosity}" "${binaryDumpFlag}" )
    execRC=$?
    if [ 0 -ne $execRC ]; then
        error_exit $execRC
    fi

    # Execute source commands
    if [ 1 -eq ${remoteFlag} ]; then
        remote_exec "${srcCmds}" "${srcHost}" "${srcUser}" "2"
        execRC=$?
    else
        local_exec "${srcCmds}"
        execRC=$?
    fi

    return $execRC
}

# get restart file from destination directory
function get_destination_restart_files {
	local srcPath=${1}
	local destPath=${2}
	local destHost=${3}
	local destIP=${4}
	local destUser=${5}

        local dataDir=$PWD
	# check dataDir for writability
	if [ ! -d ${dataDir} ] || [ ! -w ${dataDir} ]; then
		echo "INFO: Can not write to ${dataDir}. Skipping get_destination_restart_files." >/dev/stderr
		return 1
	fi
        local host=""
	if [ ! -z "${destIP}" ]; then
		host="${destIP}"
        elif [ ! -z "${destHost}" ]; then
		host="${destHost}"
        else
          echo "scripting error in get_destination_restart_files, fix it!" >/dev/stderr
	fi
        # Save top level destination directory for restart cookie files
        local dstpath="$destPath"
        local dfType=$(ssh $host \stat -c %F ${destPath} 2>/dev/null)
        if [ "$dfType" = "" -o "$dfType" = "regular file" -o "$dfType" = "regular empty file" ]; then
              dstpath=$(\dirname ${destPath})
        fi
        if [ -d "${srcPath}" ]; then
          srcbase=$(\basename ${srcPath})
          g_RestartFileDir="${dstpath}/${srcbase}"
        elif [ -f "${srcPath}" ]; then
          g_RestartFileDir="${dstpath}"
        else
          echo "INFO: Cannot determine g_RestartFileDir. Skipping get_destination_restart_files." >/dev/stderr
          return 1
        fi
        debugPrint "srcPath=$srcPath g_RestartFileDir=$g_RestartFileDir"

	# get/copy destination restart file(s) from destination to source host
 	(scp ${USER}@${host}:${g_RestartFileDir}/${g_filebaseTransferRst}\* ${PWD}) > ${g_devOut} 2>&1
}

# If restart, get file transfer history from destination if it exists.
function get_file_transfer_history {
    local srcPath=${1}
    local destPath=${2}
    local destHost=${3}
    local destIP=${4}
    local destUser=${5}

    # If restart, read in table(s) of transfer completed and/or in progress
    let "g_currentFileIndex = -1"
      get_destination_restart_files "${srcPath}" "${destPath}" "${destHost}" "${destIP}" "${destUser}"
      local srcRestartFile="${PWD}/$g_completeTransfersRst"
      if [ -e "$srcRestartFile" -a -s "$srcRestartFile" ]; then
      if [ -s "$srcRestartFile" ]; then
        debugPrint "Reading restart files from ${g_RestartFileDir}:"
        while read line
        do
          let "g_currentFileIndex += 1"
          g_srcFilePath[$g_currentFileIndex]=$(echo "$line" | cut -f 1 -d " ")
          g_srcFileMtime[$g_currentFileIndex]=$(echo "$line" | cut -f 2 -d " ")
          g_srcFileOffset[$g_currentFileIndex]=$(echo "$line" | cut -f 3 -d " ")
          debugPrint "$g_currentFileIndex: ${g_srcFilePath[$g_currentFileIndex]} ${g_srcFileMtime[$g_currentFileIndex]} ${g_srcFileOffset[$g_currentFileIndex]}"
        done < ${srcRestartFile}
        #mv ${srcRestartFile} "${srcRestartFile}.${retries}"
        rm -f  ${srcRestartFile}
      fi
      fi
      # stick it at the end; restart because offset < file size
      # this is trapped accordingly in transfer_file
      local srcRestartFile="${PWD}/$g_currentTransferRst"
      if [ -e "$srcRestartFile" ]; then
      if [ -s "$srcRestartFile" ]; then
        let "g_currentFileIndex += 1"
        g_srcFilePath[$g_currentFileIndex]=$(\cat $srcRestartFile | cut -f 1 -d " ")
        g_srcFileMtime[$g_currentFileIndex]=$(\cat $srcRestartFile | cut -f 2 -d " ")
        g_srcFileOffset[$g_currentFileIndex]=$(\cat $srcRestartFile | cut -f 3 -d " ")
        debugPrint "$g_currentFileIndex: ${g_srcFilePath[$g_currentFileIndex]} ${g_srcFileMtime[$g_currentFileIndex]} ${g_srcFileOffset[$g_currentFileIndex]}"
        # More surgical than the forceFlag option, which does not always seem to work
        # If dstKillpid no longer exist, no harm done.
        local dstKillpid=$(\cat $srcRestartFile | cut -f 5 -d " ")
        local cmd="\kill -9 ${dstKillpid}"
        remote_exec "${cmd}" "${destHost}" "${destUser}" "0"
      fi
        #mv ${srcRestartFile} "${srcRestartFile}.${retries}"
        rm -f  ${srcRestartFile}
      fi
    # Remove source side restart files. Always get fresh copies from destination.
    # Source will start with $g_currentFileIndex if not complete, or next file if complete
    # Completion with a file is needed if g_srcFileOffset < filesize. Determined in transfer_file

    return 0
} 

function check_if_file_transferred_previously {
  #Locate input file in g_srcFilePath list, check mod time and return index
  #return index. If new file, add it to list and transfer
  # prev assumes ordered list or tree traversal, speeds up find
  local path=${1} 

  local found
  local n

  let "found = -1"
  for (( n=0; n <= g_currentFileIndex; n++ ))
  do 
   if [ "$path" != "${g_srcFilePath[$n]}" ]; 
   then
    continue
   fi
   let "found = $n"
   break
 done
 # If new file, add to end of list and increment grand total
 # If new file transfer aborts, this becomes the new restart file
 if [ 0 -gt "$found" ]
 then
   let "g_currentFileIndex += 1"
   g_srcFilePath[$g_currentFileIndex]=$path
   local cutline=$(stat -c "%Y %s" $path)
   #g_srcFileMtime[$g_currentFileIndex]=$(echo "$cutline" | cut -f 1 -d " ")
   g_srcFileMtime[$g_currentFileIndex]="0"
   g_srcFileOffset[$g_currentFileIndex]="0"
   let "found = $g_currentFileIndex"
 fi
 return "$found"
}

#
# Perform transfer when the source spec is a file containing a list of files
#
function transfer_file_list {
    local srcFileList=${1}
    local srcHost=${2}
    local srcUser=${3}
    local srcRemoteFlag=${4}
    local srcDIOFlag=${5}
    local srcOrderedFlag=${6}
    local destPath=${7}
    local destHost=${8}
    local destIP=${9}
    local destUser=${10}
    local destRemoteFlag=${11}
    local destDIOFlag=${12}
    local destOrderedFlag=${13}
    local totalBytes=${14}
    local queueDepth=${15}
    local e2ePort=${16}
    local fileSizeFlag=${17}
    local forceFlag=${18}
    local resumeFlag=${19}
    local verbosity=${20}
    local binaryDumpFlag=${21}

    # Perform precondition checks for file list transfers
    check_file_list_preconditions "${srcFileList}" "1" "${fileSizeFlag}" \
	"${resumeFlag}"
    rc=$?
    if [ 0 -ne $rc ]; then
	error_exit $rc
    fi

    # Get all of the source specs and path complement
    local srcFileSpecDir=$(\dirname ${srcFileList})
    local fileNames=""
    for name in $(\cat ${srcFileList}); do
	local pathChar=$(\dirname $name |cut -c 1)
	if [ "." = "$pathChar" ]; then
	    fileNames="$fileNames ${srcFileSpecDir}/${name}"
	else
	    fileNames="$fileNames $name"
	fi
    done

    # Set the path modified file names as the source specs
    srcFileSpecList="$fileNames"
    debugPrint "transfer_file_list: srcFileSpecList=$srcFileSpecList"

    # Process all source file specs
    for srcFileSpec in ${srcFileSpecList}; do

	timerbeg "5"
	# Modify the destination path for file list transfers
	local srcFileName=$(\basename ${srcFileSpec})
	destFileSpec=${destPath}/${srcFileName}

        # Parse the source side spec
        srcRemoteFlag=0

	#Transfer the file
	transfer_file "${srcFileSpec}" "${srcHost}" "${srcUser}" \
	    "${srcRemoteFlag}" "${srcDIOFlag}" "${srcOrderedFlag}" \
	    "${destFileSpec}" "${destHost}" "${destIP}" "${destUser}" \
	    "${destRemoteFlag}" "${destDIOFlag}" "${destOrderedFlag}" \
	    "${totalBytes}" "${queueDepth}" "${e2ePort}" \
	    "${fileSizeFlag}" "${forceFlag}" "${resumeFlag}" \
	    "${verbosity}" "${binaryDumpFlag}"
	    
	rc=$?
	if [ 0 -ne $rc ]; then
	    echo "INFO: Failure while transferring ${srcFileSpec} to ${destFileSpec}"
            return $rc
	fi
        timerend "5" "total time to transfer file ${srcFileSpec}"
    done
    return 0
}

#
# Perform transfer when the source spec is a file containing a list of 
# fully qualified paths of source/destination files
#
function transfer_recursive_file_list {
    local srcFileList=${1}
    local srcHost=${2}
    local srcUser=${3}
    local srcRemoteFlag=${4}
    local srcDIOFlag=${5}
    local srcOrderedFlag=${6}
    local destPath=${7}
    local destHost=${8}
    local destIP=${9}
    local destUser=${10}
    local destRemoteFlag=${11}
    local destDIOFlag=${12}
    local destOrderedFlag=${13}
    local totalBytes=${14}
    local queueDepth=${15}
    local e2ePort=${16}
    local fileSizeFlag=${17}
    local forceFlag=${18}
    local resumeFlag=${19}
    local verbosity=${20}
    local binaryDumpFlag=${21}

    # Perform precondition checks for file list transfers
    check_file_list_preconditions "${srcFileList}" "1" "${fileSizeFlag}" \
	"${resumeFlag}"
    rc=$?
    if [ 0 -ne $rc ]; then
	error_exit $rc
    fi

    # Parse the source side spec
    srcRemoteFlag=0

    let "FileIndex = -1"
    while read line
    do
      let "FileIndex += 1"
      srcFileSpec=$(echo "$line" | cut -f 1 -d " ")
      destFileSpec=$(echo "$line" | cut -f 2 -d " ")
      debugPrint "transfer_recursive_file_list: $FileIndex: before call to transfer_file: ${srcFileSpec} to ${destFileSpec}"
      #Transfer the file
	transfer_file "${srcFileSpec}" "${srcHost}" "${srcUser}" \
	    "${srcRemoteFlag}" "${srcDIOFlag}" "${srcOrderedFlag}" \
	    "${destFileSpec}" "${destHost}" "${destIP}" "${destUser}" \
	    "${destRemoteFlag}" "${destDIOFlag}" "${destOrderedFlag}" \
	    "${totalBytes}" "${queueDepth}" "${e2ePort}" \
	    "${fileSizeFlag}" "${forceFlag}" "${resumeFlag}" \
	    "${verbosity}" "${binaryDumpFlag}"
	rc=$?
	if [ 0 -ne $rc ]; then
	    echo "INFO: Failure while transferring ${srcFileSpec} to ${destFileSpec}"
            return $rc
	fi
        debugPrint "transfer_recursive_file_list: $FileIndex: transferred ${srcFileSpec} to ${destFileSpec}"
    done < ${srcFileList}

    return 0
}

#
# Make file list from a recursive path for recursive transfer
# Create destination directories too
# Do it once. Otherwise restarts could get very expensive
#
function transfer_recursive_path_setup {
    local srcPath=${1}
    local srcHost=${2}
    local srcUser=${3}
    local srcRemoteFlag=${4}
    local srcDIOFlag=${5}
    local srcOrderedFlag=${6}
    local destPath=${7}
    local destHost=${8}
    local destIP=${9}
    local destUser=${10}
    local destRemoteFlag=${11}
    local destDIOFlag=${12}
    local destOrderedFlag=${13}
    local totalBytes=${14}
    local queueDepth=${15}
    local e2ePort=${16}
    local fileSizeFlag=${17}
    local forceFlag=${18}
    local resumeFlag=${19}
    local verbosity=${20}
    local binaryDumpFlag=${21}

    # Perform precondition checks for file list transfers
    check_file_list_preconditions "${srcFileList}" "1" "${fileSizeFlag}" \
	"${resumeFlag}"
    rc=$?
    if [ 0 -ne $rc ]; then
	error_exit $rc
    fi

    # If the source is a directory, create it on the destination
    if [ -d "$srcPath" ]; then
	# Determine the corresponding destination name for the source name
	# Modify the destination path for file list transfers
	local srcName=$(\basename $srcPath)
	local destFileSpec=${destPath}/${srcName}
	create_destination_directory "${destFileSpec}" "${destRemoteFlag}" \
                                  "${destHost}" "${destIP}" "${destUser}"
	rc=$?
	if [ 0 -ne $rc ]; then
	    echo "INFO: Failure while creating directory ${destFileSpec}"
	    error_exit $rc
	fi
        debugPrint "transfer_recursive_path_setup: srcPath=${srcPath} created destPath=${destFileSpec}"
    fi

    # Get names from source spec, if its a directory, transfer its contents recursively
    # Otherwise, just transfer the file and end
    for entry in $(/bin/ls $srcPath); do
	local srcFileSpec=$srcPath/$entry
	local destFileSpec=$destPath/$(\basename $srcPath)
	if [ -d "$srcFileSpec" ]; then
	    transfer_recursive_path_setup "${srcFileSpec}" "${srcHost}" "${srcUser}" \
		"${srcRemoteFlag}" "${srcDIOFlag}" "${srcOrderedFlag}" \
		"${destFileSpec}" "${destHost}" "${destIP}" "${destUser}" \
		"${destRemoteFlag}" "${destDIOFlag}" "${destOrderedFlag}" \
		"${totalBytes}" "${queueDepth}" "${e2ePort}" \
		"${fileSizeFlag}" "${forceFlag}" "${resumeFlag}" \
		"${verbosity}" "${binaryDumpFlag}"
	else

	    #local destFileSpec=$destPath/$(\basename $entry)
		echo "${srcFileSpec} ${destFileSpec}" >> "${g_fileRecursiveList}"
	fi
    done
    return  0
}
#
# Perform transfer for a single file
#
function transfer_file {
    #echo "transfer_file Args: $@" >/dev/stderr
    local srcFileSpec=${1}
    local srcHost=${2}
    local srcUser=${3}
    local srcRemoteFlag=${4}
    local srcDIOFlag=${5}
    local srcOrderedFlag=${6}
    local destFileSpec=${7}
    local destHost=${8}
    local destIP=${9}
    local destUser=${10}
    local destRemoteFlag=${11}
    local destDIOFlag=${12}
    local destOrderedFlag=${13}
    local totalBytes=${14}
    local queueDepth=${15}
    local e2ePort=${16}
    local fileSizeFlag=${17}
    local forceFlag=${18}
    local resumeFlag=${19}
    local verbosity=${20}
    local binaryDumpFlag=${21}

    # Check the transfer preconditions
    check_transfer_preconditions "${srcFileSpec}" "${destFileSpec}" \
	"${srcRemoteFlag}" "${destRemoteFlag}" "${srcDIOFlag}" \
	"${destDIOFlag}" "${fileSizeFlag}" "${totalBytes}"

      timerbeg "1"

      timerbeg "3"
      check_if_file_transferred_previously "${srcFileSpec}"
      local fileIndex=$?
      timerend "3" "check_if_file_transferred_previously"
      debugPrint "transfer_file: after call to check_if_file_transferred_previously"

      timerbeg "2"
    # Determine the source file size, modification time
    if [ 0 -eq $fileSizeFlag -o 1 -eq $resumeFlag ]; then
        local cutline="$(get_file_size ${srcFileSpec} \
            ${srcRemoteFlag} ${srcHost} ${srcUser})"
             totalBytes=$(\echo "$cutline" | cut -f 1 -d " ")
        local lastMtime=$(\echo "$cutline" | cut -f 2 -d " ")
    fi
    # Check here to see if restart requested; coordinated function
     g_srcRestartOpt=""
     g_dstRestartOpt=""
    if [ 1 -eq $resumeFlag ]; then
      # Check to see if restart really needed
      if [ ${g_srcFileOffset[$fileIndex]} -eq $totalBytes -a \
           ${g_srcFileMtime[$fileIndex]} -eq $lastMtime ]; then
        echo "File: ${g_srcFilePath[$fileIndex]} already transferred"  >/dev/stderr
	# Signal success
	rc=0
        # Increment the number of transfers
	g_transferCount=$((g_transferCount+1))
	timerend "1" "check if restart needed for ${g_srcFilePath[$fileIndex]}"
        return
      else
        # TO_DO: If source file messed with since start of previous transfer, start over
        # For now, print an informative message...
        if [ ${g_srcFileMtime[$fileIndex]} -ne $lastMtime -a \
        0 -ne ${g_srcFileMtime[$fileIndex]} ]; then
        #    g_srcFileOffset[$fileIndex]="0"
        #    g_srcFileMtime[$fileIndex]="$lastMtime"
        #debugPrint "File: ${g_srcFilePath[$fileIndex]} modified since previous transfer, re-transmitting entire file"
        echo "Source file: ${g_srcFilePath[$fileIndex]} modified since previous transfer, skip " >/dev/stderr
	# Signal success
	rc=0
        # Increment the number of transfers
	g_transferCount=$((g_transferCount+1))
	timerend "1" "check if restart needed for ${g_srcFilePath[$fileIndex]}"
        return
        fi
        # Got here because restart really needed, from scratch or partial
        g_srcFileMtime[$fileIndex]="$lastMtime"
        g_srcRestartOpt="-restart enable -restart offset ${g_srcFileOffset[$fileIndex]}"
        g_dstRestartOpt="-restart enable -restart offset ${g_srcFileOffset[$fileIndex]} -e2e srcpath ${g_srcFilePath[$fileIndex]} ${g_srcFileMtime[$fileIndex]} "
      fi
    fi
	timerend "2" "Hi there"
    # If we are performing multiple transfers, need to wait for the destination side to hang up
    if [ 0 -ne $g_transferCount ]; then
        timerbeg "7"
        sleep $XDDCP_DEFAULT_NETWORK_SLEEP_SECS
        timerend "7" "waiting for destination to hang up from previous transfer"
    fi

    # Hard code the recursive flag
    local RFlag=0
    debugPrint "transfer_file: before call to start_destination xdd"
    # Start destination-side XDD (also sets resume offset if needed)
    start_destination_xdd "${srcFileSpec}" "${destFileSpec}" "${totalBytes}" \
        "${queueDepth}" "${e2ePort}" "${destDIOFlag}" "${forceFlag}" \
        "${destOrderedFlag}" "${RFlag}" "${resumeFlag}" \
	"${verbosity}" "${binaryDumpFlag}" \
	"${destRemoteFlag}" "${destHost}" "${destIP}" "${destUser}" "${g_destIfaces}"
    destRC=$?
    debugPrint "transfer_file: after call to start_destination xdd"

    # Continue if the destination started correctly
    if [ 0 -eq $destRC ]; then
        # Wait to ensure the destination side has setup network and accepting
        timerbeg "6"
        sleep $XDDCP_DEFAULT_NETWORK_SLEEP_SECS
        timerend "6"

        # Start source-side XDD
	start_source_xdd "${srcFileSpec}" "${totalBytes}" \
            "${queueDepth}" "${e2ePort}" "${srcDIOFlag}" \
            "${srcOrderedFlag}" "${resumeFlag}" \
	    "${verbosity}" "${binaryDumpFlag}" "${g_destIfaces}" \
            "${srcRemoteFlag}" "${srcHost}" "${srcUser}"
	srcRC=$?

	# Wait on the destination side
	wait
	destRC=$?

	# Increment the transfer count if the source completed successfully
	if [ 0 -ne $destRC ]; then
	    rc=$destRC
	    echo "INFO: Destination-side XDD exited with an error: $destRC" >/dev/stderr
	    echo "INFO: Source-side XDD exited with code: $srcRC" >/dev/stderr
	elif [ 0 -ne $srcRC ]; then
	    rc=$srcRC
	    echo "INFO: Source-side XDD exited with an error: $srcRC" >/dev/stderr
	else
	    # Signal success
	    rc=0
            echo "INFO: #$g_transferCount: $srcFileSpec transfer completed" >/dev/stderr
            # Increment the number of transfers
	    g_transferCount=$((g_transferCount+1))
	fi
    else
	rc=$destRC
	echo "INFO: Destination-side XDD exited with an error during launch: $destRC" >/dev/stderr
    fi
 
    return $rc
}

#
# Fetches the binary ts dump, calculates running bandwidth
#    during the transfer, and plots the xfer if gnuplot is available.
#
function post_transfer_analysis {
	local srcPath=${1}
	local srcHost=$(\hostname -s)
	local srcUser=${3}
	local destPath=${4}
	local destHost=${5}
	local destIP=${6}
	local destUser=${7}
	local windowSize=${8}
	local kernelTrace=${9}

	# where the timestamp dumps should be right now
	local srcBase=$(\basename $srcPath)
	local dstBase=$(\basename $destPath)
        # If the supplied destination is a directory, append the source file name
        if [ -d $destPath ]; then
          dstBase=$srcBase
        fi
	local srcBinDump="xdd-$(\hostname)-${srcBase}-${XDDCP_DEFAULT_TIMESTAMP}.target.0000.bin"
	local dstBinDump="xdd-${destHost}-${dstBase}-${XDDCP_DEFAULT_TIMESTAMP}.target.0000.bin"
	local dstCsvFile="xdd-${destHost}-${dstBase}-${XDDCP_DEFAULT_TIMESTAMP}.target.0000.csv"
	local dstLogFile="xdd-${destHost}-${dstBase}-${XDDCP_DEFAULT_TIMESTAMP}.log"

	# where our data will be stored afterwards
	local dataPrefix="xdd-${srcHost}_to_${destHost}_${srcBase}_${XDDCP_DEFAULT_TIMESTAMP}"
	local dataDir="."
 	local myLogFile="${dataDir}/ANALYSIS_${dataPrefix}.log"
 	local tsPlotPrefix="${dataDir}/ANALYSIS_${dataPrefix}"

	echo "Running post transfer analysis... "

	# check dataDir for writability
	if [ ! -d ${dataDir} ] || [ ! -w ${dataDir} ]; then
		echo "INFO: Can not write to ${dataDir}.  Skipping analysis." >/dev/stderr
		return 1
	fi

	# print a helpful tidbit to the logfile
	echo "To change the sliding window size without rerunning the transfer, run:" >> ${myLogFile}
	echo "    $XDDCP_READTSDUMPS_EXE -t [window_size] -o plot_prefix src_${srcHost}.bin dest_${destHost}.bin" >> ${myLogFile}
	echo "    gnuplot plotit" >> ${myLogFile}
	echo "" >> ${myLogFile}

	# get/copy destination bin file from destination to source host
	local destRC=""
	if [ ! -z "${destUser}" ]; then
		sshOpts="-q -l $remoteUser"
	fi
	(ssh ${sshOpts} ${destIP} /bin/bash --login <<EOF
# If the supplied destination is a directory, append the source file name
destination_file=${destPath}
destination_dir=\$(\\dirname ${destPath})
if [ -d ${destPath} ]; then
	destination_file=${destPath}/${srcBase}
	destination_dir=${destPath}
fi
# If the filename uses a relative path, path complement it
path_char=\$(\\dirname \$destination_file |cut -c 1)
if [ "." = \$path_char ]; then
	destination_dir="\$(/bin/pwd)/\${destination_dir}"
fi
# If insufficient permissions for the log exist, direct to HOME
if [ ! -w \$destination_dir ]; then
	destination_dir="./"
fi
# send the file back through cpio
cd \${destination_dir}
ls ${dstBinDump} | /bin/cpio -o 2>/dev/null
EOF
) | /bin/cpio -i >> ${myLogFile} 2>&1
	destRC=$?

	# get/copy destination log file from destination to source host
        (ssh ${sshOpts} ${destIP} /bin/bash --login <<EOF
# Really after destination log file which should be here by all previous checks
# If the supplied destination is a directory, append the source file name
destination_file=${destPath}
destination_dir=\$(\\dirname ${destPath})
if [ -d ${destPath} ]; then
        destination_file=${destPath}/${srcBase}
        destination_dir=${destPath}
fi
# If the filename uses a relative path, path complement it
path_char=\$(\\dirname \$destination_file |cut -c 1)
if [ "." = \$path_char ]; then
        destination_dir="\$(/bin/pwd)/\${destination_dir}"
fi
# If insufficient permissions for the log exist, direct to HOME
if [ ! -w \$destination_dir ]; then
        destination_dir="./"
fi
# send the file back through cpio
cd \${destination_dir}
ls ${dstLogFile} | /bin/cpio -o 2>/dev/null
EOF
) | /bin/cpio -i >> ${myLogFile} 2>&1

        # get/copy destination timestamp csv file from destination to source host
        (ssh ${sshOpts} ${destIP} /bin/bash --login <<EOF
# Really after destination log file which should be here by all previous checks
# If the supplied destination is a directory, append the source file name
destination_file=${destPath}
destination_dir=\$(\\dirname ${destPath})
if [ -d ${destPath} ]; then
        destination_file=${destPath}/${srcBase}
        destination_dir=${destPath}
fi
# If the filename uses a relative path, path complement it
path_char=\$(\\dirname \$destination_file |cut -c 1)
if [ "." = \$path_char ]; then
        destination_dir="\$(/bin/pwd)/\${destination_dir}"
fi
# If insufficient permissions for the log exist, direct to HOME
if [ ! -w \$destination_dir ]; then
        destination_dir="./"
fi
# send the file back through cpio
cd \${destination_dir}
ls ${dstCsvFile} | /bin/cpio -o 2>/dev/null
EOF
) | /bin/cpio -i >> ${myLogFile} 2>&1

	# get/copy destination iotrace_data.out file from destination to source host
	if [ 1 -eq $kernelTrace ]; then
        (ssh ${sshOpts} ${destIP} /bin/bash --login <<EOF
# Really after destination log file which should be here by all previous checks
# If the supplied destination is a directory, append the source file name
destination_file=${destPath}
destination_dir=\$(\\dirname ${destPath})
if [ -d ${destPath} ]; then
        destination_file=${destPath}/${srcBase}
        destination_dir=${destPath}
fi
# If the filename uses a relative path, path complement it
path_char=\$(\\dirname \$destination_file |cut -c 1)
if [ "." = \$path_char ]; then
        destination_dir="\$(/bin/pwd)/\${destination_dir}"
fi
# If insufficient permissions for the log exist, direct to HOME
if [ ! -w \$destination_dir ]; then
        destination_dir="./"
fi
# send the file back through cpio
cd \${destination_dir}
ls iotrace_data*out | /bin/cpio -o 2>/dev/null
EOF
) | /bin/cpio -i >> ${myLogFile} 2>&1
fi
	destRC=$?
	if [ 0 -ne $destRC ]; then
		echo "INFO: Failed to copy iotrace_data.pid.out over ssh.  Skipping analysis" >/dev/stderr
		return 1
	fi

	# read the tsdumps and plot output
	if [ 1 -eq $kernelTrace ]; then
        # Set iotrace log files location
          export TRACE_LOG_LOC=\${PWD}
	  $XDDCP_READTSDUMPS_EXE -t ${windowSize} -k -o ${tsPlotPrefix} ${srcBinDump} ${dstBinDump} >> ${myLogFile} 2>&1
	else
	  $XDDCP_READTSDUMPS_EXE -t ${windowSize}    -o ${tsPlotPrefix} ${srcBinDump} ${dstBinDump} >> ${myLogFile} 2>&1
	fi
	if [ 0 -ne $? ]; then
		echo "INFO: Failed to read timestamp dumps with prefix ${dataPrefix} in ${dataDir}.  Skipping analysis" >/dev/stderr
		return 1
	fi

	echo "done"
}

#
# XDDCP Main
#
function xddcp_main {
    #echo "main Args: $@"
    #
    # Install necessary signal handlers
    #
    # Note: We still need to pass the signal thru for Posix compliance.  See
    #  http://www.cons.org/cracauer/sigint.html
    #
    trap 'handle_signal_common 2; trap 2; echo "sending 2"; kill -2 $$' 2 
    trap 'handle_signal_common 3; trap 3; echo "sending 3"; kill -3 $$' 3 
    trap 'handle_signal_common 15; trap 15; echo "sending 15"; kill -15 $$' 15
    trap exit

    # Print a helpful message if user is just typing command to get syntax
    if [ "$1" = "-h" ]; then
        print_usage
        return 0
    elif [ $# -lt 2 ]; then
        echo "usage: $0 [OPTION] /full_path/source_file destination_host:/full_path/destination_file [bytes_to_transfer]"
        echo "Try '$0 -h' for more information."
        return $XDDCP_ERR_CODE_INVALID_ARGS
    fi

    # Parse options
    destDIOFlag=0
    destOrderedFlag=0
    e2ePort=$XDDCP_DEFAULT_E2E_PORT
    fileListFlag=0
    fileListFile=""
    forceFlag=1
    queueDepth=$XDDCP_DEFAULT_QUEUE_DEPTH
    recursiveFlag=0
    retryCount=1
    resumeFlag=0
    srcDIOFlag=0
    srcOrderedFlag=0
    sshOption=$XDDCP_DEFAULT_SSH_PSEUDO_TERMINAL_OPT
    verbosity=0
    binaryDumpFlag=0
    kernelTraceFlag=0
    windowSize=0
    g_timerFlag=0
    g_debugFlag=0
    g_devOut="/dev/null"

    while getopts ":FYab:cDd:fhl:n:o:p:rsTt:vVw:W:" option; do
        case $option in
            F) 
                fileListFlag=1
		fileListFile=$OPTARG
                ;;
            Y) 
                sshOption="-tt"
                ;;
            a) 
                resumeFlag=1
                ;;
            b)
                g_xddRemotePathAppend=${OPTARG}
                ;;
            c)
                forceFlag=0
                ;;
            D)
                g_debugFlag=1
                g_devOut="/dev/stderr"
                ;;
	    d) 
		if [ "$OPTARG" = "dest" -o "$OPTARG" = "d" ]; then
                    destDIOFlag=1
		elif [ "$OPTARG" = "source" -o "$OPTARG" = "s" ]; then
		    srcDIOFlag=1
		elif [ "$OPTARG" = "both" -o "$OPTARG" = "b" -o "$OPTARG" = "sd" ]; then
		    destDIOFlag=1
		    srcDIOFlag=1
		else
                    echo "INFO: Unsupported dio argument: -$option $OPTARG" >/dev/stderr 
                    error_exit $XDDCP_ERR_CODE_INVALID_ARGS
		fi
                ;;
	    f) 
                forceFlag=1
                ;;
	    h) 
                print_usage 
                return 0
                ;;
            l)  
                export PATH=${OPTARG}:${PATH}
                ;;
	    n)
		retryCount=$OPTARG
		;;
            o) 
		if [ "$OPTARG" = "dest" -o "$OPTARG" = "d" ]; then
                    destOrderedFlag=1
		elif [ "$OPTARG" = "source" -o "$OPTARG" = "s" ]; then
		    srcOrderedFlag=1
		elif [ "$OPTARG" = "both" -o "$OPTARG" = "b" -o "$OPTARG" = "sd" ]; then
		    destOrderedFlag=1
		    srcOrderedFlag=1
		else
                    echo "INFO: Unsupported dio argument: -$option $OPTARG" >/dev/stderr 
                    error_exit $XDDCP_ERR_CODE_INVALID_ARGS
		fi
                ;;
            p) 
                e2ePort=$OPTARG
                ;;
	    r) 
                recursiveFlag=1
                ;;
	    T) 
                g_timerFlag=1
                g_devOut="/dev/stderr"
                ;;
	    t) 
                queueDepth=$OPTARG
                ;;
	    v) 
		if [ $verbosity -lt 1 ]; then
                    verbosity=1
		fi
                ;;
	    V) 
		if [ $verbosity -lt 2 ]; then
                    verbosity=2
		fi
                ;;
	    w) 
                verbosity=2
		binaryDumpFlag=1
		windowSize=$OPTARG
		expr $windowSize + 1 >/dev/null 2>&1
		if [ $? -ne 0 ]; then
			echo "INFO: Window size (-w arg) must be an integer." >/dev/stderr
			error_exit $XDDCP_ERR_CODE_INVALID_ARGS
		elif [ $windowSize -le 0 ]; then
			echo "INFO: Window size (-w arg) must be greater than zero." >/dev/stderr
			error_exit $XDDCP_ERR_CODE_INVALID_ARGS
		fi
                ;;
	    W) 
                verbosity=2
		binaryDumpFlag=1
		kernelTraceFlag=1
		windowSize=$OPTARG
		expr $windowSize + 1 >/dev/null 2>&1
		if [ $? -ne 0 ]; then
			echo "INFO: Window size (-w arg) must be an integer." >/dev/stderr
			error_exit $XDDCP_ERR_CODE_INVALID_ARGS
		elif [ $windowSize -le 0 ]; then
			echo "INFO: Window size (-w arg) must be greater than zero." >/dev/stderr
			error_exit $XDDCP_ERR_CODE_INVALID_ARGS
		fi
                XDDCP_IOTRACE_EXE=$(\type -P iotrace_init)
                if [ $? -ne 0 ]; then
                    echo "INFO: kernel trace mode requires the 'iotrace_init' command. Install or use -w option."
                    error_exit $XDDCP_ERR_CODE_MISSING_KERNEL_TRACE_COMPONENT
                fi
                if [ ! -c /dev/iotrace_data ]; then
                    echo "INFO: kernel trace mode requires the '/dev/iotrace_data' device. Install or use -w option."
                    error_exit $XDDCP_ERR_CODE_MISSING_KERNEL_TRACE_COMPONENT
                fi
                XDDCP_IOTRACE_DECODE=$(\type -P decode)
                if [ $? -ne 0 ]; then
                    echo "INFO: kernel trace mode requires the 'decode' command. Install or use -w option."
                    error_exit $XDDCP_ERR_CODE_MISSING_KERNEL_TRACE_COMPONENT
                fi
                ;;
            \?)
                echo "INFO: Unsupported option: -$option $OPTARG" >/dev/stderr 
                error_exit $XDDCP_ERR_CODE_INVALID_ARGS
                ;;
        esac
    done
    shift $((OPTIND-1))

    # Get the source path
    srcPath="${1}"
    srcRemoteFlag=0

    # Parse the destination endpoint spec
    destRemoteFlag=0
    parse_endpoint_spec "${2}" destRemoteFlag destUser destHost destIP destPath
    debugPrint "after parse_endpoint_spec: destPath=$destPath destRemoteFlag=$destRemoteFlag destHost=$destHost destIP=$destIP destUser=$destUser"

    # Create destination directory for file list transfer for resumeFlag
    if [ 1 -eq $fileListFlag ]; then
       create_destination_directory "${destPath}" "${destRemoteFlag}" \
                                   "${destHost}" "${destIP}" "${destUser}"
	rc=$?
	if [ 0 -ne $rc ]; then
	    echo "INFO: Failure while creating destination directory ${destPath}"
	    error_exit $rc
	fi
        debugPrint "main: creating destPath=${destPath} if it does not exist"
    fi
    # Create .xdd_recursive_transfer_list on source and make destination directories
    # Do this everytime as partial defense for something getting wiped out at destination
    # Re-making an existing directory is a no-op, so no harm done.
    if [ 1 -eq $recursiveFlag ]; then
    #  g_fileRecursiveList="${PWD}/${g_filebaseRecusiveList}.$(\basename ${srcPath})"
    #  if [ -f "${g_fileRecursiveList}" ]; then
    #    echo "INFO: Using EXISTING recursive file list ${g_fileRecursiveList}"
    #  else
      g_fileRecursiveList="${PWD}/${g_filebaseRecusiveList}.$(\basename ${srcPath})"
      rm -f $g_fileRecursiveList
      timerbeg "4"
      transfer_recursive_path_setup "${srcPath}" "${srcHost}" "${srcUser}"\
        "${srcRemoteFlag}" "${srcDIOFlag}" "${srcOrderedFlag}" \
	"${destPath}" "${destHost}" "${destIP}" "${destUser}" \
	"${destRemoteFlag}" "${destDIOFlag}" "${destOrderedFlag}" \
	"${totalBytes}" "${queueDepth}" "${e2ePort}" \
	"${fileSizeFlag}" "${forceFlag}" "${resumeFlag}" \
	"${verbosity}" "${binaryDumpFlag}"
      rc=$?
	if [ 0 -ne $rc ]; then
	    echo "INFO: Failure while creating .xdd_recursive_transfer_list "
	    error_exit $rc
	fi
        debugPrint "main: creating destPath=${destPath} if it does not exist"
    #  fi
      timerend "4" "transfer_recursive_path_setup"
    fi

    # Get transfer history from destination if it exists
    if [ 1 -eq $resumeFlag ]; then
	g_currentTransferRst="${g_filebaseTransferRst}_partial"
	g_completeTransfersRst="${g_filebaseTransferRst}_complete"
      get_file_transfer_history "${srcPath}" "${destPath}" "${destHost}" "${destIP}"\
				 "${destUser}"
    debugPrint "main: after initial get_file_transfer_history destPath=$destPath \
              destRemoteFlag=$destRemoteFlag destIP=$destIP destHost=$destHost destUser=$destUser"
    fi

    # Get the specified size if it is defined
    fileSizeFlag=0
    totalBytes=0
    if [ ! -z "${3}" ]; then
        fileSizeFlag=1
        totalBytes=${3}
    fi

    # Ensure local option preconditions are met
    check_host_preconditions ${srcPath} ${fileListFlag} ${fileSizeFlag} \
	${recursiveFlag} ${resumeFlag} ${forceFlag}

    # The force flag only works on Linux, disable it everywhere else
    if [ "Linux" != "$(\uname)" ]; then
	forceFlag=0
	echo "Warning: File transfer forcing disabled for non-Linux platforms." >/dev/stderr
    fi

    # Convert the destination host to its IP to avoid DNS round-robin issues
   # $XDDCP_GETHOSTIP_EXE -d $destHost &> /dev/null
   # if [ 0 -ne $? ]; then
   #     error_exit $XDD_ERR_CODE_DEST_IP
   # fi
   # destIP=$($XDDCP_GETHOSTIP_EXE -d $destHost)
    
    # Retry on failed transfer
    retries=0
    while [ $retries -le $retryCount ]; do
            debugPrint "main: top of while [ retries...loop retries=$retries srcPath=$srcPath destPath=$destPath recursiveFlag=${recursiveFlag} g_fileRecursiveList=${g_fileRecursiveList} "

        # Transfer according to source input type
	rc=0
	if [ 1 -eq $fileListFlag ]; then
	    transfer_file_list "${srcPath}" "${srcHost}" "${srcUser}"\
	        "${srcRemoteFlag}" "${srcDIOFlag}" "${srcOrderedFlag}" \
		"${destPath}" "${destHost}" "${destIP}" "${destUser}" \
		"${destRemoteFlag}" "${destDIOFlag}" "${destOrderedFlag}" \
		"${totalBytes}" "${queueDepth}" "${e2ePort}" \
		"${fileSizeFlag}" "${forceFlag}" "${resumeFlag}" \
		"${verbosity}" "${binaryDumpFlag}"
	    rc=$?
	elif [ 1 -eq $recursiveFlag ]; then
            debugPrint "main: before call transfer_recursive_file_list, retries=$retries srcPath=$srcPath destPath=$destPath recursiveFlag=${recursiveFlag} g_fileRecursiveList=${g_fileRecursiveList} "
	    transfer_recursive_file_list "${g_fileRecursiveList}" "${srcHost}" "${srcUser}"\
	        "${srcRemoteFlag}" "${srcDIOFlag}" "${srcOrderedFlag}" \
		"${destPath}" "${destHost}" "${destIP}" "${destUser}" \
		"${destRemoteFlag}" "${destDIOFlag}" "${destOrderedFlag}" \
		"${totalBytes}" "${queueDepth}" "${e2ePort}" \
		"${fileSizeFlag}" "${forceFlag}" "${resumeFlag}" \
		"${verbosity}" "${binaryDumpFlag}"
	    rc=$?
            debugPrint "main: after call transfer_recursive_file_list, retries=$retries srcPath=$srcPath destPath=$destPath recursiveFlag=${recursiveFlag} g_fileRecursiveList=${g_fileRecursiveList} "
	else
	    transfer_file "${srcPath}" "${srcHost}" "${srcUser}"\
	        "${srcRemoteFlag}" "${srcDIOFlag}" "${srcOrderedFlag}" \
		"${destPath}" "${destHost}" "${destIP}" "${destUser}" \
		"${destRemoteFlag}" "${destDIOFlag}" "${destOrderedFlag}" \
		"${totalBytes}" "${queueDepth}" "${e2ePort}" \
		"${fileSizeFlag}" "${forceFlag}" "${resumeFlag}" \
		"${verbosity}" "${binaryDumpFlag}"
	    rc=$?
	fi

	debugPrint "XDDCP main: Transfer status was: $rc"

	# Perform post transfer analysis
	if [ 1 -eq ${binaryDumpFlag} -a 0 -eq $rc ]; then
	    post_transfer_analysis "${srcPath}" "${srcHost}" "${srcUser}" \
		"${destPath}" "${destHost}" "${destIP}" "${destUser}" "${windowSize}" \
		"${kernelTraceFlag}"
	fi

	# On successful transfer complete without any more retries
	if [ 0 -eq $rc ]; then
	    echo ""
	    echo "Transfer complete.  Verify results with md5sum."
            #All files transfered ok, remove source side list
            rm -f $g_fileRecursiveList
	    break
	elif [ $retries -lt $retryCount ]; then
	    # Print a retry message
            retries=$((retries+1))
	    echo "Transfer failed.  Retry attempt: $retries"
	    sleep $XDDCP_DEFAULT_RETRY_SLEEP_SECS
	    reset_global_data
            # Clean up xdd procs at source, destination
            local cmd="pkill -9 -u ${USER} -U ${USER} -x xdd"
            remote_exec "${cmd}" "${destHost}" "${destUser}" "0"
            local_exec  "${cmd}"
            # Get(refresh) transfer history from destination if it exists
            if [ 1 -eq $resumeFlag ]; then
        	g_currentTransferRst="${g_filebaseTransferRst}_partial"
        	g_completeTransfersRst="${g_filebaseTransferRst}_complete"
            debugPrint "destPath=$destPath destRemoteFlag=$destRemoteFlag destIP=$destIP destHost=$destHost destUser=$destUser"
              get_file_transfer_history "${srcPath}" "${destPath}" "${destHost}" "${destIP}"\
				 "${destUser}"
            debugPrint "main: after call get_file_transfer_history retries=$retries srcPath=$srcPath destPath=$destPath recursiveFlag=${recursiveFlag} g_fileRecursiveList=${g_fileRecursiveList} "
            fi
	else
	    echo "Transfer failed.  Error code: $rc  Retries: $retries of $retryCount"
	    break
	fi
    done

    return $rc
}

#
# Execute xddcp
#
xddcp_main "$@"
exit $?
