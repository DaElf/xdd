#!/bin/bash
#
# This program is free software; you can redistribute it and/or modify 
# it under the terms of the GNU General Public License as published by 
# the Free Software Foundation; either version 2 of the License, or 
# (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful, but 
# WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY 
# or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License 
# for more details.
# 
# You should have received a copy of the GNU General Public License along 
# with this program; if not, write to the Free Software Foundation, Inc., 
# 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
#
#
# This file is part of XDD
#
# Copyright (C) 2010, Brad Settlemyer
#
# Description:  This script enables the use of XDD as a remote data movement
# engine.  Its functionality loosely mimics the capabilities of scp and bbcp,
# however, with hopefully much improved performance.
#
# Notes: XDDCP has been tested on AIX and Linux environments.  
#
# The following POSIX utilities are required to utilize XDDCP:
#    /bin/basename
#    /bin/cat
#    /bin/cut
#    /bin/date
#    /bin/echo
#    /bin/egrep
#    /bin/grep
#    /bin/hostname
#    /bin/ps
#    /bin/uname
#
# The following utilities are provided by the XDD distribution
#    xdd-getfilesize
#    xdd-gethostip
#    xdd-truncate
#    xdd
#
# The following utilities (non-POSIX) are required to utilize XDDCP:
#    dirname
#    mkfifo
#    ssh
#    stat
#    tr
#
# The following utilities are optionally used by XDDCP:
#    netstat 
#


# XDD Configurable global settings
XDDCP_DEFAULT_E2E_PORT=40010
XDDCP_DEFAULT_XFER_SIZE=33554432
XDDCP_DEFAULT_QUEUE_DEPTH=8
XDDCP_DEFAULT_SSH_PSEUDO_TERMINAL_OPT="-T"
XDDCP_DEFAULT_HEARTBEAT_SECS=4
XDDCP_DEFAULT_TIMESTAMP="$(/bin/date -u +'%Y-%m-%d-%H%M%S')-GMT"
XDDCP_DEFAULT_NETWORK_SLEEP_SECS=4
XDDCP_DEFAULT_RETRY_SLEEP_SECS=4
XDDCP_DEFAULT_NETWORK_CLEAR_SECS=2
XDDCP_DEFAULT_FIFO_PATH="/tmp/xddcp-$USER.$$"
XDDCP_IOTRACE_EXE=""

# XDD package executables
XDDCP_XDD_EXE="xdd"
XDDCP_GETHOSTIP_EXE="xdd-gethostip"
XDDCP_TRUNCATE_EXE="xdd-truncate"
XDDCP_GETFILESIZE_EXE="xdd-getfilesize"
XDDCP_READTSDUMPS_EXE="xdd-read-tsdumps"
XDDCP_PLOTTSDUMPS_EXE="xdd-plot-tsdumps"
XDDCP_PLOTTSDUMPSDK_EXE="xdd-plot-tsdumps-dk"

# XDDCP Error Codes
XDDCP_ERR_CODE_INVALID_ARGS=101
XDDCP_ERR_CODE_INVALID_FORMAT=102
XDDCP_ERR_CODE_XDD_NOT_FOUND=103
XDDCP_ERR_CODE_QIP_NOT_FOUND=104
XDDCP_ERR_CODE_INV_FLAGS=105
XDDCP_ERR_CODE_SRC_XST=106
XDDCP_ERR_CODE_INV_RST=107
XDDCP_ERR_CODE_SSH_ERROR=108
XDDCP_ERR_CODE_SSH_FAILURE=109
XDDCP_ERR_CODE_SMALL_FILE=110
XDDCP_ERR_CODE_XFER_SIZE=111
XDDCP_ERR_CODE_VERSION_MATCH=112
XDDCP_ERR_CODE_NO_REMOTE=113
XDDCP_ERR_CODE_XFER_FAIL=114
XDDCP_ERR_CODE_DEST_PORT=115
XDDCP_ERR_CODE_SRC_DEV_DIRECT_IO=116
XDDCP_ERR_CODE_DEST_DEV_DIRECT_IO=117
XDDCP_ERR_CODE_DEST_DEV_FILE_SIZE=118
XDDCP_ERR_CODE_DEST_DIR_NOT_XST=119
XDDCP_ERR_CODE_DEST_DIR_NOT_WR=120
XDDCP_ERR_CODE_DEST_TGT_NOT_WR=121
XDDCP_ERR_CODE_DEST_IP=122
XDDCP_ERR_CODE_GETHOSTIP_NOT_FOUND=123
XDDCP_ERR_CODE_FIFO_ACCESS=124
XDDCP_ERR_CODE_FIFO_FAILED=125
XDDCP_ERR_CODE_MISSING_KERNEL_TRACE_COMPONENT=126

#
# Global variables
#
g_xddcpXddVersion="-1"
g_xddcpFifoPath=""
g_xddcpDestSSHPid="-1"
g_xddcpSrcXddPid="-1"
g_xddcpResumeOffset="0"
g_transferCount="0"

#
# Reset global variables before retry
#
function reset_global_data {
    g_xddcpDestSSHPid="-1"
    g_xddcpSrcXddPid="-1"
    g_xddcpResumeOffset="0"
}

#
# Print out the usage information
#
function print_usage {
    echo "xddcp [OPTIONS] source_file destination_host:destination_file [size]"
    echo ""
    echo "source_file       - complete /filepath/name for source file on source host"
    echo "destination_host  - destination host IP or Name over which data is transferred"
    echo "destination_file  - complete /filepath/name for destination file on destination host"
    echo "size              - number of bytes to transfer [Default: size of source file]"
    echo ""
    echo "OPTIONS: "
    echo " -a		- Resume transfer if it was only partially completed and the -a flag was specified"
    echo " -c           - If ports are unavailable on destination, indicate error rather than trying to force transfer"
    echo " -d s|d|b	- Use direct I/O the end specified (s for source, d for dest, b for both)"
    #echo " -f           - If ports are unavailable on destination, attempt to kill running XDD and retry"
    echo " -F		- Transfer a list of files named in source_file"
    echo " -h		- Print out usage information"
    echo " -n		- If operation fails for any reason, retry up to n times"
    echo " -p portnum   - First port to use for transfer [Default: $XDDCP_DEFAULT_E2E_PORT]" 
    echo " -o s|d|b     - Perform file I/O in serial order on end specified (s for source, d for dest, b for both)"
    echo " -r           - Copy sub-directories and contents recursively"
    echo " -t threads   - Use 'threads' number of threads during transfer [Default: $XDDCP_DEFAULT_QUEUE_DEPTH]"
    echo " -v           - Turn on logging"
    echo " -V           - Add timestamping output to logs"
    echo " -w sec       - Add post-analysis: plot bandwidth over time with sliding window of 'sec' seconds. (sec >= 1)"
    echo " -W sec       - Add post-analysis: -w option with kernel tracing. (sec >= 1)"
    #echo "-Y           - Force SSH to create psueo-terminal tty"
    echo "NOTE: 'xdd' must be in your PATH env on both source and destination hosts!!!"
}

#
# Print out an appropriate error message and exit
#
function error_exit {
    local errorCode=$1

    error_print $errorCode

#    echo "Call stack: $FUNCNAME"
#    for ((i=0; i < ${#FUNCNAME[@]}; i=$i+1)); do
#	echo "INFO: Call Stack ${FUNCNAME[$i]}"
#    done

    # Exit the program with the error code
    exit $errorCode
}

#
# Print out an appropriate error message
#
function error_print {
    local errorCode=$1
    case $errorCode in
        $XDDCP_ERR_CODE_INVALID_ARGS) 
            echo "ERROR: Invalid command arguments" >/dev/stderr
            ;;
        $XDDCP_ERR_CODE_INVALID_FORMAT) 
            echo "ERROR: Invalid source/destination format" >/dev/stderr
            ;;
        $XDDCP_ERR_CODE_XDD_NOT_FOUND) 
            echo "ERROR: ${XDDCP_XDD_EXE} executable not found" >/dev/stderr
            ;;
        $XDDCP_ERR_CODE_QIP_NOT_FOUND) 
            echo "ERROR: qipcrm executable not found" >/dev/stderr
            ;;
        $XDDCP_ERR_CODE_INV_FLAGS) 
            echo "ERROR: Incompatible command line arguments" >/dev/stderr
            ;;
        $XDDCP_ERR_CODE_SRC_XST) 
            echo "ERROR: Cannot locate source file" >/dev/stderr
            ;;
        $XDDCP_ERR_CODE_INV_RST) 
            echo "ERROR: Invalid restart offset location" >/dev/stderr
            ;;
        $XDDCP_ERR_CODE_SSH_FAILURE) 
            echo "ERROR: Failure spawing process via SSH" >/dev/stderr
            ;;
        $XDDCP_ERR_CODE_SSH_ERROR) 
            echo "ERROR: Remote session failure" >/dev/stderr
            ;;
        $XDDCP_ERR_CODE_SMALL_FILE) 
            echo "ERROR: Cannot transfer files smaller than $XDDCP_DEFAULT_XFER_SIZE bytes" >/dev/stderr
            ;;
        $XDDCP_ERR_CODE_XFER_SIZE) 
            echo "ERROR: Requested transfer size is larger than file size" >/dev/stderr
            ;;
        $XDDCP_ERR_CODE_VERSION_MATCH) 
            echo "ERROR: ${XDDCP_XDD_EXE} versions differ on source and destination" >/dev/stderr
            ;;
        $XDDCP_ERR_CODE_NO_REMOTE) 
            echo "ERROR: Local file transfers are not permitted" >/dev/stderr
            ;;
        $XDDCP_ERR_CODE_XFER_FAIL) 
            echo "ERROR: File transfer failed." >/dev/stderr
            echo "  If the reason is \"Connection refused\", check the destination logfile." >/dev/stderr
            ;;
        $XDDCP_ERR_CODE_DEST_PORT) 
            echo "ERROR: Destination port is in use" >/dev/stderr
            ;;
        $XDDCP_ERR_CODE_DEST_DEV_DIRECT_IO)
            echo "ERROR: Destination is a character device, direct I/O is not allowed." >/dev/stderr
            ;;
        $XDDCP_ERR_CODE_SRC_DEV_DIRECT_IO)
            echo "ERROR: Source is a character device, direct I/O is not allowed." >/dev/stderr
            ;;
        $XDDCP_ERR_CODE_SRC_DEV_FILE_SIZE)
            echo "ERROR: Source is a character device, transfer size must be provided." >/dev/stderr
            ;;
	$XDDCP_ERR_CODE_DEST_DIR_NOT_XST)
	    echo "ERROR: Destination directory does not exist." >/dev/stderr
	    ;;
        $XDDCP_ERR_CODE_DEST_DIR_NOT_WR)
	    echo "ERROR: Destination directory is not writable." >/dev/stderr
	    ;;
        $XDDCP_ERR_CODE_DEST_TGT_NOT_WR)
	    echo "ERROR: Destination target is not writable." >/dev/stderr
	    ;;
        $XDDCP_ERR_CODE_DEST_IP)
	    echo "ERROR: Could not resolve destination IP address." >/dev/stderr
	    ;;
        $XDDCP_ERR_CODE_GETHOSTIP_NOT_FOUND)
	    echo "ERROR: Could not find xdd-gethostip program." >/dev/stderr
	    ;;
        $XDDCP_ERR_CODE_FIFO_ACCESS)
	    echo "ERROR: Invalid permissions to access FIFO." >/dev/stderr
	    ;;
        $XDDCP_ERR_CODE_FIFO_FAILED)
	    echo "ERROR: Could not create FIFO." >/dev/stderr
	    ;;
        \?) 
            echo "ERROR: Unknown error code" >/dev/stderr
            ;;
    esac
}

#
# Handle trapped signals
#
function handle_signal_common {
    local signum=$1

    # Attempt to deliver the signal to source-side XDD
    if [ -1 -ne $g_xddcpSrcXddPid ]; then
        kill -$signum $g_xddcpSrcXddPid &>/dev/null
	sleep 1
    fi

    # Attempt to destroy any open SSH sessions
    if [ -1 -ne $g_xddcpDestSSHPid ]; then
	kill $g_xddcpDestSSHPid &>/dev/null
    fi

    # Remove the FIFO if it still exists
    if [ -e "$g_xddcpFifoPath" ]; then
	rm -f $g_xddcpFifoPath &>/dev/null
    fi

    echo "INFO:  Transfer cancelled by user." >/dev/stderr
}

#
# Parse endpoint spec of the form [[user@]host:]path
#
# Call with spec and variable names as arguments, e.g.:
#
# spec="user@foo.bar.com:/home/user"
# srcRemoteFlag=0
# srcUser=""
# srcHost=""
# srcPath=""
# parse_endpoint_spec $spec srcRemoteFlag srcUser srcHost srcPath
#
function parse_endpoint_spec {
    local spec=$1
    local remoteFlagRef="$2"
    local remoteUserRef="$3"
    local remoteHostRef="$4"
    local remotePathRef="$5"
    
    # Set the outbound defaults
    eval "$remoteFlagRef=0"
    eval "$remoteUserRef=\"\""
    eval "$remoteHostRef=\"\""
    eval "$remotePathRef=\"\""
    
    # Parse out remote host and file
    local colon_count=`/bin/echo $spec | grep -c ":"`
    if [ $colon_count -eq 1 ]; then

        # Set the remote flag
        eval "$remoteFlagRef=1"

        # Set the path
        eval "$remotePathRef=$(/bin/echo $spec | awk -F: '{print $2}')"

        # Set the host
        local _tmp=$(/bin/echo $spec | awk -F: '{print $1}')
        eval "$remoteHostRef=$(/bin/echo $spec | awk -F: '{print $1}')"
        
        # Set the username if it exists
        local amp_count=$(/bin/echo $_tmp |grep -c "@")
        if [ 1 -eq $amp_count ]; then
            eval "$remoteUserRef=$(/bin/echo $_tmp |awk -F@ '{print $1}')"
            eval "$remoteHostRef=$(/bin/echo $_tmp |awk -F@ '{print $2}')"
        fi
    else
        eval "$remotePathRef=$spec"
    fi
}

#
# Check preconditions for the host
#
# Sideffects: Sets the global XDDCP version identifier
#
function check_host_preconditions {

    # Arguments
    local sourceSideFilename=${1}
    local fileListFlag=${2}
    local fileSizeFlag=${3}
    local resumeFlag=${4}
    local recursiveFlag=${5}
    local forceFlag=${6}

    # Set the XDD version information
    g_xddcpXddVersion=$(${XDDCP_XDD_EXE} -version)

    # Check for gethostip binary
    type $XDDCP_GETHOSTIP_EXE &>/dev/null
    if [ 0 -ne $? ]; then
        error_exit $XDDCP_ERR_CODE_GETHOSTIP_NOT_FOUND
    fi

    # Ensure flag combinations are valid
    if [ 1 -eq $fileListFlag -a 1 -eq $resumeFlag ]; then
        echo "INFO: -F and -a flags cannot both be specified" >/dev/stderr
        error_exit $XDDCP_ERR_CODE_INV_FLAGS
    elif [ 1 -eq $fileListFlag -a 1 -eq $fileSizeFlag ]; then
        echo "INFO: -F option does not take an argument" >/dev/stderr
        error_exit $XDDCP_ERR_CODE_INV_FLAGS
    elif [ 1 -eq $fileListFlag -a 1 -eq $recursiveFlag ]; then
        echo "INFO: -F and -r flags cannot both be specified" >/dev/stderr
        error_exit $XDDCP_ERR_CODE_INV_FLAGS
    elif [ 1 -eq $recursiveFlag -a 1 -eq $fileSizeFlag ]; then
        echo "INFO: -r option does not take an argument" >/dev/stderr
        error_exit $XDDCP_ERR_CODE_INV_FLAGS
    elif [ 1 -eq $recursiveFlag -a 1 -eq $resumeFlag ]; then
        echo "INFO: -r and -a flags cannot both be specified" >/dev/stderr
        error_exit $XDDCP_ERR_CODE_INV_FLAGS
    fi

    # Ensure tools required for force flag exist
    type $XDDCP_GETHOSTIP_EXE &>/dev/null
    if [ $? -ne 0 ]; then
        echo "INFO: Force mode requires the gethostip command, force disabled."
        eval "forceFlag=0"
    fi
}

#
# Check preconditions for the file list transfer
#
function check_file_list_preconditions {

    # Arguments
    local sourceSideFilename=$1
    local fileSizeFlag=$3
    local resumeFlag=$4

    # Ensure source side file list filename exists and is readable
    if [ 1 -eq $fileListFlag -a ! -r "${sourceSideFilename}" ]; then
	echo "INFO: Cannot read ${sourceSideFilename}" >/dev/stderr
	error_exit $XDDCP_ERR_CODE_SRC_XST
    fi
}

#
# Check preconditions for a recursive transfer
#
function check_recursive_preconditions {

    # Arguments
    local sourceSidePath=$1
    local fileSizeFlag=$3
    local resumeFlag=$4

    # If source side name is a file, ensure its readable
    # if it is a directory, is readable and searchable
    if [ -f "${sourceSidePath}" -a ! -r "${sourceSidePath}" ]; then
	echo "INFO: Cannot read ${sourceSidePath}" >/dev/stderr
	error_exit $XDDCP_ERR_CODE_SRC_XST
    elif [ -d "${sourceSidePath}" ]; then
	if [ ! -r "${sourceSidePath}" -o ! -x "${sourceSidePath}" ]; then
	    echo "INFO: Cannot read/search ${sourceSidePath}" >/dev/stderr
	    error_exit $XDDCP_ERR_CODE_SRC_XST
	fi
    fi
}

#
# Check preconditions for the transfer
#
function check_transfer_preconditions {

    # Arguments
    local sourceSideFilename=$1
    local destSidePathname=$2
    local srcRemoteFlag=$3
    local destRemoteFlag=$4
    local srcDIOFlag=$5
    local destDIOFlag=$6
    local fileSizeFlag=$7
    local transferSize=$8

    # Ensure at least one of the sides is remote
    if [ 0 -eq ${destRemoteFlag} -a 0 -eq ${srcRemoteFlag} ]; then
        error_exit $XDDCP_ERR_CODE_NO_REMOTE
    fi

    # Ensure source side file exists
    if [ ! -r "${sourceSideFilename}" ]; then
	echo "INFO: Cannot read ${sourceSideFilename}"
	error_exit $XDDCP_ERR_CODE_SRC_XST
    fi

    # Check if file is a character special device (like zero or null)
    local sfType=$(stat -c %F ${sourceSideFilename} 2>/dev/null)
    local dfType=$(stat -c %F ${destSidePathname} 2>/dev/null)

    # Ensure file is large enough
    local totalBytes="$transferSize"
    if [ "$sfType" != "character special file" ]; then
        local trueSize="$($XDDCP_GETFILESIZE_EXE $sourceSideFilename)"
        if [ $XDDCP_DEFAULT_XFER_SIZE -gt $trueSize ]; then
            error_exit $XDDCP_ERR_CODE_SMALL_FILE
        elif [ 1 -eq $fileSizeFlag -a $transferSize -gt $trueSize ]; then
            error_exit $XDDCP_ERR_CODE_XFER_SIZE
        fi
    elif [ "$sfType" = "character special file" ]; then
	if [ 0 -eq "$fileSizeFlag" ]; then
	    error_exit $XDDCP_ERR_CODE_SRC_DEV_FILE_SIZE
	elif [ $XDDCP_DEFAULT_XFER_SIZE -gt "$transferSize" ]; then
            error_exit $XDDCP_ERR_CODE_XFER_SIZE
	fi
    fi

    # Ensure devices and Direct I/O are not combined
    if [ "$sfType" = "character special file" -a 0 -ne $srcDIOFlag ]; then
        error_exit $XDDCP_ERR_CODE_SRC_DEV_DIRECT_IO
    elif [ "$dfType" = "character special file" -a 0 -ne $destDIOFlag ]; then
        error_exit $XDDCP_ERR_CODE_DEST_DEV_DIRECT_IO
    fi
    return 0
}

#
# Execute xdd commands locally
#
function local_exec {
    local cmds="$1"
    /bin/bash --login <<EOF
$cmds
EOF
    
    # If the transfer failed, trigger appropriate error
    local rc=$?
    return $rc
}

#
# Execute xdd commands on remote host
#
function remote_exec {
    #echo "remote_exec Args: $@" >/dev/stderr
    local cmds="$1"
    local remoteHost="$2"
    local remoteUser="$3"

    # Construct ssh options
    if [ ! -z "${remoteUser}" ]; then
        sshOpts="-q -l $remoteUser"
    fi

    # Local decl must be on seperate line so $? is correct
    local destRC=""
    local remoteOutput=""
    remoteOutput=$(ssh ${sshOpts} ${remoteHost} /bin/bash --login <<EOF
$cmds
EOF
        )
    destRC=$?

    # Check the status of remote operations
    if [ 255 -eq $destRC ]; then
        echo "INFO: Remote output - $remoteOutput" >/dev/stderr
        error_exit $XDDCP_ERR_CODE_SSH_FAILURE
    elif [ 0 -ne $destRC -a ! -z "$remoteOutput" ]; then
        echo "INFO: Remote RC: $destRC Remote Error: $remoteOutput" >/dev/stderr
        error_print $destRC
        error_exit $XDDCP_ERR_CODE_SSH_ERROR
    elif [ 0 -ne $destRC ]; then
        echo "INFO: Remote operation failure, no cause detected" >/dev/stderr
        error_exit $XDDCP_ERR_CODE_SSH_ERROR
    fi
    echo "$remoteOutput"
}

#
# Perform a remote execution using a FIFO to capture stdout
#
function remote_exec_with_fifo {
    #echo "remote_exec Args: $@" >/dev/stderr
    local cmds="$1"
    local fifoPath="$2"
    local remoteHost="$3"
    local remoteUser="$4"

    # If a fifo exists, remove it
    if [ -e "$fifoPath" ]; then
	rm -f $fifoPath
	rc=$?
	if [ 0 -ne $rc ]; then
	    echo "INFO: Unable to remove existing FIFO: $fifoPath"
	    error_exit $XDDCP_ERR_CODE_FIFO_ACCESS
	fi
    fi

    # Create a new fifo
    mkfifo $fifoPath &>/dev/null
    rc=$?
    if [ 0 -ne $rc ]; then
	echo "INFO: Unable to create FIFO: $fifoPath"
	error_exit $XDDCP_ERR_CODE_FIFO_FAILED
    fi
    
    # Construct ssh options
    if [ ! -z "${remoteUser}" ]; then
        sshOpts="-q -o ServerAliveInterval 30 -l $remoteUser"
    fi

    # Local decl must be on seperate line so $? is correct
    ssh ${sshOpts} ${remoteHost} /bin/bash --login <<EOF > $fifoPath &
$cmds
wait
EOF
    rc=$?
    g_xddcpDestSSHPid=$!
    g_xddcpFifoPath=$fifoPath
    return $rc
}

#
# Return the file size
#
function get_file_size {
    #echo "get_file_size Args: $@" >/dev/stderr
    local filename=$1
    local remoteFlag=$2
    local host=$3
    local user=$4

    if [ 0 -eq "$remoteFlag" ]; then
        echo $($XDDCP_GETFILESIZE_EXE $filename)
    else
        cmd="$XDDCP_GETFILESIZE_EXE $filename"
        remote_exec $cmd $host $user
    fi
}

#
# Return the destination side program
#
function get_destination_cmds {
    #echo "get_destination_cmds Args: $@" >/dev/stderr
    local destHost=${1}
    local destIP=${2}
    local destIfaces=${3}
    local destIfaceThreads=${4}
    local srcFile=${5}
    local destPath=${6}
    local totalBytes=${7}
    local e2ePort=${8}
    local dioFlag=${9}
    local forceFlag=${10}
    local serialOrderedFlag=${11}
    local recursionFlag=${12}
    local resumeFlag=${13}
    local verbosity=${14}
    local binaryDumpFlag=${15}

    # Options that aren't yet settable
    local srcHost=$(/bin/hostname)
    
    # Construct transfer settings
    declare -i xfer=${XDDCP_DEFAULT_XFER_SIZE}
    declare -i numreqs=$((totalBytes/xfer))
    declare -i blocksize=1024
    declare -i reqsize=$((xfer/blocksize))

    # Other variables
    local srcBase=$(/bin/basename $srcFile)
    local destQD="-queuedepth ${queueDepth}"

    # Construct the e2e destinations
    local e2eDestinations=""
    declare idx=0
    for iface in $destIfaces; do
	idx=$((idx+1))
	tcount=$(/bin/echo $destIfaceThreads |cut -f $idx -d ' ')
	e2eDestinations="$e2eDestinations -e2e dest ${iface}:${e2ePort},${tcount}" 
    done
    if [ -z "$e2eDestinations" ]; then
	/bin/echo "ERROR: No destination interfaces specified"
	error_exit $XDDCP_ERR_CODE_NO_REMOTE
    fi

    # Direct I/O option
    if [ 1 -eq $dioFlag ]; then
        local destDIO="-dio"
    fi

    # Thread ordering option
    local orderedOpt="-noordering"
    if [ 1 -eq $serialOrderedFlag ]; then
        orderedOpt="-serialordering"
    fi

    # Verbose option
    if [ 1 -eq $verbosity ]; then
        local verboseOpt="-verbose"
    fi

    # binary timestamp dump
    if [ 1 -eq $binaryDumpFlag ]; then
        local binaryDumpPrefix="xdd-${destHost}-$(/bin/basename $destPath)-${XDDCP_DEFAULT_TIMESTAMP}"
    fi
    
    cat <<EOF
# Ensure xdd is in the remote path
type ${XDDCP_XDD_EXE} &>/dev/null
if [ 0 -ne \$? ]; then
    echo "xdd binary is not in destination host PATH" >/dev/stderr
    exit ${XDDCP_ERR_CODE_XDD_NOT_FOUND}
fi

# Check that the correct version of XDD is available
dest_version=\$(${XDDCP_XDD_EXE} -version)
if [ "\$dest_version" != "$g_xddcpXddVersion" ]; then
    echo "XDD source and destionation version mismatch." >/dev/stderr
    exit ${XDDCP_ERR_CODE_VERSION_MATCH}
fi

# Path complement xdd so that iotracing can function
xdd_exe_path=\$(type -P ${XDDCP_XDD_EXE})

# Check that ports are available for binding (Linux only)
declare -i port_conflict=0
if [ "$(/bin/uname)" = "Linux" ]; then
    type $XDDCP_GETHOSTIP_EXE &>/dev/null
    hasIpTranslator=\$?
    if [ 1 -ne \$hasIpTranslator ]; then
        declare -i tcount_idx=0
        for iface in $destIfaces; do
            tcount_idx=\$((tcount+1))
                tcount=\$(/bin/echo $destIfaceThreads |cut -f \$tcount_idx -d ' ')
            iface_ip=\$($XDDCP_GETHOSTIP_EXE -d \$iface)
            e2eLB=$e2ePort
            e2eUB=\$((e2eLB+tcount))
#        echo "\$tcount_idx \$iface_ip \$e2eLB \$e2eUB" >>/tmp/bws
#        echo "netstat -nlt |grep \$iface_ip |cut -d : -f 2 |cut -d ' ' -f 1 |tr -d [:alpha:])" >>/tmp/bws
            used_ports=\$(netstat -nlt |grep \$iface_ip |cut -d : -f 2 |cut -d ' ' -f 1 |tr -d [:alpha:])
#        echo "Used ports: \$used_ports" >>/tmp/bws
            for p in \$used_ports; do
                if [ \$e2eLB -le \$p -a \$e2eUB -gt \$p ]; then
                    port_conflict=1
                    break
                fi
            done
        done
    fi

    # If a port conflict exists, user may want to kill running XDD's and retry
    if [ 1 -eq \$port_conflict ]; then
        # Attempt to kill any running XDDs and re-check
        if [ 1 -eq $forceFlag ]; then
            xddpid=\$(/bin/ps -u \${USER} |grep xdd |grep -v grep |grep -v xddcp |cut -c-5)
            if [ ! -z "\$xddpid" ]; then
                kill \$xddpid 2>/dev/null
                sleep $XDDCP_DEFAULT_NETWORK_CLEAR_SECS
                kill -9 \$xddpid 2>/dev/null
                sleep $XDDCP_DEFAULT_NETWORK_CLEAR_SECS
            fi
        else
            echo "Requested port \$p is in use" >/dev/stderr
            exit ${XDDCP_ERR_CODE_DEST_PORT}
        fi

        tcount_idx=0
        for iface in $destIfaces; do
            tcount_idx+=1
            tcount=\$(/bin/echo $destIfaceThreads |cut -f \$tcount_idx -d ' ')
            e2eLB=$e2ePort
            e2eUB=\$((e2eLB+tcount))
            used_ports=\$(netstat -nlt |grep $iface |cut -d : -f 2 |cut -d ' ' -f 1 |tr -d [:alpha:])
            for p in \$used_ports; do
                if [ \$e2eLB -le \$p -a \$e2eUB -gt \$p ]; then
                    echo "Requested port \$p is in use" >/dev/stderr
                    exit ${XDDCP_ERR_CODE_DEST_PORT}
                fi
            done
        done
    fi
fi

# If the supplied destination is a directory, append the source file name
destination_file=$destPath
destination_base=\$(/bin/basename $destPath)
destination_dir=\$(dirname $destPath)
if [ -d $destPath ]; then
    destination_file=$destPath/$srcBase
    destination_base=$srcBase
    destination_dir=$destPath
fi

# If the filename uses a relative path, path complement it
path_char=\$(dirname \$destination_file |cut -c 1)
if [ "." = \$path_char ]; then
    default_dir=\$(/bin/pwd)
    destination_dir="\${default_dir}/\${destination_dir}"
    destination_file="\${default_dir}/\${destination_file}"
fi

# Create the log file name
destination_log_base="xdd-${destHost}-\${destination_base}-${XDDCP_DEFAULT_TIMESTAMP}.log"
destination_log="\${destination_dir}/\${destination_log_base}"

# Ensure destination is writable
if [ ! -d \$destination_dir ]; then
    echo "Destination directory does not exist: \${destination_dir}" >/dev/stderr
    exit ${XDDCP_ERR_CODE_DEST_DIR_NOT_XST} 
elif [ -d \$destination_dir -a ! -e \$destination_file -a ! -w \$destination_dir ]; then
    echo "Destination directory is not writable: \$destination_dir"
    exit ${XDDCP_ERR_CODE_DEST_DIR_NOT_WR}
elif [ -e \$destination_file -a ! -w \$destination_file ]; then
    echo "Destination target exists but is not writable: \$destination_file" >/dev/stderr
    exit ${XDDCP_ERR_CODE_DEST_TGT_NOT_WR}
fi

# Perform restart if necessary
if [ 1 -eq $resumeFlag ]; then
    # Ensure sufficient permissions exist to create restart cookie
    if [ ! -w \$destination_dir ]; then
        echo "Restart option requires write access to: \$destination_dir" >/dev/stderr
        exit ${XDDCP_ERR_CODE_DEST_DIR_NOT_WR}
    fi

    # Create the name for a new restart cookie
    restart_logfile="\${destination_dir}/xdd-${srcHost}-${srcBase}-${destHost}-\${destination_base}-${XDDCP_DEFAULT_TIMESTAMP}.rst"

    # Check for the existence a restart cookie
    most_recent_restart_cookie=\$(/bin/ls \${destination_dir}/xdd-${srcHost}-${srcBase}-${destHost}-\${destination_base}-*.rst 2>/dev/null |tail -1)
    echo "Using restart cookie: \$most_recent_restart_cookie"
    if [ -z "\$most_recent_restart_cookie" ]; then
       destination_restart="-restart file \${restart_logfile} -restart enable"
    else
       destination_restart="-restart file \${restart_logfile} -restart enable \$(/bin/cat \$most_recent_restart_cookie)"
    fi
fi

# If insufficient permissions for the log exist, direct to HOME
if [ $verbosity -lt 1 ]; then
    destination_log=/dev/null
elif [ ! -w \$destination_dir -a -e \$destination_log -a ! -w \$destination_log ]; then
    echo "Logfile already exists and is not writable: \$destination_log" >/dev/stderr
    exit ${XDDCP_ERR_CODE_DEST_TGT_NOT_WR}
elif [ ! -w \$destination_dir -a ! -w \$destination_log ]; then
    home_dir_log="./\${destination_log_base}"
    if [ ! -w "./" ]; then
        echo "Could not create log file as \$destination_log or as \$home_dir_log"
        exit ${XDDCP_ERR_CODE_DEST_TGT_NOT_WR}
    fi
    echo "Warning: Writing log to: \$home_dir_log"
    destination_log=\$home_dir_log
fi
# Verbose option
  if [ 1 -eq $verbosity ]; then
        verboseopt="-verbose"
elif [ 2 -eq $verbosity ]; then
        verboseopt="-verbose -ts detailed -ts output \$(dirname \${destination_log})/$binaryDumpPrefix"
fi
if [ 1 -eq $binaryDumpFlag ]; then
	binary_dump_opts="-ts dump \$(dirname \${destination_log})/$binaryDumpPrefix"
fi

# Truncate the destination to the correct size if necessary
if [ -e \$destination_file ]; then
    cur_size=\$($XDDCP_GETFILESIZE_EXE \${destination_file})
    if [ \$cur_size -gt $totalBytes ]; then
        $XDDCP_TRUNCATE_EXE -s $totalBytes \${destination_file}
    fi
fi

# XDD Command
xdd_cmd="${XDDCP_IOTRACE_EXE} \${xdd_exe_path} -target \${destination_file} -op write -minall ${orderedOpt} \${verboseopt} \${binary_dump_opts} -bytes ${totalBytes} -reqsize $reqsize -e2e isdestination ${e2eDestinations} ${destDIO} \${destination_restart} -preallocate ${totalBytes} -stoponerror > \${destination_log}"

# Log XDD Command
echo "Destination-side invocation: \${xdd_cmd}" > \${destination_log}

# Set iotrace log files location
export TR_RUN_LOG=\${destination_dir}

# Invoke XDD
\${xdd_cmd} >> \${destination_log} 2>&1 &

# Send the restart offset back to the source side via stdout
if [ 1 -eq $resumeFlag ]; then
    echo "XDDCP RESTART TOKENS: \${destination_restart}"
else
    echo "XDD started without restart capability"
fi
EOF
}

#
# Return the source side program
#
function get_source_cmds {
    #echo "get_source_cmds Args: $@" >/dev/stderr
    local destIfaces=${1}
    local srcFile=${2}
    local totalBytes=${3}
    local destIfaceThreads=${4}
    local e2ePort=${5}
    local srcDIOFlag=${6}
    local serialOrderedFlag=${7}
    local resumeFlag=${8}
    local verbosity=${9}
    local binaryDumpFlag=${10}
    local resumeOffset=${11}

    # Construct XDD transfer settings
    xfer=${XDDCP_DEFAULT_XFER_SIZE}
    numReqs=$((totalBytes/xfer))
    blockSize=1024
    reqSize=$((xfer/blockSize))

    # Construct the e2e destinations
    local e2eDestinations=""
    declare idx=0
    for iface in $destIfaces; do
	idx=$((idx+1))
	tcount=$(/bin/echo $destIfaceThreads |cut -f $idx -d ' ')
	e2eDestinations="$e2eDestinations -e2e dest ${iface}:${e2ePort},${tcount}" 
    done
    if [ -z "$e2eDestinations" ]; then
	/bin/echo "ERROR: No destination interfaces specified"
	error_exit $XDDCP_ERR_CODE_NO_REMOTE
    fi

    # Validate restart flag if necessary
    srcRestart=""
    if [ 1 -eq $resumeFlag ]; then
        if [ "enable" = "$resumeOffset" ]; then
            srcRestart="-restart enable"
        elif [ "capability" = "$resumeOffset" ]; then
            error_exit $XDDCP_ERR_CODE_INV_RESTART
        elif [ 0 -le "$resumeOffset" ]; then
            echo "INFO: Resuming XDD file transfer at offset: $resumeOffset" >/dev/stderr
            srcRestart="-restart enable -restart offset $resumeOffset"
        else
            error_exit $XDDCP_ERR_CODE_INV_RESTART
        fi
    fi

    # Construct source XDD settings
    local srcBase=$(/bin/basename ${srcFile})
    local srcQD="-queuedepth ${queueDepth}"
    local srcLog="xdd-$(/bin/hostname)-${srcBase}-${XDDCP_DEFAULT_TIMESTAMP}.log"

    # Direct I/O option
    if [ 1 -eq $srcDIOFlag ]; then
        local srcDIO="-dio"
    fi

    # Thread ordering option
    local orderedOpt="-looseordering"
    if [ 1 -eq $serialOrderedFlag ]; then
        orderedOpt="-serialordering"
    fi

    # Verbose option
    if [ 1 -eq $verbosity ]; then
        local verboseOpt="-verbose"
    elif [ 2 -eq $verbosity ]; then
        local verboseOpt="-verbose -ts detailed -ts output xdd-$(/bin/hostname)-${srcBase}-${XDDCP_DEFAULT_TIMESTAMP}"
    fi

    # binary timestamp dump option
    if [ 1 -eq $binaryDumpFlag ]; then
        local binaryDumpOpt="-ts dump xdd-$(/bin/hostname)-${srcBase}-${XDDCP_DEFAULT_TIMESTAMP}"
    fi
    
    # Determine if output can be sent to log file
    local srcOutput="-output ${srcLog}"
    if [ ! -w "./" ]; then
        echo "WARNING:  Cannot create log file: ./$srcLog, logging output to stdout" >/dev/stderr
        sourceOutput=""
    fi

    # Build the command string
    cat <<EOF
# Ensure xdd is in the path
type ${XDDCP_XDD_EXE} &>/dev/null
if [ 0 -ne \$? ]; then
    echo "xdd binary is not in the source host PATH"
    exit ${XDDCP_ERR_CODE_XDD_NOT_FOUND}
fi

# Check that the correct version of XDD is available
source_version=\$(${XDDCP_XDD_EXE} -version)
if [ "\$source_version" != "$g_xddcpXddVersion" ]; then
    echo "XDD source and destionation version mismatch."
    exit ${XDDCP_ERR_CODE_VERSION_MATCH}
fi

# Path complement xdd so that iotracing can function
xdd_exe_path=\$(type -P ${XDDCP_XDD_EXE})

# Ensure source side file exists
if [ ! -r "${srcFile}" ]; then
    echo "ERROR: Cannot read source file: ${srcFile}"
    exit ${XDDCP_ERR_CODE_SRC_XST}
fi

# Add the command to the log file
if [ $verbosity -gt 0 ]; then
    src_log="xdd-\$(/bin/hostname)-${srcBase}-${XDDCP_DEFAULT_TIMESTAMP}.log"
else
    src_log=/dev/null
fi

xdd_cmd="${XDDCP_IOTRACE_EXE} \${xdd_exe_path} -targets 1  ${srcFile} -op read -minall ${orderedOpt} ${verboseOpt} ${binaryDumpOpt} -bytes ${totalBytes} -reqsize ${reqSize} -e2e issource ${e2eDestinations} ${srcDIO} ${srcRestart} -output \${src_log} -hb ${XDDCP_DEFAULT_HEARTBEAT_SECS} -hb pct -stoponerror"

# Set iotrace log files location
export TR_RUN_LOG=\${PWD}

# Construct local transport endpoint
echo "Source-side invocation: \${xdd_cmd}" > \${src_log}
\${xdd_cmd}

src_xdd_rc=\$?
if [ \${src_xdd_rc} -ne 0 ]; then
    exit ${XDDCP_ERR_CODE_XFER_FAIL}
fi
EOF
}

#
# Create a directory on the destination side
#
function create_destination_directory {
    local destPath=${1}
    local remoteFlag=${2}
    local destHost=${3}
    local destUser=${4}

    # Create destination commands
    local destCmds="mkdir $destPath"

    # Execute destination side directory creation
    local destResult=""
    local execRC=1
    if [ 1 -eq ${remoteFlag} ]; then
        destResult=$(remote_exec "${destCmds}" "${destHost}" "${destUser}")
        execRC=$?
    else
        destResult=$(local_exec "${destCmds}")
        execRC=$?
    fi

    # Error handling
    if [ 0 -ne $execRC ]; then
        error_exit $execRC
    fi
    return 0
}

#
# Start XDD on the destination side
#
function start_destination_xdd {
    #echo "start_destination_xdd Args: $@" >/dev/stderr
    local srcPath=${1}
    local destPath=${2}
    local totalBytes=${3}
    local queueDepth=${4}
    local e2ePort=${5}
    local dioFlag=${6}
    local forceFlag=${7}
    local orderedFlag=${8}
    local recursionFlag=${9}
    local resumeFlag=${10}
    local verbosity=${11}
    local binaryDumpFlag=${12}
    local remoteFlag=${13}
    local destHost=${14}
    local destIP=${15}
    local destUser=${16}
    local destIfaces=${17}

    # Get destination commands
    local execRC=1
    local destResult=""
    local destCmds=$(get_destination_cmds "$destHost" "$destIP" "$destIfaces" \
        "$queueDepth" "$srcPath" "$destPath" \
        "$totalBytes" "$e2ePort" "$dioFlag" "$forceFlag" "$orderedFlag" \
        "$recursionFlag" "$resumeFlag" "$verbosity" "$binaryDumpFlag")
    execRC=$?
    if [ 0 -ne $execRC ]; then
        error_exit $execRC
    fi

    # Execute destination side commands
    if [ 1 -eq ${remoteFlag} ]; then
        remote_exec_with_fifo "${destCmds}" "${XDDCP_DEFAULT_FIFO_PATH}" "${destIP}" "${destUser}"
        execRC=$?
    else
	error_exit $UNKNOWN
        #destResult=$(local_exec "${destCmds}")
        #execRC=$?
    fi

    if [ 0 -eq $execRC ]; then
        # The destination side pauses to block on IO, 
	# so read the IO to allow the destination to start
	while read line; do
	    echo $line
	    if [ 0 -eq $resumeFlag ]; then
		break;
	    elif [ 1 -eq $resumeFlag ]; then
	        # Search each line for the resume offset
		restartLine=$(echo $line |grep "RESTART TOKENS")
		if [ ! -z "$restartLine" ]; then
		    g_xddcpResumeOffset=$(/bin/echo $restartLine |rev |cut -d ' ' -f 1 |rev)

		    # If the restart value is non-numeric, just set it to 0
		    echo "$g_xddcpResumeOffset" |egrep "^[0-9]+$" &>/dev/null
		    if [ 0 -ne $? ]; then
			g_xddcpResumeOffset=0
		    fi
		    break;
		fi
	    fi
	done < ${XDDCP_DEFAULT_FIFO_PATH}

        # Trigger an error if no restart is found
        if [ 1 -eq $resumeFlag -a -z "$g_xddcpResumeOffset" ]; then
            error_exit $XDDCP_ERR_CODE_INV_RESTART
	fi
    fi

    # Remove the fifo, as it is no longer needed
    rm -f ${XDDCP_DEFAULT_FIFO_PATH}

    return $execRC
}

#
# Start XDD on the source side
#
function start_source_xdd {
    #echo "start_source_xdd Args: $@" >/dev/stderr
    local path=${1}
    local totalBytes=${2}
    local queueDepth=${3}
    local e2ePort=${4}
    local dioFlag=${5}
    local orderedFlag=${6}
    local resumeFlag=${7}
    local verbosity=${8}
    local binaryDumpFlag=${9}
    local resumeOffset=${10}
    local destHost=${11}
    local remoteFlag=${12}
    local srcHost=${13}
    local srcUser=${14}

    # Get source commands
    local execRC=1
    srcCmds=$(get_source_cmds "${destHost}" "${path}" "${totalBytes}" \
	"${queueDepth}" "${e2ePort}" "${dioFlag}" "${orderedFlag}" \
	"${resumeFlag}" "${verbosity}" "${binaryDumpFlag}" "${resumeOffset}")
    execRC=$?
    if [ 0 -ne $execRC ]; then
        error_exit $execRC
    fi

    # Execute source commands
    if [ 1 -eq ${remoteFlag} ]; then
        remote_exec "${srcCmds}" "${srcHost}" "${srcUser}"
        execRC=$?
    else
        local_exec "${srcCmds}"
        execRC=$?
    fi

    return $execRC
}

#
# Perform transfer when the source spec is a file containing a list of files
#
function transfer_file_list {
    local srcFileList=${1}
    local srcHost=${2}
    local srcUser=${3}
    local srcRemoteFlag=${4}
    local srcDIOFlag=${5}
    local srcOrderedFlag=${6}
    local destFileSpec=${7}
    local destHost=${8}
    local destIP=${9}
    local destUser=${10}
    local destRemoteFlag=${11}
    local destDIOFlag=${12}
    local destOrderedFlag=${13}
    local totalBytes=${14}
    local queueDepth=${15}
    local e2ePort=${16}
    local fileSizeFlag=${17}
    local forceFlag=${18}
    local resumeFlag=${19}
    local verbosity=${20}
    local binaryDumpFlag=${21}

    # Perform precondition checks for file list transfers
    check_file_list_preconditions "${srcFileList}" "1" "${fileSizeFlag}" \
	"${resumeFlag}"
    rc=$?
    if [ 0 -ne $rc ]; then
	error_exit $rc
    fi

    # Get all of the source specs and path complement
    local srcFileSpecDir=$(dirname ${srcFileList})
    local fileNames=""
    for name in $(/bin/cat ${srcFileList}); do
	local pathChar=$(dirname $name |cut -c 1)
	if [ "." = "$pathChar" ]; then
	    fileNames="${srcFileSpecDir}/${name} $fileNames"
	else
	    fileNames="$name $fileNames"
	fi
    done

    # Set the path modified file names as the source specs
    srcFileSpecList="$fileNames"
    
    # Process all source file specs
    for srcFileSpec in ${srcFileSpecList}; do

	# Modify the destination path for file list transfers
	local srcFileName=$(/bin/basename ${srcFileSpec})
	destFileSpec=${destPath}/${srcFileName}

        # Parse the source side spec
        srcRemoteFlag=0

	# If we are performing multiple transfers, need to wait for the destination side to hang up
	if [ 0 -ne $g_transferCount ]; then
	    sleep $XDDCP_DEFAULT_NETWORK_SLEEP_SECS
	fi

	#Transfer the file
	transfer_file "${srcFileSpec}" "${srcHost}" "${srcUser}" \
	    "${srcRemoteFlag}" "${srcDIOFlag}" "${srcOrderedFlag}" \
	    "${destFileSpec}" "${destHost}" "${destIP}" "${destUser}" \
	    "${destRemoteFlag}" "${destDIOFlag}" "${destOrderedFlag}" \
	    "${totalBytes}" "${queueDepth}" "${e2ePort}" \
	    "${fileSizeFlag}" "${forceFlag}" "${resumeFlag}" \
	    "${verbosity}" "${binaryDumpFlag}"
	    
	rc=$?

	if [ 0 -ne $rc ]; then
	    echo "INFO: Failure while transferring ${srcFileSpec} to ${destFileSpec}"
            error_exit $rc
	fi
    done
    return 0
}

#
# Perform transfer when the source spec is a recursive path
#
function transfer_recursive_path {
    local srcPath=${1}
    local srcHost=${2}
    local srcUser=${3}
    local srcRemoteFlag=${4}
    local srcDIOFlag=${5}
    local srcOrderedFlag=${6}
    local destPath=${7}
    local destHost=${8}
    local destIP=${9}
    local destUser=${10}
    local destRemoteFlag=${11}
    local destDIOFlag=${12}
    local destOrderedFlag=${13}
    local totalBytes=${14}
    local queueDepth=${15}
    local e2ePort=${16}
    local fileSizeFlag=${17}
    local forceFlag=${18}
    local resumeFlag=${19}
    local verbosity=${20}
    local binaryDumpFlag=${21}

    # Perform precondition checks for file list transfers
    check_file_list_preconditions "${srcFileList}" "1" "${fileSizeFlag}" \
	"${resumeFlag}"
    rc=$?
    if [ 0 -ne $rc ]; then
	error_exit $rc
    fi

    # If the source is a directory, create it on the destination
    if [ -d "$srcPath" ]; then
	# Determine the corresponding destination name for the source name
	# Modify the destination path for file list transfers
	local srcName=$(/bin/basename $srcPath)
	local destFileSpec=${destPath}/${srcName}
	create_destination_directory "${destFileSpec}" "${destRemoteFlag}" "${destIP}" "${destUser}"
	rc=$?
	if [ 0 -ne $rc ]; then
	    echo "INFO: Failure while creating directory ${destFileSpec}"
	    error_exit $rc
	fi
    fi

    # Get names from source spec, if its a directory, transfer its contents recursively
    # Otherwise, just transfer the file and end
    for entry in $(/bin/ls $srcPath); do
	local srcFileSpec=$srcPath/$entry
	local destFileSpec=$destPath/$(basename $srcPath)
	if [ -d "$srcFileSpec" ]; then
	    transfer_recursive_path "${srcFileSpec}" "${srcHost}" "${srcUser}" \
		"${srcRemoteFlag}" "${srcDIOFlag}" "${srcOrderedFlag}" \
		"${destFileSpec}" "${destHost}" "${destIP}" "${destUser}" \
		"${destRemoteFlag}" "${destDIOFlag}" "${destOrderedFlag}" \
		"${totalBytes}" "${queueDepth}" "${e2ePort}" \
		"${fileSizeFlag}" "${forceFlag}" "${resumeFlag}" \
		"${verbosity}" "${binaryDumpFlag}"
	else
	    # If we are performing multiple transfers, need to wait for the destination side to hang up
	    if [ 0 -ne $g_transferCount ]; then
		sleep $XDDCP_DEFAULT_NETWORK_SLEEP_SECS
	    fi

	    #local destFileSpec=$destPath/$(basename $entry)
	    transfer_file "${srcFileSpec}" "${srcHost}" "${srcUser}" \
		"${srcRemoteFlag}" "${srcDIOFlag}" "${srcOrderedFlag}" \
		"${destFileSpec}" "${destHost}" "${destIP}" "${destUser}" \
		"${destRemoteFlag}" "${destDIOFlag}" "${destOrderedFlag}" \
		"${totalBytes}" "${queueDepth}" "${e2ePort}" \
		"${fileSizeFlag}" "${forceFlag}" "${resumeFlag}" \
		"${verbosity}" "${binaryDumpFlag}"

	    rc=$?
	    if [ 0 -ne $rc ]; then
		echo "INFO: Failure while transferring ${srcFileSpec} to ${destFileSpec}"
		error_exit $rc
	    fi
	fi
    done
    return 0
}

#
# Perform transfer for a single file
#
function transfer_file {
    #echo "transfer_file Args: $@" >/dev/stderr
    local srcFileSpec=${1}
    local srcHost=${2}
    local srcUser=${3}
    local srcRemoteFlag=${4}
    local srcDIOFlag=${5}
    local srcOrderedFlag=${6}
    local destFileSpec=${7}
    local destHost=${8}
    local destIP=${9}
    local destUser=${10}
    local destRemoteFlag=${11}
    local destDIOFlag=${12}
    local destOrderedFlag=${13}
    local totalBytes=${14}
    local queueDepth=${15}
    local e2ePort=${16}
    local fileSizeFlag=${17}
    local forceFlag=${18}
    local resumeFlag=${19}
    local verbosity=${20}
    local binaryDumpFlag=${21}

    # Check the transfer preconditions
    check_transfer_preconditions "${srcFileSpec}" "${destFileSpec}" \
	"${srcRemoteFlag}" "${destRemoteFlag}" "${srcDIOFlag}" \
	"${destDIOFlag}" "${fileSizeFlag}" "${totalBytes}"

    # Determine the source file size
    if [ 0 -eq $fileSizeFlag ]; then
        totalBytes=$(get_file_size ${srcFileSpec} \
            ${srcRemoteFlag} ${srcHost} ${srcUser})
    fi

    # Hard code the recursive flag
    recursiveFlag=0

    # Start destination-side XDD (also sets resume offset if needed)
    start_destination_xdd "${srcFileSpec}" "${destFileSpec}" "${totalBytes}" \
        "${queueDepth}" "${e2ePort}" "${destDIOFlag}" "${forceFlag}" \
        "${destOrderedFlag}" "${recursiveFlag}" "${resumeFlag}" \
	"${verbosity}" "${binaryDumpFlag}" \
	"${destRemoteFlag}" "${destHost}" "${destIP}" "${destUser}" "${destIP}"
    destRC=$?

    # Continue if the destination started correctly
    if [ 0 -eq $destRC ]; then
        # Wait to ensure the destination side has setup network and accepting
        sleep $XDDCP_DEFAULT_NETWORK_SLEEP_SECS

        # Start source-side XDD
	start_source_xdd "${srcFileSpec}" "${totalBytes}" \
            "${queueDepth}" "${e2ePort}" "${srcDIOFlag}" \
            "${srcOrderedFlag}" "${resumeFlag}" \
	    "${verbosity}" "${binaryDumpFlag}" \
            "${g_xddcpResumeOffset}" "${destHost}" \
            "${srcRemoteFlag}" "${srcHost}" "${srcUser}"
	srcRC=$?

	# Wait on the destination side
	wait
	destRC=$?

	# Increment the transfer count if the source completed successfully
	if [ 0 -ne $destRC ]; then
	    rc=$destRC
	    echo "INFO: Destination-side XDD exited with an error: $destRC" >/dev/stderr
	    echo "INFO: Source-side XDD exited with code: $srcRC" >/dev/stderr
	elif [ 0 -ne $srcRC ]; then
	    rc=$srcRC
	    echo "INFO: Source-side XDD exited with an error: $srcRC" >/dev/stderr
	else
	    # Signal success
	    rc=0

            # Increment the number of transfers
	    g_transferCount=$((g_transferCount+1))
	fi
    else
	rc=$destRC
	echo "INFO: Destination-side XDD exited with an error during launch: $destRC" >/dev/stderr
    fi
 
    return $rc
}

#
# Fetches the binary ts dump, calculates running bandwidth
#    during the transfer, and plots the xfer if gnuplot is available.
#
function post_transfer_analysis {
	local srcPath=${1}
	local srcHost=$(/bin/hostname -s)
	local srcUser=${3}
	local destPath=${4}
	local destHost=${5}
	local destIP=${6}
	local destUser=${7}
	local windowSize=${8}
	local kernelTrace=${9}

	# where the timestamp dumps should be right now
	local srcBase=$(/bin/basename $srcPath)
	local dstBase=$(/bin/basename $destPath)
	local srcBinDump="xdd-$(/bin/hostname)-${srcBase}-${XDDCP_DEFAULT_TIMESTAMP}.target.0000.bin"
	local dstBinDump="xdd-${destHost}-${dstBase}-${XDDCP_DEFAULT_TIMESTAMP}.target.0000.bin"
	local dstCsvFile="xdd-${destHost}-${dstBase}-${XDDCP_DEFAULT_TIMESTAMP}.target.0000.csv"
	local dstLogFile="xdd-${destHost}-${dstBase}-${XDDCP_DEFAULT_TIMESTAMP}.log"

	# where our data will be stored afterwards
	local dataDir="${srcHost}_to_${destHost}_${srcBase}_${XDDCP_DEFAULT_TIMESTAMP}"
	local myLogFile="${dataDir}/post_transfer_analysis.log"
	local newSrcBin="${dataDir}/src_${srcHost}.bin"
	local newDstBin="${dataDir}/dest_${destHost}.bin"
	local tsDataFile="${dataDir}/xfer.dat"
	local plotPrefix="${dataDir}/xfer"

	echo "Running post transfer analysis... "

	# create data directory and check for writability
	mkdir ${dataDir}
	if [ ! -d ${dataDir} ] || [ ! -w ${dataDir} ]; then
		echo "INFO: Can not write to ${dataDir}.  Skipping analysis." >/dev/stderr
		return 1
	fi

	# print a helpful tidbit to the logfile
	echo "To change the sliding window size without rerunning the transfer, run:" >> ${myLogFile}
	echo "    $XDDCP_READTSDUMPS_EXE -t [window_size] -o xfer.dat src_${srcHost}.bin dest_${destHost}.bin" >> ${myLogFile}
	echo "    $XDDCP_PLOTTSDUMPS_EXE xfer.dat xfer" >> ${myLogFile}
	echo "" >> ${myLogFile}

	# copy local bin file
	cp ${srcBinDump} ${newSrcBin} >> ${myLogFile} 2>&1
	if [ 0 -ne $? ]; then
		echo "INFO: Failed to copy ${srcBinDump}.  Skipping analysis" >/dev/stderr
		return 1
	fi
	# get/copy destination bin file from destination to source host
	local destRC=""
	if [ ! -z "${destUser}" ]; then
		sshOpts="-q -l $remoteUser"
	fi
	(ssh ${sshOpts} ${destIP} /bin/bash --login <<EOF
# If the supplied destination is a directory, append the source file name
destination_file=${destPath}
destination_dir=\$(dirname ${destPath})
if [ -d ${destPath} ]; then
	destination_file=${destPath}/${srcBase}
	destination_dir=${destPath}
fi
# If the filename uses a relative path, path complement it
path_char=\$(dirname \$destination_file |cut -c 1)
if [ "." = \$path_char ]; then
	destination_dir="\$(/bin/pwd)/\${destination_dir}"
fi
# If insufficient permissions for the log exist, direct to HOME
if [ ! -w \$destination_dir ]; then
	destination_dir="./"
fi
# send the file back through cpio
cd \${destination_dir}
ls ${dstBinDump} | /bin/cpio -o 2>/dev/null
EOF
) | /bin/cpio -i >> ${myLogFile} 2>&1
	destRC=$?
	cp ${dstBinDump} ${newDstBin} >> ${myLogFile} 2>&1
	if [ 0 -ne $destRC ]; then
		echo "INFO: Failed to copy ${dstBinDump} over ssh.  Skipping analysis" >/dev/stderr
		return 1
	fi

	# get/copy destination log file from destination to source host
        (ssh ${sshOpts} ${destIP} /bin/bash --login <<EOF
# Really after destination log file which should be here by all previous checks
# If the supplied destination is a directory, append the source file name
destination_file=${destPath}
destination_dir=\$(dirname ${destPath})
if [ -d ${destPath} ]; then
        destination_file=${destPath}/${srcBase}
        destination_dir=${destPath}
fi
# If the filename uses a relative path, path complement it
path_char=\$(dirname \$destination_file |cut -c 1)
if [ "." = \$path_char ]; then
        destination_dir="\$(/bin/pwd)/\${destination_dir}"
fi
# If insufficient permissions for the log exist, direct to HOME
if [ ! -w \$destination_dir ]; then
        destination_dir="./"
fi
# send the file back through cpio
cd \${destination_dir}
ls ${dstLogFile} | /bin/cpio -o 2>/dev/null
EOF
) | /bin/cpio -i >> ${myLogFile} 2>&1

        # get/copy destination timestamp csv file from destination to source host
        (ssh ${sshOpts} ${destIP} /bin/bash --login <<EOF
# Really after destination log file which should be here by all previous checks
# If the supplied destination is a directory, append the source file name
destination_file=${destPath}
destination_dir=\$(dirname ${destPath})
if [ -d ${destPath} ]; then
        destination_file=${destPath}/${srcBase}
        destination_dir=${destPath}
fi
# If the filename uses a relative path, path complement it
path_char=\$(dirname \$destination_file |cut -c 1)
if [ "." = \$path_char ]; then
        destination_dir="\$(/bin/pwd)/\${destination_dir}"
fi
# If insufficient permissions for the log exist, direct to HOME
if [ ! -w \$destination_dir ]; then
        destination_dir="./"
fi
# send the file back through cpio
cd \${destination_dir}
ls ${dstCsvFile} | /bin/cpio -o 2>/dev/null
EOF
) | /bin/cpio -i >> ${myLogFile} 2>&1

	# get/copy destination iotrace_data.out file from destination to source host
	if [ 1 -eq $kernelTrace ]; then
        (ssh ${sshOpts} ${destIP} /bin/bash --login <<EOF
# Really after destination log file which should be here by all previous checks
# If the supplied destination is a directory, append the source file name
destination_file=${destPath}
destination_dir=\$(dirname ${destPath})
if [ -d ${destPath} ]; then
        destination_file=${destPath}/${srcBase}
        destination_dir=${destPath}
fi
# If the filename uses a relative path, path complement it
path_char=\$(dirname \$destination_file |cut -c 1)
if [ "." = \$path_char ]; then
        destination_dir="\$(/bin/pwd)/\${destination_dir}"
fi
# If insufficient permissions for the log exist, direct to HOME
if [ ! -w \$destination_dir ]; then
        destination_dir="./"
fi
# send the file back through cpio
cd \${destination_dir}
ls iotrace_data*out | /bin/cpio -o 2>/dev/null
EOF
) | /bin/cpio -i >> ${myLogFile} 2>&1
fi
	destRC=$?
	if [ 0 -ne $destRC ]; then
		echo "INFO: Failed to copy iotrace_data.pid.out over ssh.  Skipping analysis" >/dev/stderr
		return 1
	fi

	# read the tsdumps and plot output
	if [ 1 -eq $kernelTrace ]; then
        # Set iotrace log files location
          export TR_RUN_LOG=\${PWD}
	  $XDDCP_READTSDUMPS_EXE -t ${windowSize} -k -o ${tsDataFile} ${newSrcBin} ${newDstBin} >> ${myLogFile} 2>&1
	else
	  $XDDCP_READTSDUMPS_EXE -t ${windowSize}    -o ${tsDataFile} ${newSrcBin} ${newDstBin} >> ${myLogFile} 2>&1
	fi
	if [ 0 -ne $? ]; then
		echo "INFO: Failed to read timestamp dumps in ${dataDir}.  Skipping analysis" >/dev/stderr
		return 1
	fi
	$XDDCP_PLOTTSDUMPS_EXE ${tsDataFile} ${plotPrefix} >> ${myLogFile} 2>&1
	if [ 0 -ne $? ]; then
		echo "INFO: Failed to plot analysis data.  Skipping gnuplot" >/dev/stderr
		return 1
	fi
	if [ 1 -eq $kernelTrace ]; then
  	  $XDDCP_PLOTTSDUMPS_EXE ${tsDataFile}.k ${plotPrefix}k >> ${myLogFile} 2>&1
       	  if [ 0 -ne $? ]; then
		echo "INFO: Failed to plot analysis data, kernel files.  Skipping gnuplot" >/dev/stderr
		return 1
	  fi
  	  $XDDCP_PLOTTSDUMPSDK_EXE ${tsDataFile}.k.d ${plotPrefix}d >> ${myLogFile} 2>&1
       	  if [ 0 -ne $? ]; then
		echo "INFO: Failed to plot analysis data, kernel files.  Skipping gnuplot" >/dev/stderr
		return 1
	  fi
	fi

	echo "done"
}

#
# XDDCP Main
#
function xddcp_main {
    #echo "main Args: $@"
    #
    # Install necessary signal handlers
    #
    # Note: We still need to pass the signal thru for Posix compliance.  See
    #  http://www.cons.org/cracauer/sigint.html
    #
    trap 'handle_signal_common 2; trap 2; echo "sending 2"; kill -2 $$' 2 
    trap 'handle_signal_common 3; trap 3; echo "sending 3"; kill -3 $$' 3 
    trap 'handle_signal_common 15; trap 15; echo "sending 15"; kill -15 $$' 15
    trap exit

    # Print a helpful message if user is just typing command to get syntax
    if [ "$1" = "-h" ]; then
        print_usage
        return 0
    elif [ $# -lt 2 ]; then
        echo "usage: $0 [OPTION] /full_path/source_file destination_host:/full_path/destination_file [bytes_to_transfer]"
        echo "Try '$0 -h' for more information."
        return $XDDCP_ERR_CODE_INVALID_ARGS
    fi

    # Parse options
    destDIOFlag=0
    destOrderedFlag=0
    e2ePort=$XDDCP_DEFAULT_E2E_PORT
    fileListFlag=0
    fileListFile=""
    forceFlag=1
    queueDepth=$XDDCP_DEFAULT_QUEUE_DEPTH
    recursiveFlag=0
    retryCount=0
    resumeFlag=0
    srcDIOFlag=0
    srcOrderedFlag=0
    sshOption=$XDDCP_DEFAULT_SSH_PSEUDO_TERMINAL_OPT
    verbosity=0
    binaryDumpFlag=0
    kernelTraceFlag=0
    windowSize=0

    while getopts ":FYacd:hn:o:p:rst:vVw:W:" option; do
        case $option in
            F) 
                fileListFlag=1
		fileListFile=$OPTARG
                ;;
            Y) 
                sshOption="-tt"
                ;;
            a) 
                resumeFlag=1
                ;;
            c)
                forceFlag=0
                ;;
	    d) 
		if [ "$OPTARG" = "dest" -o "$OPTARG" = "d" ]; then
                    destDIOFlag=1
		elif [ "$OPTARG" = "source" -o "$OPTARG" = "s" ]; then
		    srcDIOFlag=1
		elif [ "$OPTARG" = "both" -o "$OPTARG" = "b" -o "$OPTARG" = "sd" ]; then
		    destDIOFlag=1
		    srcDIOFlag=1
		else
                    echo "INFO: Unsupported dio argument: -$option $OPTARG" >/dev/stderr 
                    error_exit $XDDCP_ERR_CODE_INVALID_ARGS
		fi
                ;;
	    f) 
                forceFlag=1
                ;;
	    h) 
                print_usage 
                return 0
                ;;
	    n)
		retryCount=$OPTARG
		;;
            o) 
		if [ "$OPTARG" = "dest" -o "$OPTARG" = "d" ]; then
                    destOrderedFlag=1
		elif [ "$OPTARG" = "source" -o "$OPTARG" = "s" ]; then
		    srcOrderedFlag=1
		elif [ "$OPTARG" = "both" -o "$OPTARG" = "b" -o "$OPTARG" = "sd" ]; then
		    destOrderedFlag=1
		    srcOrderedFlag=1
		else
                    echo "INFO: Unsupported dio argument: -$option $OPTARG" >/dev/stderr 
                    error_exit $XDDCP_ERR_CODE_INVALID_ARGS
		fi
                ;;
            p) 
                e2ePort=$OPTARG
                ;;
	    r) 
                recursiveFlag=1
                ;;
	    t) 
                queueDepth=$OPTARG
                ;;
	    v) 
		if [ $verbosity -lt 1 ]; then
                    verbosity=1
		fi
                ;;
	    V) 
		if [ $verbosity -lt 2 ]; then
                    verbosity=2
		fi
                ;;
	    w) 
                verbosity=2
		binaryDumpFlag=1
		windowSize=$OPTARG
		expr $windowSize + 1 >/dev/null 2>&1
		if [ $? -ne 0 ]; then
			echo "INFO: Window size (-w arg) must be an integer." >/dev/stderr
			error_exit $XDDCP_ERR_CODE_INVALID_ARGS
		elif [ $windowSize -le 0 ]; then
			echo "INFO: Window size (-w arg) must be greater than zero." >/dev/stderr
			error_exit $XDDCP_ERR_CODE_INVALID_ARGS
		fi
                ;;
	    W) 
                verbosity=2
		binaryDumpFlag=1
		kernelTraceFlag=1
		windowSize=$OPTARG
		expr $windowSize + 1 >/dev/null 2>&1
		if [ $? -ne 0 ]; then
			echo "INFO: Window size (-w arg) must be an integer." >/dev/stderr
			error_exit $XDDCP_ERR_CODE_INVALID_ARGS
		elif [ $windowSize -le 0 ]; then
			echo "INFO: Window size (-w arg) must be greater than zero." >/dev/stderr
			error_exit $XDDCP_ERR_CODE_INVALID_ARGS
		fi
                XDDCP_IOTRACE_EXE=$(type -P iotrace_init)
                if [ $? -ne 0 ]; then
                    echo "INFO: kernel trace mode requires the 'iotrace_init' command. Install or use -w option."
                    error_exit $XDDCP_ERR_CODE_MISSING_KERNEL_TRACE_COMPONENT
                fi
                if [ ! -c /dev/iotrace_data ]; then
                    echo "INFO: kernel trace mode requires the '/dev/iotrace_data' device. Install or use -w option."
                    error_exit $XDDCP_ERR_CODE_MISSING_KERNEL_TRACE_COMPONENT
                fi
                XDDCP_IOTRACE_DECODE=$(type -P decode)
                if [ $? -ne 0 ]; then
                    echo "INFO: kernel trace mode requires the 'decode' command. Install or use -w option."
                    error_exit $XDDCP_ERR_CODE_MISSING_KERNEL_TRACE_COMPONENT
                fi
                ;;
            \?)
                echo "INFO: Unsupported option: -$option $OPTARG" >/dev/stderr 
                error_exit $XDDCP_ERR_CODE_INVALID_ARGS
                ;;
        esac
    done
    shift $((OPTIND-1))

    # Get the source path
    srcPath="${1}"
    srcRemoteFlag=0

    # Parse the destination endpoint spec
    destRemoteFlag=0
    parse_endpoint_spec "${2}" destRemoteFlag destUser destHost destPath

    # Get the specified size if it is defined
    fileSizeFlag=0
    totalBytes=0
    if [ ! -z "${3}" ]; then
        fileSizeFlag=1
        totalBytes=${3}
    fi

    # Ensure local option preconditions are met
    check_host_preconditions ${srcPath} ${fileListFlag} ${fileSizeFlag} \
	${recursiveFlag} ${resumeFlag} ${forceFlag}

    # The force flag only works on Linux, disable it everywhere else
    if [ "Linux" != "$(/bin/uname)" ]; then
	forceFlag=0
	echo "Warning: File transfer forcing disabled for non-Linux platforms." >/dev/stderr
    fi

    # Convert the destination host to its IP to avoid DNS round-robin issues
    $XDDCP_GETHOSTIP_EXE -d $destHost &> /dev/null
    if [ 0 -ne $? ]; then
        error_exit $XDD_ERR_CODE_DEST_IP
    fi
    destIP=$($XDDCP_GETHOSTIP_EXE -d $destHost)

    # Retry on failed transfer
    retries=0
    while [ $retries -le $retryCount ]; do
        # Transfer according to source input type
	rc=0
	if [ 1 -eq $fileListFlag ]; then
	    transfer_file_list "${srcPath}" "${srcHost}" "${srcUser}"\
	        "${srcRemoteFlag}" "${srcDIOFlag}" "${srcOrderedFlag}" \
		"${destPath}" "${destHost}" "${destIP}" "${destUser}" \
		"${destRemoteFlag}" "${destDIOFlag}" "${destOrderedFlag}" \
		"${totalBytes}" "${queueDepth}" "${e2ePort}" \
		"${fileSizeFlag}" "${forceFlag}" "${resumeFlag}" \
		"${verbosity}" "${binaryDumpFlag}"
	    rc=$?
	elif [ 1 -eq $recursiveFlag ]; then
	    transfer_recursive_path "${srcPath}" "${srcHost}" "${srcUser}"\
	        "${srcRemoteFlag}" "${srcDIOFlag}" "${srcOrderedFlag}" \
		"${destPath}" "${destHost}" "${destIP}" "${destUser}" \
		"${destRemoteFlag}" "${destDIOFlag}" "${destOrderedFlag}" \
		"${totalBytes}" "${queueDepth}" "${e2ePort}" \
		"${fileSizeFlag}" "${forceFlag}" "${resumeFlag}" \
		"${verbosity}" "${binaryDumpFlag}"
	    rc=$?
	else
	    transfer_file "${srcPath}" "${srcHost}" "${srcUser}"\
	        "${srcRemoteFlag}" "${srcDIOFlag}" "${srcOrderedFlag}" \
		"${destPath}" "${destHost}" "${destIP}" "${destUser}" \
		"${destRemoteFlag}" "${destDIOFlag}" "${destOrderedFlag}" \
		"${totalBytes}" "${queueDepth}" "${e2ePort}" \
		"${fileSizeFlag}" "${forceFlag}" "${resumeFlag}" \
		"${verbosity}" "${binaryDumpFlag}"
	    rc=$?
	fi

	echo "XDDCP: Transfer status was: $rc"

	# Perform post transfer analysis
	if [ 1 -eq ${binaryDumpFlag} ]; then
	    post_transfer_analysis "${srcPath}" "${srcHost}" "${srcUser}" \
		"${destPath}" "${destHost}" "${destIP}" "${destUser}" "${windowSize}" \
		"${kernelTraceFlag}"
	fi

	# On successful transfer complete without any more retries
	if [ 0 -eq $rc ]; then
	    echo ""
	    echo "Transfer complete.  Verify results with md5sum."
	    break
	elif [ $retries -lt $retryCount ]; then
	    # Print a retry message
            retries=$((retries+1))
	    echo "Transfer failed.  Retry attempt: $retries"
	    sleep $XDDCP_DEFAULT_RETRY_SLEEP_SECS
	    reset_global_data
	else
	    echo "Transfer failed.  Error code: $rc"
	    break
	fi
    done

    return $rc
}

#
# Execute xddcp
#
xddcp_main "$@"
exit $?
