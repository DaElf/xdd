#!/bin/bash
#
# This is the multi-host XDD data movement script.  If you want to move a 
# file from a single source to a single destination, you probably want xddcp.  
# The xddcp script works similarly to bbcp and scp, it just drives the disk 
# alot faster.  But if you're here, then you want to go faster than a single 
# host can drive.  Welcome to where the sidewalk ends.
#

#
# Global constants
#
XDDMCP_CONNECT_DELAY_SECS=0
XDDMCP_DEFAULT_CONFIG=".xddmcprc"
XDDMCP_ORDER_LOOSE_ID=1
XDDMCP_ORDER_NONE_ID=2
XDDMCP_ORDER_SERIAL_ID=3
XDDMCP_ORDER_STRICT_ID=4

#
# Error codes
#
XDDMCP_INVALID_CMD_LINE=1
XDDMCP_INVALID_CONFIG=2
XDDMCP_INVALID_FLOW_SPEC=3
XDDMCP_INVALID_NET_SPEC=4
XDDMCP_INVALID_STORAGE_SPEC=5
XDDMCP_INVALID_CONFIG_SYNTAX=6

#
# Global variables
#
declare -a g_hostNames[0]=0
declare -a g_hostIfaces[0]=0

declare -a g_networkNames[0]=0
declare -a g_networkThreads[0]=0

declare -a g_storageNames[0]=0
declare -a g_storageDIO[0]=0
declare -a g_storageOrdering[0]=0

declare -i g_flowCount=0
declare -a g_flowSrcHostId[0]
declare -a g_flowSrcStorageId[0]
declare -a g_flowNetworkId[0]
declare -a g_flowDestHostId[0]
declare -a g_flowDestStorageId[0]

#
# Print out the usage information
#
function xddmcp_print_usage() {
    echo "xddmcp [OPTIONS] source_file destination_file [size]"
    echo ""
    echo "source_file       - complete /filepath/name for source file on source host"
    echo "destination_file  - complete /filepath/name for destination file on "
    echo "                    destination host"
    echo "size              - number of bytes to transfer [Default: size of source file]"
    echo ""
    echo "OPTIONS: "
    echo " -a		- Resume transfer if it was only partially completed "
    echo "                and the -a flag was specified"
    echo " -c <file>    - Provide an xddmcp config file"
    echo " -h		- Print out usage information"
    echo "NOTE: 'xdd.Linux' must be in your PATH on both source and destination hosts!!"
}

#
# Add xddcp functions to namespace
#
function xddmcp_include_xddcp() {

    # This is done to reuse the transfer functions of xddcp.  It's slightly messy, 
    # but if you are reading the source to *this* script, then you are already in 
    # the weeds and signed up for understanding complexity.  We overload exit 
    # because trap EXIT doesn't prevent an eventual call to exit.  We then unset 
    # the overload after sourcing the appropriate file(s).
    #
    xddcp_path=$(which xddcp)
    if [ -f "$xddcp_path" ]; then
        exit() { :; }
        source $xddcp_path >/dev/null
        unset -f exit
    else
        echo "ERROR: Could not find xddcp"
        exit 1
    fi

    # Set XDDCP use preconditions
    g_xddcpXddVersion=$(${XDDCP_DEFAULT_XDD} -version)
}

#
# Locate xddmcp config file from several possible locations
#
function xddmcp_locate_config_file() {
    local configFile=$1

    if [ -z "$configFile" ]; then
	# Check environment variable
	if [ ! -z "$XDD_CONFIG_FILE" -a -f "$XDD_CONFIG_FILE" ]; then
	    configFile=$XDD_CONFIG_FILE
	# Check home directory
	elif [ -f "$HOME/xddmcp.conf" ]; then
	    configFile=$HOME/xddmcp.conf
	# Check /etc
	elif [ -f /etc/xddmcp.conf ]; then
	    configFile=/etc/xddmcp.conf
	fi
    fi
    echo "$configFile"
}

#
# Parse a xddmcp host entry
#
function xddmcp_parse_host_entry() {
    local hostName=$1
    local hostSpec=$2

    # Setup the host data
    declare -i idx=${#g_hostNames[@]}
    g_hostNames[$idx]=$hostName
    g_hostIfaces[$idx]=$hostSpec    
    return 0
}

#
# Parse a xddmcp network entry
#
function xddmcp_parse_network_entry() {
    local networkName=$1
    local networkSpec=$2

    # Parse thread count and DIO out of channel spec
    declare -i threads=$(echo $networkSpec |cut -f 1);
    if [ 1 -gt "$threads" ]; then
	echo "ERROR: Invalid thread count."
	exit $XDDMCP_INVALID_NET_SPEC
    fi

    # Setup the channel data
    declare -i idx=${#g_networkNames[@]}
    g_networkNames[$idx]=$networkName
    g_networkThreads[$idx]=$threads    
    return 0
}

#
# Parse a xddmcp storage entry
#
function xddmcp_parse_storage_entry() {
    local storageName=$1
    local storageOpts=$2

    # Parse DIO flag out
    local dioFlag=$(echo $storageOpts |grep -c -i dio)
    if [ 1 -lt $dioFlag ]; then
	dioFlag=1
    fi

    # Parse thread ordering
    local orderId=$XDDMCP_ORDER_NONE_ID
    declare -u orderString=$(echo $storageOpts |grep -o -i -e "(loose|strict|none)")
    if [ -z "$orderString" ]; then
	orderId=$XDDMCP_ORDER_NONE_ID
    elif [ "LOOSE" = "$orderString" ]; then
	orderId=$XDDMCP_ORDER_LOOSE_ID
    elif [ "NONE" = "$orderString" ]; then
	orderId=$XDDMCP_ORDER_NONE_ID
    elif [ "SERIAL" = "$orderString" ]; then
	orderId=$XDDMCP_ORDER_SERIAL_ID
    else
	echo "ERROR: Unsupported ordering option: $orderString"
	exit $XDDMCP_INVALID_STORAGE_SPEC
    fi

    # Setup the storage data
    #echo "Channel $channelName: $threads $srcDIO $destDIO"
    declare -i idx=${#g_storageNames[@]}
    g_storageNames[$idx]=$storageName
    g_storageDIO[$idx]=$dioFlag
    g_storageOrdering[$idx]=$orderId
    return 0
}

#
# Parse a xddmcp flow entry
#
function xddmcp_parse_flow_entry() {
    local token=$1
    local connectionSpec=$2
    #echo "Flow: $token $connectionSpec"
    
    # Source storage id
    local srcStore=$token
    declare -i srcStoreId=-1
    declare -i storageCount=${#g_storageNames[@]}
    for ((i=0; i<$storageCount; i+=1)); do
	if [ "$srcStore" = "${g_storageNames[$i]}" ]; then
	    srcStoreId=$i
	    break
	fi
    done
    if [ -1 -eq $srcStoreId ]; then
	echo "ERROR: Unknown source storage name: $srcStore" >/dev/stderr
	exit $XDDMCP_INVALID_FLOW_SPEC
    fi
    
    # Skip ->

    # Source host id
    local srcHost=$(echo $connectionSpec |cut -f 2 -d ' ')
    declare -i srcHostId=-1
    declare -i hostCount=${#g_storageNames[@]}
    for ((i=0; i<$hostCount; i+=1)); do
	if [ "$srcHost" = "${g_hostNames[$i]}" ]; then
	    srcHostId=$i
	    break
	fi
    done
    if [ -1 -eq $srcHostId ]; then
	echo "ERROR: Unknown source host name: $srcHost" >/dev/stderr
	exit $XDDMCP_INVALID_FLOW_SPEC
    fi

    # Skip ->

    # Parse determine network
    local networkName=$(echo $connectionSpec |cut -f 4 -d ' ')
    declare -i networkId=-1
    declare -i networkCount=${#g_networkNames[@]}
    for ((i=0; i<$networkCount; i+=1)); do
	if [ "$networkName" = "${g_networkNames[$i]}" ]; then
	    networkId=$i
	    break
	fi
    done
    if [ -1 -eq $networkId ]; then
	echo "ERROR: Unknown network name: $networkName" >/dev/stderr
	exit $XDDMCP_INVALID_FLOW_SPEC
    fi
    
    # Skip ->

    # Determine if host has an interface of not
    local destHost=$(echo $connectionSpec |cut -f 6 -d ' ')
    declare -i destHostId=-1
    for ((i=0; i<$hostCount; i+=1)); do
	if [ "$destHost" = "${g_hostNames[$i]}" ]; then
	    destHostId=$i
	    break
	fi
    done
    if [ -1 -eq $destHostId ]; then
	echo "ERROR: Unknown destination host name: $destHost" >/dev/stderr
	exit $XDDMCP_INVALID_FLOW_SPEC
    fi

    # Skip ->

    # Determine the destination store
    local destStore=$(echo $connectionSpec |cut -f 8 -d ' ')
    declare -i destStoreId=-1
    for ((i=0; i<$storageCount; i+=1)); do
	if [ "$destStore" = "${g_storageNames[$i]}" ]; then
	    destStoreId=$i
	    break
	fi
    done
    if [ -1 -eq $destStoreId ]; then
	echo "ERROR: Unknown storage name for destination: $srcStore" >/dev/stderr
	exit $XDDMCP_INVALID_FLOW_SPEC
    fi

    # Construct the connection
    declare -i idx=$g_flowCount
    g_flowSrcStorageId[$idx]=$srcStoreId
    g_flowSrcHostId[$idx]=$srcHostId
    g_flowNetworkId[$idx]=$networkId
    g_flowDestHostId[$idx]=$destHostId
    g_flowDestStorageId[$idx]=$destStoreId
    #echo "Added flow: ${g_flowSrcStorageId[$idx]} ${g_flowSrcHostId[$idx]} ${g_flowNetworkId[$idx]} ${g_flowDestHostId[$idx]} ${g_flowDestStorageId[$idx]}"

    # Increment the connection count
    g_flowCount=$((g_flowCount + 1))
    return 0
}


#
# Parser for xddmcp config files (only requires lexical analysis)
#
function xddmcp_parse_config() {
    local configFile=$1

    local tok0=""
    local remainder=""
    local state="null"
    local lp=0
    while read tok0 remainder; do
        lp=$((lp + 1))
        local res=1
        local first_char=$(echo "$tok0"| cut -c1)
        if [ "#" == "$first_char" -o -z "$tok0" ]; then
            continue
        elif [ "[" == "$first_char" ]; then
            state=$tok0
            if [ "[flows]" == "$state" -o "[network]" == "$state" \
		-o "[storage]" == "$state" -o "[host]" == "$state" ]; then
                res=0
            fi
        elif [ "[host]" == "$state" -a ! -z "$tok0" ]; then
            xddmcp_parse_host_entry "$tok0" "$remainder"
            res=$?
        elif [ "[flows]" == "$state" -a ! -z "$tok0" ]; then
            xddmcp_parse_flow_entry "$tok0" "$remainder"
            res=$?
        elif [ "[network]" == "$state"  -a ! -z "$tok0" ]; then
            xddmcp_parse_network_entry "$tok0" "$remainder"
            res=$?
        elif [ "[storage]" == "$state"  -a ! -z "$tok0" ]; then
            xddmcp_parse_storage_entry "$tok0" "$remainder"
            res=$?
        fi

        if [ 0 -ne "$res" ]; then
            echo "$configFile: line $lp: Invalid config syntax"
            exit 37
        fi
    done < $configFile

    echo "Config successfully parsed."
}

#
# Partition the file evenly among the number of processes on 1024-byte aligned
# boundaries
#
function xddmcp_partition() {
    local fileSize=$1
    local rank=$2
    local size=$3
    local outBegin=$4
    local outPartitionSize=$5

    # Determine the partion beginning
    local partLB=0
    let "partLB = ($rank * ($fileSize / 1024) / $size) * 1024"
    echo "partLB = $partLB"

    # Determine the partition end
    local partUB=0
    if [ $rank -eq $((size-1)) ]; then
        let "partUB = $fileSize"
    else
        let "partUB = (($rank + 1) * ($fileSize / 1024) / $size) * 1024"
    fi
    echo "partUB = $partUB"

    # Set the outbound parameters
    let "$outBegin=$partLB"
    let "$outPartitionSize= $partUB - $partLB"
}

#
# Start destination sides
#
function xddmcp_start_destinations() {
    local fileSize=$1

    # Start destinations
    local rankOffset=0
    local rankPartSize=0
    for ((i=0; i < $g_flowCount; i+=1)); do
        xddmcp_partition $fileSize $i $g_flowCount rankOffset rankPartSize

	# Get the destination host
	declare -i destHostId=${g_flowDestHostId[$i]}
	local destHost=${g_hostNames[$destHostId]}
	local destIfaces=${g_hostIfaces[$destHostId]}

	# Get the number of network threads
	declare -i networkId=${g_flowNetworkId[$i]}
	declare -i threadCount=${g_networkThreads[$networkId]}

	# Get the storage DIO flag and ordering
	declare -i storageId=${g_flowDestStorageId[$i]}
	declare -i dioFlag=${g_storageDIO[$storageId]}
	declare -i orderId=${g_storageOrdering[$storageId]}

	# Flag settings
	local forceFlag=0
	local orderedFlag=0
	local recursionFlag=0
	local resumeFlag=0
	local verboseFlag=0
	local remoteFlag=1

        echo "Start dest: $destHost $destIfaces $threadCount $dioFlag $orderId $rankOffset $rankPartSize"
	start_destination_xdd $srcPath $destPath $rankPartSize $threadCount \
	    40010 $dioFlag $forceFlag $orderedFlag $recursionFlag $resumeFlag \
	    $verboseFlag $remoteFlag $destHost bws $destIfaces
    done
}

#
# Start source sides
#
function xddmcp_start_sources() {
    local fileSize=$1

    # Start the sources to initiate transfers
    local rankOffset=0
    local rankPartSize=0
    for ((i=0; i < $g_flowCount; i+=1)); do
        xddmcp_partition $fileSize $i $g_flowCount rankOffset rankPartSize

	# Get the destination host
	declare -i destHostId=${g_flowDestHostId[$i]}
	local destHost=${g_hostNames[$destHostId]}
	local destIfaces=${g_hostIfaces[$destHostId]}

	# Get the source host
	declare -i srcHostId=${g_flowSrcHostId[$i]}
	local host=${g_hostNames[$srcHostId]}
	local ifaces=${g_hostIfaces[$srcHostId]}

	# Get the number of network threads
	declare -i networkId=${g_flowNetworkId[$i]}
	declare -i threadCount=${g_networkThreads[$networkId]}

	# Get the storage DIO flag and ordering
	declare -i storageId=${g_flowSrcStorageId[$i]}
	declare -i dioFlag=${g_storageDIO[$storageId]}
	declare -i orderId=${g_storageOrdering[$storageId]}

        echo "Start source: $host $ifaces $threadCount $dioFlag $orderId $rankOffset $rankPartSize"

#	start_source_xdd $srcPath $rankPartSize \
#		${g_channelThreads[$channelIdx]} 40010 \
#		${g_channelSrcDIO[$channelIdx]} 0 0 0 0 \
#		${g_connectionDest[$i]} 1 \
#		${g_connectionSrc[$i]} bws &
    done

}

#
# Main
#
function xddmcp_main() {

    #
    # Install necessary signal handlers
    #
    # Note: We still need to pass the signal thru for Posix compliance.  See
    #  http://www.cons.org/cracauer/sigint.html
    #
    trap 'handle_signal_common; trap 2; kill -2 $$' 2 
    trap 'handle_signal_common; trap 3; kill -3 $$' 3 
    trap 'handle_signal_common; trap 15; kill -15 $$' 15

    # Parse arguments
    if [ 2 -gt $# ]; then
	xddmcp_print_usage
	exit 12
    fi

    # Parse options
    local configFile=""
    local resumeFlag=0
    local verboseFlag=0

    while getopts ":ac:hv" option; do
        case $option in
            a) 
                resumeFlag=1
                ;;
	    c) 
                configFile=$OPTARG
                ;;
	    h) 
                print_usage 
                return 0
                ;;
	    v) 
                verboseFlag=1
                ;;
            \?)
                echo "INFO: Unsupported option: -$OPTARG" >/dev/stderr 
                error_exit $XDDCP_ERR_CODE_INVALID_ARGS
                ;;
        esac
    done
    shift $((OPTIND-1))

    #
    # Get the source and destination paths
    #
    srcPath=$1
    destPath=$2

    #
    # Validate supplied arguments
    #
    if [ -z "$srcPath" ]; then
	echo "ERROR: Invalid source path specified."
	exit 1
    elif [ -z "$destPath" ]; then
	echo "ERROR: Invalid destination path specified."
	exit 1
    fi

    # Locate config
    configFile=$(xddmcp_locate_config_file $configFile)
    if [ ! -r "$configFile" ]; then
        echo "Can't read config: $configFile"
        exit -1
    fi
    echo "INFO: Using config: $configFile"

    # Parse config
    xddmcp_parse_config $configFile

    # Check source file preconditions
    declare -i fileSize=0
    if [ -r $srcPath ]; then
	fileSize=$(stat -c '%s' $srcPath)
    fi
    if [ 0 -ge $fileSize ]; then
	echo "ERROR: Insufficient file size $fileSize for: $srcPath"
	exit $XDDMCP_INVALID_CONFIG
    fi

    # Start destinations
    xddmcp_start_destinations $fileSize

    # Pause to let everything get initialized
    sleep $XDDMCP_CONNECT_DELAY_SECS

    # Start sources
    xddmcp_start_sources $fileSize

    # Collect statuses
    wait

    return 0
}

#
# Include xddcp script source
#
xddmcp_include_xddcp

# Main
xddmcp_main $*
exit $?
