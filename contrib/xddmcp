#!/bin/bash
#
# This is the multi-host XDD data movement script.  If you want to move a 
# file from a single source to a single destination, you probably want xddcp.  
# The xddcp script works similarly to bbcp and scp, it just drives the disk 
# alot faster.  But if you're here, then you want to go faster than a single 
# host can drive.  Welcome to where the sidewalk ends.
#

#
# Global constants
#
XDDMCP_DEFAULT_CONFIG=".xddmcprc"
XDDMCP_ORDER_LOOSE_ID=1
XDDMCP_ORDER_NONE_ID=2
XDDMCP_ORDER_SERIAL_ID=3
XDDMCP_ORDER_STRICT_ID=4

#
# Error codes
#
XDDMCP_INVALID_CMD_LINE=1
XDDMCP_INVALID_FLOW_SPEC=2
XDDMCP_INVALID_NET_SPEC=3
XDDMCP_INVALID_STORAGE_SPEC=4
XDDMCP_INVALID_CONFIG_SYNTAX=5

#
# Global variables
#
g_storageCount=0
g_storageNames[0]=0
g_storageDIO[0]=0
g_storageOrdering[0]=0

g_networkCount=0
g_networkNames[0]=0
g_networkThreads[0]=0

g_flowCount=0
g_flowSrcHost[0]=""
g_flowSrcIface[0]=""
g_flowSrcStorageId[0]=""
g_flowNetworkId[0]=""
g_flowDestHost[0]=""
g_flowDestIface[0]=""
g_flowDestStorageId[0]=""

#
# Print out the usage information
#
function xddmcp_print_usage() {
    echo "xddmcp [OPTIONS] source_file destination_file [size]"
    echo ""
    echo "source_file       - complete /filepath/name for source file on source host"
    echo "destination_file  - complete /filepath/name for destination file on "
    echo "                    destination host"
    echo "size              - number of bytes to transfer [Default: size of source file]"
    echo ""
    echo "OPTIONS: "
    echo " -a		- Resume transfer if it was only partially completed "
    echo "                and the -a flag was specified"
    echo " -c <file>    - Provide an xddmcp config file"
    echo " -h		- Print out usage information"
    echo "NOTE: 'xdd.Linux' must be in your PATH on both source and destination hosts!!"
}

#
# Add xddcp functions to namespace
#
function xddmcp_include_xddcp() {

    # This is done to reuse the transfer functions of xddcp.  It's slightly messy, 
    # but if you are reading the source to *this* script, then you are already in 
    # the weeds and signed up for understanding complexity.  We overload exit 
    # because trap EXIT doesn't prevent an enventual call to exit.  We then unset 
    # the overload after sourcing the appropriate file(s).
    #
    xddcp_path=$(which xddcp)
    if [ -f "$xddcp_path" ]; then
        exit() { :; }
        source $xddcp_path >/dev/null
        unset -f exit
    else
        echo "ERROR: Could not find xddcp"
        exit 1
    fi
}

#
# Locate xddmcp config file from several possible locations
#
function xddmcp_locate_config_file() {
    local configFile=$1

    if [ -z "$configFile" ]; then
	# Check environment variable
	if [ ! -z "$XDD_CONFIG_FILE" -a -f "$XDD_CONFIG_FILE" ]; then
	    configFile=$XDD_CONFIG_FILE
	# Check home directory
	elif [ -f "$HOME/xddmcp.conf" ]; then
	    configFile=$HOME/xddmcp.conf
	# Check /etc
	elif [ -f /etc/xddmcp.conf ]; then
	    configFile=/etc/xddmcp.conf
	fi
    fi
    echo "$configFile"
}

#
# Parse a xddmcp network entry
#
function xddmcp_parse_network_entry() {
    local networkName=$1
    local networkSpec=$2

    # Parse thread count and DIO out of channel spec
    declare -i threads=$(echo $networkSpec |cut -f 1);
    if [ 1 -gt "$threads" ]; then
	echo "ERROR: Invalid thread count."
	exit $XDDMCP_INVALID_NET_SPEC
    fi

    # Setup the channel data
    g_networkNames[$g_networkCount]=$networkName
    g_networkThreads[$g_networkCount]=$threads
    
    # Increment the channel count
    g_networkCount=$((g_networkCount + 1))
    return 0
}

#
# Parse a xddmcp storage entry
#
function xddmcp_parse_storage_entry() {
    local storageName=$1
    local storageOpts=$2

    # Parse DIO flag out
    local dioFlag=$(echo $storageOpts |grep -c -i dio)
    if [ 1 -lt $dioFlag ]; then
	dioFlag=1
    fi

    # Parse thread ordering
    local orderId=$XDDMCP_ORDER_NONE_ID
    declare -u orderString=$(echo $storageOpts |grep -o -i -e "(loose|strict|none)")
    if [ -z "$orderString" ]; then
	orderId=$XDDMCP_ORDER_NONE_ID
    elif [ "LOOSE" = "$orderString" ]; then
	orderId=$XDDMCP_ORDER_LOOSE_ID
    elif [ "NONE" = "$orderString" ]; then
	orderId=$XDDMCP_ORDER_NONE_ID
    elif [ "SERIAL" = "$orderString" ]; then
	orderId=$XDDMCP_ORDER_SERIAL_ID
    else
	echo "ERROR: Unsupported ordering option: $orderString"
	exit $XDDMCP_INVALID_STORAGE_SPEC
    fi

    # Setup the storage data
    #echo "Channel $channelName: $threads $srcDIO $destDIO"
    g_storageNames[$g_storageCount]=$storageName
    g_storageDIO[$g_storageCount]=$dioFlag
    g_storageOrdering[$g_storageCount]=$orderId
    
    # Increment the storage count
    g_storageCount=$((g_storageCount + 1))
    return 0
}

#
# Parse a xddmcp flow entry
#
function xddmcp_parse_flow_entry() {
    local token=$1
    local connectionSpec=$2
    #echo "Flow: $token $connectionSpec"
    
    # Source storage id
    local srcStore=$token
    declare -i srcStoreId=-1
    for ((i=0; i<$g_storageCount; i+=1)); do
	if [ "$srcStore" = "${g_storageNames[$i]}" ]; then
	    srcStoreId=$i
	    break
	fi
    done
    if [ -1 -eq $srcStoreId ]; then
	echo "ERROR: Unknown source storage name: $srcStore" >/dev/stderr
	exit $XDDMCP_INVALID_FLOW_SPEC
    fi
    
    # Skip ->

    # Determine if the first token has an interface or not
    local srcSpec=$(echo $connectionSpec |cut -f 2 -d ' ')
    declare -i colonCount=$(echo $destSpec |grep -c :)
    local srcHost=$srcSpec
    local srcIface=$srcHost
    if [ 1 -eq $colonCount ]; then
	srcHost=$(echo $srcSpec |cut -f 1 -d ':')
	srcIface=$(echo $srcSpec |cut -f 2 -d ':')
    elif [ 0 -ne $colonCount ]; then
	echo "Invalid destination specification: $destSpec" >/dev/stderr
	exit $XDDMCP_INVALID_FLOW_SPEC
    fi

    # Skip ->

    # Parse determine network
    local networkName=$(echo $connectionSpec |cut -f 4 -d ' ')
    declare -i networkId=-1
    for ((i=0; i<$g_networkCount; i+=1)); do
	if [ "$networkName" = "${g_networkNames[$i]}" ]; then
	    networkId=$i
	    break
	fi
    done
    if [ -1 -eq $networkId ]; then
	echo "ERROR: Unknown network name: $networkName" >/dev/stderr
	exit $XDDMCP_INVALID_FLOW_SPEC
    fi
    
    # Skip ->

    # Determine if host has an interface of not
    local destSpec=$(echo $connectionSpec |cut -f 6 -d ' ')
    declare -i colonCount=$(echo $destSpec |grep -c :)
    local destHost=$destSpec
    local destIface=$destHost
    if [ 1 -eq $colonCount ]; then
	destHost=$(echo $destSpec |cut -f 1 -d ':')
	destIface=$(echo $destSpec |cut -f 2 -d ':')
    elif [ 0 -ne $colonCount ]; then
	echo "ERROR: Invalid destination specification: $destSpec" >/dev/stderr
	exit $XDDMCP_INVALID_FLOW_SPEC
    fi

    # Skip ->

    # Determine the destination store
    local destStore=$(echo $connectionSpec |cut -f 8 -d ' ')
    declare -i destStoreId=-1
    for ((i=0; i<$g_storageCount; i+=1)); do
	if [ "$destStore" = "${g_storageNames[$i]}" ]; then
	    destStoreId=$i
	    break
	fi
    done
    if [ -1 -eq $destStoreId ]; then
	echo "ERROR: Unknown storage name for destination: $srcStore" >/dev/stderr
	exit $XDDMCP_INVALID_FLOW_SPEC
    fi

    # Construct the connection
    g_flowSrc[$g_connectionCount]=$srcHost
    g_flowSrcIface[$g_connectionCount]=$srcIface
    g_flowSrcStorageId[$g_connectionCount]=$channelId
    g_flowDest[$g_connectionCount]=$destHost
    g_flowDestIface[$g_connectionCount]=$destIface
    g_flowDestStorageId[$g_connectionCount]=$channelId
    g_flowNetworkId[$g_connectionCount]=$channelId

    # Increment the connection count
    g_connectionCount=$((g_connectionCount + 1))
    return 0
}


#
# Parser for xddmcp config files (only requires lexical analysis)
#
function xddmcp_parse_config() {
    local configFile=$1

    local tok0=""
    local remainder=""
    local state="null"
    local lp=0
    while read tok0 remainder; do
        lp=$((lp + 1))
        local res=1
        local first_char=$(echo "$tok0"| cut -c1)
        if [ "#" == "$first_char" -o -z "$tok0" ]; then
            continue
        elif [ "[" == "$first_char" ]; then
            state=$tok0
            if [ "[flows]" == "$state" -o "[network]" == "$state" -o "[storage]" == "$state" ]; then
                res=0
            fi
        elif [ "[flows]" == "$state" -a ! -z "$tok0" ]; then
            xddmcp_parse_flow_entry "$tok0" "$remainder"
            res=$?
        elif [ "[network]" == "$state"  -a ! -z "$tok0" ]; then
            xddmcp_parse_network_entry "$tok0" "$remainder"
            res=$?
        elif [ "[storage]" == "$state"  -a ! -z "$tok0" ]; then
            xddmcp_parse_storage_entry "$tok0" "$remainder"
            res=$?
        fi

        if [ 0 -ne "$res" ]; then
            echo "$configFile: line $lp: Invalid config syntax"
            exit 37
        fi
    done < $configFile

    echo "Config successfully parsed."
}

#
# Partition the file evenly among the number of processes on 1024-byte aligned
# boundaries
#
function xddmcp_partition() {
    local fileSize=$1
    local rank=$2
    local size=$3
    local outBegin=$4
    local outPartitionSize=$5

    # Determine the partion beginning
    local partLB=0
    let "partLB = ($rank * ($fileSize / 1024) / $size) * 1024"
    echo "partLB = $partLB"

    # Determine the partition end
    local partUB=0
    if [ $rank -eq $((size-1)) ]; then
        let "partUB = $fileSize"
    else
        let "partUB = (($rank + 1) * ($fileSize / 1024) / $size) * 1024"
    fi
    echo "partUB = $partUB"

    # Set the outbound parameters
    let "$outBegin=$partLB"
    let "$outPartitionSize= $partUB - $partLB"
}

#
# Main
#
function xddmcp_main() {

    #
    # Install necessary signal handlers
    #
    # Note: We still need to pass the signal thru for Posix compliance.  See
    #  http://www.cons.org/cracauer/sigint.html
    #
    trap 'handle_signal_common; trap 2; kill -2 $$' 2 
    trap 'handle_signal_common; trap 3; kill -3 $$' 3 
    trap 'handle_signal_common; trap 15; kill -15 $$' 15

    # Parse arguments
    if [ 2 -gt $# ]; then
	xddmcp_print_usage
	exit 12
    fi

    # Parse options
    local configFile=""
    local resumeFlag=0
    local verboseFlag=0

    while getopts ":ac:hv" option; do
        case $option in
            a) 
                resumeFlag=1
                ;;
	    c) 
                configFile=$OPTARG
                ;;
	    h) 
                print_usage 
                return 0
                ;;
	    v) 
                verboseFlag=1
                ;;
            \?)
                echo "INFO: Unsupported option: -$OPTARG" >/dev/stderr 
                error_exit $XDDCP_ERR_CODE_INVALID_ARGS
                ;;
        esac
    done
    shift $((OPTIND-1))

    #
    # Get the source and destination paths
    #
    srcPath=$1
    destPath=$2

    #
    # Validate supplied arguments
    #
    if [ -z "$srcPath" ]; then
	echo "ERROR: Invalid source path specified."
	exit 1
    elif [ -z "$destPath" ]; then
	echo "ERROR: Invalid destination path specified."
	exit 1
    fi

    # Locate config
    configFile=$(xddmcp_locate_config_file $configFile)
    if [ ! -r "$configFile" ]; then
        echo "Can't read config: $configFile"
        exit -1
    fi
    echo "INFO: Using config: $configFile"

    # Parse config
    xddmcp_parse_config $configFile
    exit 0
    fileSize=$(stat -c '%s' $srcPath)

    # Set preconditions
    g_xddcpXddVersion=$(${XDDCP_DEFAULT_XDD} -version)

    # Start destinations
    local rankOffset=0
    local rankPartSize=0
    #g_connectionCount=1
    for ((i=0; i < $g_connectionCount; i+=1)); do
        xddmcp_partition $fileSize $i $g_connectionCount rankOffset rankPartSize
        local channelIdx=${g_connectionChannel[$i]}
        echo "Start dest: ${g_connectionDest[$i]} ${g_channelThreads[$channelIdx]} ${g_channelDestDIO[$channelIdx]}"
#	start_destination_xdd $srcPath $destPath $rankPartSize \
#		${g_channelThreads[$channelIdx]} 40010 \
#		${g_channelDestDIO[$channelIdx]} 0 0 0 0 0 1 \
#		${g_connectionDest[$i]} bws
    done

    # Pause to let everything get initialized
#    sleep 10

    # Start the sources to initiate transfers
    for ((i=0; i < $g_connectionCount; i+=1)); do
        xddmcp_partition $fileSize $i $g_connectionCount rankOffset rankPartSize
        local channelIdx=${g_connectionChannel[$i]}
        echo "Start src: ${g_connectionSrc[$i]} ${g_channelThreads[$channelIdx]} ${g_channelSrcDIO[$channelIdx]}"

#	start_source_xdd $srcPath $rankPartSize \
#		${g_channelThreads[$channelIdx]} 40010 \
#		${g_channelSrcDIO[$channelIdx]} 0 0 0 0 \
#		${g_connectionDest[$i]} 1 \
#		${g_connectionSrc[$i]} bws &
    done

    # Collect statuses
    wait

    return 0
}

#
# Include xddcp script source
#
xddmcp_include_xddcp

# Use a working XDD rather than the current version
#XDDCP_DEFAULT_XDD="/ccs/home/bws/software/xdd-7.0.0.rc14/bin/xdd.$(/bin/uname)"

# Main
xddmcp_main $*
exit $?
