#!/bin/bash
#
# This is the multi-host XDD data movement script.  If you want to move a 
# file from a single source to a single destination, you probably want xddcp.  
# The xddcp script works similarly to bbcp and scp, it just drives the disk 
# alot faster.  But if you're here, then you want to go faster than a single 
# host can drive.  Welcome to where the sidewalk ends.
#

#
# Global constants
#
XDDMCP_DEFAULT_CONFIG=".xddmcprc"

#
# Global variables
#
g_channelCount=0
g_channelNames[0]=0
g_channelThreads[0]=0
g_channelSrcDIO[0]=0
g_channelDestDIO[0]=0

g_connectionCount=0
g_connectionSrc[0]=""
g_connectionDest[0]=""
g_connectionChannelIdx[0]=0

#
# Print out the usage information
#
function xddmcp_print_usage() {
    echo "xddmcp [OPTIONS] source_file destination_file [size]"
    echo ""
    echo "source_file       - complete /filepath/name for source file on source host"
    echo "destination_file  - complete /filepath/name for destination file on destination host"
    echo "size              - number of bytes to transfer [Default: size of source file]"
    echo ""
    echo "OPTIONS: "
    echo " -a		- Resume transfer if it was only partially completed and the -a flag was specified"
    echo " -c <file>    - Provide an xddmcp config file"
    echo " -h		- Print out usage information"
    echo "NOTE: 'xdd.Linux' must be in your PATH env on both source and destination hosts!!!"
}

#
# Parse a xddmcp channel
#
function xddmcp_parse_channel() {
    local channelSpec=$1

    local channelName=$(echo $channelSpec |cut -f 1)

    # Setup the channel data
    #g_channelNames[$g_channelCount]=$channelName
    #g_channelThreads[$g_channelCount]=4
    #g_channelDestDIO[$g_channelCount]=1
    #g_channelSrcDIO[$g_channelCount]=1
    
    # Hardcode the channel info for now
    g_channelNames[$g_channelCount]=usn_xfs
    g_channelThreads[$g_channelCount]=36
    g_channelDestDIO[$g_channelCount]=1
    g_channelSrcDIO[$g_channelCount]=1

    # Increment the channel count
    g_channelCount=$((g_channelCount + 1))
    return 0
}

#
# Parse a xddmcp connection
#
function xddmcp_parse_connection() {
    local connectionSpec=$1

    # Hard code the connections
    g_connectionSrc[0]="192.168.1.3"
    g_connectionDest[0]="192.168.1.4"
    g_connectionChannelIdx[0]=0

    g_connectionSrc[1]="192.168.1.10"
    g_connectionDest[1]="192.168.1.11"
    g_connectionChannelIdx[1]=0

    # Increment the connection count
    g_connectionCount=$((g_connectionCount + 1))
    g_connectionCount=2

    return 0
}


#
# Parser for xddmcp config files (only requires lexical analysis)
#
function xddmcp_parse_config() {
    local configFile=$1

    local tok0=""
    local remainder=""
    local state="null"
    local lp=0
    while read tok0 remainder; do
        lp=$((lp + 1))
        local res=1
        local first_char=$(echo "$tok0"| cut -c1)
        echo "Token: $tok0"
        if [ "#" == "$first_char" -o -z "$tok0" ]; then
            continue
        elif [ "[" == "$first_char" ]; then
            state=$tok0
            echo "Setting state to: $state"
            if [ "[connections]" == "$state" -o "[channels]" == "$state" ]; then
                res=0
            fi
        elif [ "[connections]" == "$state" -a ! -z "$tok0" ]; then
            xddmcp_parse_connection "$tok0" "$remainder"
            res=$?
        elif [ "[channels]" == "$state"  -a ! -z "$tok0" ]; then
            xddmcp_parse_channel "$tok0" "$remainder"
            res=$?
        fi

        if [ 0 -ne "$res" ]; then
            echo "$configFile: line $lp: Invalid config syntax"
            exit 37
        fi
    done < $configFile

    echo "Config successfully parsed."
}

#
# Partition the file evenly among the number of processes on 1024-byte aligned
# boundaries
#
function xddmcp_partition() {
    local fileSize=$1
    local rank=$2
    local size=$3
    local outBegin=$4
    local outPartitionSize=$5

    # Determine the partion beginning
    local partLB=0
    let "partLB = ($rank * ($fileSize / 1024) / $size) * 1024"
    echo "partLB = $partLB"

    # Determine the partition end
    local partUB=0
    if [ $rank -eq $((size-1)) ]; then
        let "partUB = $fileSize"
    else
        let "partUB = (($rank + 1) * ($fileSize / 1024) / $size) * 1024"
    fi
    echo "partUB = $partUB"

    # Set the outbound parameters
    let "$outBegin=$partLB"
    let "$outPartitionSize= $partUB - $partLB"
}

#
# Main
#
function xddmcp_main() {

    #
    # Install necessary signal handlers
    #
    # Note: We still need to pass the signal thru for Posix compliance.  See
    #  http://www.cons.org/cracauer/sigint.html
    #
    trap 'handle_signal_common; trap 2; kill -2 $$' 2 
    trap 'handle_signal_common; trap 3; kill -3 $$' 3 
    trap 'handle_signal_common; trap 15; kill -15 $$' 15

    # Parse arguments
    #xddmcp_print_usage

    # Locate config
    configFile=$HOME/xddmcp.conf
    if [ ! -r "$configFile" ]; then
        echo "Can't find config: $configFile"
        exit -1
    fi

    # Parse config
    xddmcp_parse_config $configFile

    # Start destinations
    local rankOffset=0
    local rankPartSize=0
    for ((i=0; i < $g_connectionCount; i+=1)); do
        xddmcp_partition 5000000000000 $i $g_connectionCount rankOffset rankPartSize
        local channelIdx=${g_connectionChannel[$i]}
        echo "Start dest: ${g_connectionDest[$i]} ${g_channelThreads[$channelIdx]} ${g_channelDestDIO[$channelIdx]}"
    done

    # Pause to let everything get initialized
    sleep 0

    # Start the sources to initiate transfers
    for ((i=0; i < $g_connectionCount; i+=1)); do
        xddmcp_partition 5000000000000 $i $g_connectionCount rankOffset rankPartSize
        local channelIdx=${g_connectionChannel[$i]}
        echo "Start src: ${g_connectionSrc[$i]} ${g_channelThreads[$channelIdx]} ${g_channelDestDIO[$channelIdx]}"
    done

    # Collect statuses
    
    return 0
}

#
# Include xddcp script source
#
# This is done to reuse the transfer functions of xddcp.  It's slightly messy, 
# but if you are reading the source to *this* script, then you are already in 
# the weeds and signed up for understanding complexity.  We overload exit 
# because trap EXIT doesn't prevent an enventual call to exit.  We then unset 
# the overload after sourcing the appropriate file(s).
#
xddcp_path=$(which xddcp)
if [ -f $xddcp_path ]; then
    exit() { :; }
    source $xddcp_path >/dev/null
    unset -f exit
else
    echo "ERROR: Could not find xddcp"
    exit 1
fi


# Main
xddmcp_main
exit $?